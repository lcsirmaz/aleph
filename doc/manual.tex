\documentclass{article}

\usepackage{xcolor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% grammar is typeset in \sf font.
%% the {grammar} environment uses lines with \tem
% add extra sapce around []
{\catcode`\[=\active\catcode`\]=\active%
\gdef\mkoptions{\catcode`\[\active\def[{\kern0.05em\char91\kern0.12em\relax}%
\catcode`\]\active\def]{\kern0.1em\char93\kern0.05em\relax}%
}}%
\newcommand\g[1]{{\color{blue!50!black}\sf #1}}
%\renewcommand\ast{\,\raisebox{-0.2ex}{\bt*}}
\renewcommand\ast{\kern0.08em{\tt*}}%{\,{\bt*}}
\newcommand\plus{\kern0.08em{\tt+}}%{\,{\bt+}}
\newcommand\no[1]{}

\newenvironment{grammar}{%
\begin{list}{}{%
\setlength\leftmargin{18pt}%
\setlength\rightmargin{-5pt}%
\setlength\listparindent{20pt}%
\setlength\itemsep{1pt plus0.2ex}%
\setlength\parsep{0pt plus 2pt}%
\setlength\labelsep{-5pt}%
\setlength\topsep{3pt plus 2pt}
}\sf\mkoptions\color{blue!50!black}%
}{\end{list}}
\renewenvironment{itemize}{\begin{list}{}{%
\advance\leftmargin by -8pt%
\setlength\itemsep{0ex plus 0.2ex}%
\setlength\partopsep{3pt}%
\setlength\topsep{2pt plus 2pt}%
\setlength\parsep{0pt plus 2pt}%
}}{\end{list}}

% add and 's' or 'es' after a grammatical notion
\renewcommand\/{\kern 0.066em}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% definiting steps of an algorithm
\newenvironment{steps}[1]{\smallskip\noindent {#1}
\list{}{%
\advance\leftmargin by -16pt%
\setlength\itemsep{0ex plus 0.2ex}%
\setlength\partopsep{3pt}%
\setlength\topsep{2pt plus 2pt}%
\setlength\parsep{0pt plus 2pt}%
}\item\relax}{\endlist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% bibliography is a subsection, removing the section head
\makeatletter
\renewenvironment{thebibliography}[1]
     {\list{\@biblabel{\@arabic\c@enumiv}}%
           {\settowidth\labelwidth{\@biblabel{#1}}%
            \leftmargin\labelwidth
            \advance\leftmargin\labelsep
            \@openbib@code
            \usecounter{enumiv}%
            \let\p@enumiv\@empty
            \renewcommand\theenumiv{\@arabic\c@enumiv}}%
      \sloppy
      \clubpenalty4000
      \@clubpenalty \clubpenalty
      \widowpenalty4000%
      \sfcode`\.\@m}
     {\def\@noitemerr
       {\@latex@warning{Empty `thebibliography' environment}}%
      \endlist}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% program listing is done using lmtt fixed font
%%   words within '' are typeset in bold
%%   disabling '' and ,, and << >> ligatures.
\def\GREEN{\color{green!30!black}\tt}
\DeclareFixedFont{\tt}{T1}{lmtt}{m}{n}{9.2pt}
\DeclareFixedFont{\tft}{T1}{lmtt}{m}{n}{8.5pt}
\DeclareFixedFont{\bt}{T1}{lmtt}{b}{n}{9.2pt}
%% \mkbold sets space, comma, apostrophy active
%%   and defined words between '' to be typeset in bold
%% \pp|text| is an inline program
%% \begin{program} ... \end{program} is a displayed program
{\catcode`\'=\active\catcode`\ =\active\catcode`\,=\active%
\catcode`\$=12\catcode`\<\active\catcode`\>\active%
\gdef\mkbold{\catcode`\'\active\def'##1'{\char39\relax{\bt##1}\char39\relax}%
\catcode`\,\active\def,{\char44\relax}%
\catcode`\<\active\def<{\char60\relax}%
\catcode`\>\active\def>{\char62\relax}%
\catcode`\$=12\catcode`\#=12\catcode`\^=12%
\catcode`\ \active\def {\nobreakspace}}}
\newenvironment{program}{%
\ignorespaces
\par\vskip 5pt plus 2pt minus 2pt
\leftmargin=20pt
\parindent=0pt%\tt
\catcode`\$=12\catcode`\^=12
\mkbold
\obeylines
\leftskip 8pt
\baselineskip=0.9\baselineskip
\everypar\expandafter{\the\everypar\unpenalty}%
\GREEN%
}{\vskip 6pt plus 2pt minus 1pt}
%%
\makeatletter
{\catcode`\'=\active\catcode`\ =\active\catcode`\,=\active%
\catcode`\$=12\catcode`\^=12\catcode`\|=\active\catcode`\<\active\catcode`\>\active%
\gdef\pp#1{\relax\begingroup
\catcode`\$=12\catcode`\~=12\catcode`\^=12%
\catcode`\|\active\let|\endgroup
\catcode`\ \active\def {\space}%\nobreakspace
\catcode`\'\active\def'##1'{\char39\relax{\bt##1}\char39\relax}%
\catcode`\<\active\def<{\char60\relax}%
\catcode`\>\active\def>{\char62\relax}%
\catcode`\#=12\catcode`\^=12%
\GREEN%
%\tt
}%
}
%% moving :: closer
\def\cc{\kern-0.2pt:\kern-1pt:\kern-0.5pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subsubsubsection
%\makeatletter
%\setcounter{secnumdepth}{4}
%\newcounter{subsubsubsection}[subsubsection]
%\newcommand*\l@subsubsubsection{\@dottedtocline{4}{7.0em}{4.1em}}
%\renewcommand\thesubsubsubsection{\thesubsubsection.\@arabic\c@subsubsubsection}
%\newcommand\subsubsubsectionmark[1]{}
%\newcommand\subsubsubsection{%
%\@startsection{subsubsubsection}{4}{\z@}%
%   {-3.25ex\@plus -1ex \@minus -.2ex}% {3.25ex \@plus1ex \@minus.2ex}
%   {1ex \@plus .5ex}%             {-1em}
%   {\normalfont\normalsize\bfseries}}
%\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% keywords in two columns (7.2)
\makeatletter
\newenvironment{keywords}{%
\gdef\\{\@ifnextchar[{\@finishline}{\@finishline[0pt]}}%
\gdef\@finishline[##1]{\par\vskip ##1}%
\gdef\G##1{\noindent\rule{30pt}{0pt}\hbox to 0.25\linewidth{\g{ ##1-symbol}\hfil}
   \qquad }%
\gdef\K##1{\noindent\rule{30pt}{0pt}\hbox to 0.25\linewidth{\space ##1\hfil}
   \qquad }%
}{}
\makeatother
\long\def\ignore#1\endignore{}

\hyphenation{name-space}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% hyperref, restore \ref otherwise hyperref blows up
\let\oref\ref
\usepackage[hidelinks=true,bookmarks=false,hyperindex=false]{hyperref}
\def\Ref#1{\rref#1\erref}
\def\rref#1 #2\erref{\hyperref[#2]{#1 \ref{#2}}}
\let\ref\oref
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\A{{\sf ALEPH}}

\title{Aleph Manual}
%\author{D. Grune \and R. Bosch \and L.G.L.T Meertens}
%\date{Fourth printing, 1982}
\author{Laszlo Csirmaz}
\date{April 29, 2025}


\begin{document}
\maketitle

\section*{Preface}

{\A} -- an acronym for ``{\sf A} {\sf L}anguage {\sf E}ncouraging {\sf
P}rogram {\sf H}ierarchy'' -- is a high-level programming language designed
to provide a tool that effectively helps programmers to structure their
programs in a hierarchical fashion. {\A} is suitable for problems that
suggest top-down analysis, like parsers, search algorithms, combinatorial
problems, artificial intelligence problems, etc. Probably the most
interesting feature of the \A{} language is its unique ``copy, execute,
copy'' parameter passing method. This method prevents modifying parameter
values when the called routine fails as well as it postpones side effects
caused by global parameters until a successful call is completed. Another
\A{} feature is modeling the complete computer memory as a single (virtual)
list of computer words indexed by integers. Continuous segments of this
virtual memory are populated by stacks and tables so that an index (pointer)
determines the stack or table it points to. Stacks can grow and shrink
within their virtual limits which are assigned during compilation. This
memory model allows transferring pointers seamlessly from one \A{} program to
another.

\hyperref[sec:1]{Chapter 1} of this Manual gives a tutorial introduction
into the basics of \A. It is written in a style which can be followed easily
by novice programmes. Chapters 2 to 7 contain a semi-formal definition of
the language. \Ref{Chapter sec:3} treats \emph{rules}, and the control flow
in them. \Ref{Chapter sec:4} is about data types, while \emph{externals} are
treated in \Ref{Chapter sec:5}. \Ref{Chapter sec:6} describes
\emph{pragmats}. The global structure of an \A{} program, including how the
source can be split into files and modules are discussed in \Ref{Chapter
sec:units}. Elements of the Standard Library in \Ref{Chapter 5.2}, program
representation in \Ref{Chapter sec:7}, and sample programs in \Ref{Chapter
sec:8} close the Manual.

\medskip

This version describes the language as it has been implemented in
\cite{alephcomp}. The Manual is based on, and repeats large parts of the
fourth printing from 1982 \cite{manual}. Many paragraphs have been kept
identical, while many others were rewritten to reflect the implemented
language.

\newpage
\setcounter{tocdepth}{3}
\tableofcontents

\newpage
\section{Informal introduction to Aleph}\label{sec:1}

This chapter gradually develops a small \A{} program, 
interspersing it liberally with annotations and arguments. This introduction
is intended to give some insight into the use of the language \A{} and to
display its main features in a very informal way.

\subsection{The problem and its grammar}\label{1.1}

We want to write a program that reads a series of arithmetic expressions
separated by commas, calculate the value of each expression while reading
it, and subsequently print the value. The expression will contain only
unsigned integers, plus symbols, multiplication symbols and parentheses; and
example might be \pp|15 * (12 + 3 * 9)|.

First we put the requirements for the input to our program in a more
formal form of a context-free grammar. This grammar shows
exactly which symbol we will accept in which position.
\begin{grammar}
\item input: expression, input-tail.
\item input-tail: comma symbol, input; empty.
\item expression: term, plus symbol, expression; term.
\item term: primary, times symbol, term; primary.
\item primary: left-parenthesis, expression, right-parenthesis; integer.
\item integer: digit, integer; digit.
\item empty: .
\end{grammar}
The rule for \g{input} can be read as
\begin{itemize}
\item \sl \g{input} is an \g{expression}
followed by and \g{input-tail};
\end{itemize}
whereas the rule for \g{primary} can be read as 
\begin{itemize}
\item
\sl a \g{primary} is either a \g{left-parenthesis} followed by an
\g{expression} followed by a \g{right-parenthesis}, or an \g{integer}.
\end{itemize}
This grammar shows clearly that, for instance, \pp|15*+3| will not be
accepted as an \g{expression}. The \pp|*| can only be followed by a \g{term},
which always starts with a \g{primary}, which in turn either starts with an
\g{integer} or a \g{left-parenthesis}, but never with a \pp|+|.


\subsection{Rules}\label{1.2}

We now write a series of \A{} rules, one for each rule in the
grammar. For the grammar rule \g{expression} we write an \A{} rule
that, when executed, reads and processes an expression and yields its
result. This \A{} rule looks as follows:
\begin{program}
'action'expression+res>-r:
   term+res,
   (is symbol+/+/,expression+r,add+res+r+res;+).
\end{program}
\noindent
This can be read as
\begin{itemize}\item\sl
an \g{expression}, which must yield a result in
\pp|res| and uses a (local) variable \pp|r|, is \emph{(we are now at the
colon)} a
\g{term} which will yield a result in \pp|res|, followed by either
\emph{(we are now at the left parenthesis)} by a \g{plus-symbol} followed by an
\g{expression} which will yield its result in \pp|r| after which the result
in \pp|res| and the result in \pp|r| will be added to form a new result in
\pp|res|, or \emph{(we are at the semicolon now)} by nothing.
\end{itemize}
We see that this is the old meaning of the grammar rule for \g{expression},
sprinkled with some data-handling. This data-handling tells what is to be
done to get the correct result: we could call it the \emph{semantics} of an
\g{expression}. If we remove these paraphernalia from the \A{} rule we
obtain something very similar to the original grammar rule:
\begin{program}
'action'expression1:
    term, (is symbol+/+/,expression1; +).
\end{program}
\noindent
This rule, while it is still correct \A, does no data handling, and,
consequently, will not yield a result. It could, for example, be used to
skip an \g{expression} in the input.

We now direct our attention back to the \A{} rule \pp|expression| and
consider what happens when it is ``executed''. First, \pp|term| is executed
and will yield a result in \pp|res|. It does so because we will define
\pp|term| so that it will. Then we meet a series of two alternatives
separated by a semicolon (\emph{either} a this \emph{or} a that). First, an
attempt is made to execute the first alternative by asking \pp|is
symbol+/+/|. This is a \emph{question} (because we will define it so) which
is answered positively if indeed the next symbol is a \pp|+| (in which case
the \pp|+| will be discarded after reading), or negatively, if the next
symbol is something else.

If \pp|is symbol+/+/| ``succeeds'' the remainder of the first alternative is
executed, meaning \pp|expression+r| is called (recursively), yielding its
result in \pp|r|, and subsequently \pp|add+res+r+res| is called, putting the
sum of \pp|res| and \pp|r| in \pp|res|. The call of \pp|expression+r| works
because we just defined what it should do. \pp|add| is the name known to the
compiler and has a predefined meaning. However, if we are dissatisfied with
its workings we could define our own rule for it. Now this alternative is
finished, so the parenthesized part is finished, which brings us to the end
of the execution of the rule \pp|expression|.

If \pp|is symbol+/+/| ``fails'', the next alternative after the semicolon is
tried. This alternative consists of a single \pp|+| which is a dummy
statement that always succeeds. Without further action we reach the end of
the rule \pp|expression|.

The above indicates the division of responsibility between the language and
the programmer. The language provides a framework that controls which rules
are called depending on the answers obtained from other rules. The
programmer must fill in this framework by defining what action must be
performed by a specific rule, and what question must be asked. These
definitions again will have the form of rules that do something (as defined
by the programmer) embedded in a framework that controls their order (which
is supplied by the language). It is clear that this process must end
somewhere. It can end in one of two ways.

It may appear that the action needed is supplied by \A. There are some basic
primitives in the language, such as copying of a value, comparing two
values, and extending a stack by a fixed number of given values. Often,
however, these primitives are not sufficient. In such cases the rule is
declared to be \pp|'external'|, and its actions are specified in a different
way. A number of such external rules are predefined, including the rule
\pp|add| used above. This predefined set of rules probably suffice for most
applications.

We now pay some attention to the exact notation (syntax) of the rule
\pp|expression|. All rules have the property that when they are called they
are either guaranteed to succeed or they may fail. The word \pp|'action'|
indicates that a call of this rule is guaranteed to succeed. The name of the
rule is \pp|expression|, and \pp|res| is its only formal ``affix''
(parameter). The \pp|+| serves as a separator as it \emph{affixes} the affix
to the rule. The right arrowhead (\pp|>|) indicates that the resulting value
of \pp|res| will be passed back to the calling rule. This means that
\pp|expression| has the obligation to assign a value to \pp|res| under all
circumstances since \pp|res| is an output parameter, guaranteed to receive a
value. If the text of the rule does not support this claim, the compiler
will discover it and issue an error message. The \pp|+| sign and the term
\emph{affix} stem from the theory of affix grammars of which \A{} is based
on \cite{koster71b,watt77}.

The \pp|-r| specifies \pp|r| as a local affix (local variable) of the rule,
and the colon closes the left hand side. The \pp|+| in \pp|term+res| appends
the actual affix \pp|res| to the rule \pp|term|, the comma separates calls
of rules. The parentheses group both alternatives into one action. The
\pp|+| between slashes (indicating ``absolute value'') represents the
integer value of the plus symbol. The semicolon separates alternatives,
which are checked in textual order. As said before, the stand-alone \pp|+|
denotes the dummy action that always succeeds. Finally, the period ends the
rule.

\subsection{Further rules}\label{1.3}
In view of the above, the rule for \g{term} should not be a surprise:
\begin{program}
'action'term+res>-r:
   primary+res,
    (is symbol+/*/, term+r, mult+res+r+res;+).
\end{program}
\noindent
Now, we are tempted to render the rule for \g{primary} as:
\begin{program}
'action'primary+res>:
   is symbol+/(/, expression+res, is symbol+/)/;
   integer+res.
\end{program}
\noindent
but here the compiler would discover that we did not specify what should be
done if the second call of \pp|is symbol| fails. If that happens, we would
have recognized, processed and skipped a \g{left-parenthesis} and a complete
\g{expression}, to find that the corresponding \g{right-parenthesis} is
missing. This means that the input is incorrect; we now decide that we do
not do any error recovery, instead give an error message and stop the
program. The modified version of the \pp|primary| rule is then:
\begin{program}
'action'primary+res>:
   is symbol+/(/,expression+res,
      (is symbol+/)/;error+no paren);
   integer+res.
\end{program}
\noindent
Here the two alternatives between parentheses behave like one action that will
always succeed: either the right parenthesis is present in the input, or an
error will be signaled. \pp|no paren| is a constant that will be specified
later on.

Writing a rule for reading an integer is trickier than it seems to be.
%For a comprehensive account on how to obtain correct and incorrect versions
%of it the reader is referred to \cite{koster71a}. We shall confine ourselves to
%giving one correct version.
Our version consists of two rules and is about as complicated as necessary.
\begin{program}
'action'integer+res>:
   digit+res,integer1+res;
   error+no int.
\smallskip
'action'integer1+>res>-d:
   digit+d,mult+res+10+res,add+res+d+res,integer1+res;
   +.
\end{program}
\noindent
The rule \pp|integer| asks for a digit. If present, its value will serve as
the initial value of \pp|res|. The value of \pp|res| is then passed to
\pp|integer1|. If no digit is present an error message is issued. The
rule \pp|integer| must assign a value to \pp|res| under all circumstances.
This requirement is not violated here as \pp|error| will be specified as 
a non-returning, \pp|'exit'| rule.

The rule \pp|integer1| processes the tail of the integer. If there is such a
tail, it starts with a digit, so the first alternative asks \pp|digit+d|. If
so, a new result is calculated from the previous one and the digit \pp|d| by
making \pp|res| equal to \pp|res*10+d| and \pp|integer1| is called again (to
see if there are more digits to come). If there was no digit, we have
processed the whole integer and \pp|res| contains its value.

The right arrow-head in front of \pp|res| means that the calling rule will
have assigned a value to this affix just before calling \pp|integer1|, i.e.,
\pp|res| is ``initialized''. The right arrow-head after \pp|res| again
indicates that the resulting value will be passed back to the calling rule.

A more convenient way of reading an integer is provided by the rule
\pp|get int| from the Standard Library.


\subsection{Input}\label{1.4}

The above forms the heart of our program. We now supply some input and
output definitions. For input we will use the predefined \A{} character file
\pp|STDIN|, which provides the characters entered at the console.
Additionally, the global variable \pp|buff| will contain the first character
not yet processed. Comments in \A{} start with a \pp|$| and end with another
\pp|$| or at the end of the line, whichever comes first.

\begin{program}
$ Input\no$
'variable'buff=/ /.
\end{program}
\noindent
The variable \pp|buff| is initialized with the code for the space character
(there being no uninitialized variables in \A). We are now in a position to
give two rule definitions that were still missing.
\begin{program}
'predicate'is symbol+>n: buff=n, get next symbol.
\smallskip
'predicate'digit+d>:
  =buff=
  [/0/:/9/], subtr+buff+/0/+d, get next symbol;
  [   :   ], -.
\end{program}
\noindent
These require some more explanation, mainly concerning the notation. The
word \pp|'predicate'| indicates that \pp|is symbol| is not an action but a
question, or more precisely a \emph{committing} question as opposed to a
\emph{non-committal} question. A non-committal question is a question that,
regardless of the answer it yields, makes no global changes, does not do
anything irreversible. A committing question is a question that, when
answered positively, does make global (and often irreversible) changes. To
give an example, ``{\sl Are there plane tickets to New York for less than
\$1000?\,}'' is a non-committal question, whereas ``{\sl Are there plane
tickets for New York for less than \$1000? If so, I want one.}'' is a
committing question.

In the case of \pp|is symbol| the (committing) question is: {\sl Is the
symbol in \pp|buff| equal to the one I want? If so, advance the input and
put the next character into \pp|buff|.} The form \pp|buff=n| is a test for
equality, it is one of the primitive operations in \A. The rule \pp|get next
symbol| will be defined below.

Again, the right arrow-head in front of the formal affix \pp|n| indicates
that the calling rule will have assigned a value to it. The absence of a
right arrow-head to the right of the \pp|n| indicates that the value of
\pp|n| (which may have been changed) will not be passed back to the calling
rule.

The rule for \pp|digit| (again a \pp|'predicate'|) shows another feature of
\A, the \g{classification}. Classes are specified by the values presented in
square brackets, for each possible value of \pp|buff| they specify which of
the alternatives will be chosen. Thus for values of \pp|buff| that lie
between the code for \pp|0| and the code for \pp|9| the first alternative
is chosen. For all other values the next alternative---consisting of the
dummy question that always fails, denoted by the dash---will be chosen. The rule
\pp|digit| is equivalent to
\begin{program}
'predicate'digit+d>:
   between+/0/+buff+/9/,subtr+buff+/0/+d,get next symbol.
\end{program}
\noindent
assuming that \pp|between+/0/+buff+/9/| succeeds if and only if the value of
\pp|buff| is between \pp|/0/| and \pp|/9/|. Classification is analogous to the
case statement in other programming languages.

%All the arithmetic used here on symbols is based on the assumption that the
%numerical codes associated with the characters \pp|0| through \pp|9| are a
%set of consecutive integers in ascending order. The numerical value of a
%digit symbol can then indeed be obtained by subtracting the code for \pp|0|
%from its numerical value.

One more input rule must be supplied:
\begin{program}
'action'get next symbol:
   get char+STDIN+buff,
      ((buff=/ /; buff=newline), get next symbol;
       + );
   stop->buff.
\smallskip
'constant'stop=-1.
\end{program}
\noindent
\pp|get char| is an (external) rule known to the compiler. It tries to read
the next character from the \A{} file indicated by its first affix, which is
\pp|STDIN|. If there is a character, it puts it in its second affix (here
\pp|buff|); if there are no more characters, the rule fails. In the latter 
case \pp|buff| is given the value \pp|stop|, which is defined in a 
\g{constant-declaration} to be \pp|-1|.

If \pp|get char| returns a character and if this is a space or a newline,
\pp|get char| is called again. We've used nested parenthesizing. This
definition of \pp|get next symbol| implies that we have decided that spaces
and newlines are allowed in the input in all positions (a decision that was
not present in the initial grammar).

\subsection{Output}\label{1.5}
The output is as follows:
\begin{program}
$ output\no$
'action'print integer+>int:
   out integer+int,put char+STDOUT+newline.
'action'out integer+>int-rem:
   divrem+int+10+int+rem,add+rem+/0/+rem,
   (int=0;out integer+int),put char+STDOUT+rem.
\end{program}
\noindent
The rule \pp|put char| is known to the compiler, as are \pp|STDOUT| and
\pp|divrem|. The call of the latter has the effect that \pp|int| is divided
by 10, the quotient is placed back to \pp|int| and the remainder to
\pp|rem|. This splits the number into its last digit and its head; if this
head (now in \pp|int|) is not zero it must be printed first, which is
done by the recursive call of \pp|out integer|. Subsequently, the last
digit is printed through a call of \pp|put char|. This is a simple way of
printing a number. A more convenient way of printing an integer is provided
by the Standard Library rule \pp|print int|.

The predefined character file \pp|STDOUT| sends characters to the console directly.

For the printing of error messages we will need some string handling. Strings
do not constitute a special data type in \A; they are handled, like all
other complicated data types, by putting them into \g{stack}\/s and 
\g{table}\/s and are operated upon by suitably defined rules (in this case
supplied by the system).

The error handler takes the following form:
\begin{program}
$ Error-message printing\no$
'exit'error+>er:
   put string+STDOUT+strings+er,put char+STDOUT+newline,
     exit+1.
\smallskip
'table'strings[]=
  ("Right parenthesis missing":no paren,
   "Integer missing":no int
  ).
\end{program}
\noindent
The table \pp|strings| contains two strings stored in compressed form;
they can be reached under the names \pp|no paren| and \pp|no int|. The call
of \pp|put string| takes the affix \pp|er|, looks in the table \pp|strings|
under the entry corresponding to \pp|er| and transfers the string thus found
to \pp|STDOUT| for printing.

The rule call \pp|exit+1| never returns, it terminates the program
while \pp|1| will be passed to the operating system as an indication what
went wrong. This is by no means the normal program termination: normal
program termination ensues when all work is done. The rule \pp|error| is
defined to be of type \pp|'exit'| indicating that this rule never returns,
in particular it neither succeeds nor fails.

\subsection{Starting the program}\label{1.6}

The rule for reading an \g{expression} (\pp|expression|) and the one for
printing an \g{integer} (\pp|print integer|) can now be combined into the rule
\pp|input| (see the grammar at the beginning of this chapter).
\begin{program}
'action'input-int:
   expression+int, print integer+int,
     (is symbol+/,/, input;+).
\end{program}
\noindent
This rule combines the grammar rule for \g{input} and \g{input tail}.
Instead of translating \g{empty} by \pp|+|, we could make a test to see
whether we have indeed reached the end of the file:
\begin{program}
     (buff=stop; error+no end)
\end{program}
\noindent
We now remember our convention that \pp|buff| contains the first symbol not
yet recognized, and realize that \pp|buff| must be initialized with the
first non-space symbol of the input:
\begin{program}
'action'initialize: get next symbol.
\smallskip
'action'read expressions and print results: initialize,input.
\end{program}

At this point the reader will have noticed that until know we have only
defined rules that will do something if they are executed (called), and
which will then call other rules. Does \A{} contain any directly executable
statements at all? The answer is yes, but only one (per program). In our
example it has the following form:
\begin{program}
'root'read expressions and print results.
\end{program}
\noindent
We now indicate the end of our program:
\begin{program}
'end'
\end{program}

\noindent
When the program is run the root rule \pp|read expressions and print
results| is executed. This rule calls \pp|initialize|, which through a call
of \pp|get next symbol| puts the first non-space symbol in \pp|buff|; when
\pp|initialize| is done, \pp|input| is called which calls \pp|expression|
which in turn executes \pp|term|, etc. After a while \pp|input|, which is
called repeatedly, will find \pp|is symbol+/,/| to fail. At that moment it
is done, and so is \pp|read expressions and print results|. The call
specified in the \pp|'root'| instruction is finished: this constitutes the
normal program termination.

We could give the \g{rule-declarations} and \g{data-declarations} in any other
order and the effect would still be the same. The \pp|'end'|,
however, must be the last item of the program.

This brings us to the end of our sample program.

\subsection{Creating a module}\label{1.6a}

Looking back to the context-free grammar in \Ref{Section 1.1} specifying the
problem which was to be solved, we observe that the auxiliary input and
output rules developed in \Ref{Section 1.4} and \Ref{Section 1.5} can be
used more generally. These rules would remain unchanged if the problem, and,
consequently, the grammar describing the problem, changes. Thus we decided to
create an \A{} library module which provides these auxiliary rules ``out of
the box,'' so that they can be used without copying them verbatim into the
main program. The module will contain three of the rules: \pp|is symbol|,
\pp|digit|, and \pp|error|. The rule \pp|get next symbol| and the variable
\pp|buff| are used by these rules only, thus they can be local to our
module. We choose \pp|base| as the module name. According to the best
practice, the name of the file containing the source code of the module
should resemble the module name. It is particularly important as \A{}
modules are invoked by specifying file names and not module names. Thus the
source text of the module will be put into a file named \pp|base.ale|, where
the extension \pp|.ale| indicates that it is an \A{} file.

In general, an \A{} module has two parts: the \emph{head} which specifies
which rules (and other constructs) this module provides, and the \emph{body}
which contains the realization of these resources. When the module is used,
only the head part is consulted, so this part must provide complete
information on the provided items. When the module is compiled, both parts
are processed, letting the compiler check that all promised resources are
indeed defined. Modules use the \A{} \g{pragmat} facility extensively to
control these aspects of compilation.

The overall structure of an \A{} module typically starts with a \g{pragmat}
specifying the module name. It is followed by the module head, followed by
the body. The latter one is enclosed between the conditional \g{pragmat}\/s
\pp|if=compile| and \pp|endif=compile|. Accordingly, we start our module
with the title and head as
\begin{program}
'pragmat'module=base. $ module name\no$
  $ module head\no$
  'predicate'is symbol+>n, digit+d>.
  'exit'error+>er.
\end{program}
\noindent
The first line specifies the module name, informing the compiler at the
same time 
that it is reading a module source. The subsequent \g{prototypes} (rule
heads without rule body) specify
the three rules exported by this module. These rule heads
convey all information needed when they are used. The affix of
\pp|is symbol| will be a character specified by the caller, and \pp|digit| 
will return the value of the next digit in the affix \pp|d|. The affix of 
the \pp|error| rule specifies the error message to be printed; it has been 
chosen to be a pointer to one of the predefined strings
in the table \pp|strings|. Our module needs access to this table (when it
wants to retrieve the error string), and the main program also needs access to
this table (when defining those strings). So the table \pp|strings| will be
\emph{declared} in our module; and will be made available to the main program through a
\g{table-prototype} in the module head, so that the main program can use
\g{filling}\/s to populate this table. Thus we also add the line
\begin{program}
  'table'strings.
\end{program}
\noindent
to the head. The lack of the square brackets after the tag indicates
that this is a \g{prototype} and not a \g{declaration}.

The module body is enclosed between conditional \g{pragmat}\/s to ensure
that it is executed only when the module is compiled. The module body must
also contain a \g{root}. This root is executed before the main root, so it can
perform all necessary initializations. If no initializations are necessary,
this root can consist of a sole dummy action, written as \pp|'root'+.|
In our case the initialization performed by the \pp|initialize| rule can be
transferred here; with this move the main root simplifies to
\begin{program}
  'root'input.
\end{program}
\noindent
Without repeating the rules developed in \Ref{Section 1.4} and \Ref{Section
1.5}, the overall structure of the body of our module will be similar
to the one below.
\begin{program}
'pragmat'if=compile.   $ start of module body\no$
  'table'strings[].            $ table declaration\no$
  'variable'buff=/ /.          $ only in this module\no$
  'constant'stop=-1.           $ only in this module\no$
  'predicate'is symbol+>n: ... $ rule body\no$
  'predicate'digit+d>:  ...    $ rule body\no$
  'exit'error+>er: ...         $ rule body\no$
  'action'get next symbol: ... $ rule body\no$
  'root'get next symbol.       $ initialization\no$
'pragmat'endif=compile.$ end of module body\no$
'end'
\end{program}

\noindent
The rule \pp|get next symbol|, the variable \pp|buff| and the constant
\pp|stop| are declared in the module body, and they are available only in this
module. If the main program wants to check whether the input is exhausted
(as was done in \Ref{Section 1.6}), a possible solution is to add
another \g{rule}, without affixes, to the module head, and define it in
the body to return
success when there are no more input characters, and failure otherwise.

To use items exported by a module, the main program should \emph{require} the
module using the ``require'' pragmat as follows:
\begin{program}
'pragmat'require="base".
\end{program}
\noindent
This pragmat specifies the source file name (possibly with path information and
without extension) enclosed in quote marks, and not the module name. The main program could use
rules, variables, constants, tables, etc., exported by the module exactly the same
way as if they were declared there. Error strings can be added to the \pp|strings|
table exported by our module using \g{filling}\/s, which can spread across
the main program, such as
\begin{program}
'table'strings=("Right parent missing":no paren).
'table'strings=("Integer missing":no int,
                "Extra characters":no end).
\end{program}


\subsection{The anatomy of a rule}\label{1.7}

Although the rule \pp|put string| used in error messages is known to the
compiler, it is useful to see, as an additional example, how it looks when
expressed in \A. We first propose the preliminary version \pp|put string 1|.
\begin{program}
'action'put string 1+""file+table[]+>string-count:
   0->count,next1+file+table+string+count.
\smallskip
'action'next1+""out+tbl[]+>str+>cnt-symb:
   string elem+tbl+str+cnt+symb,put char+out+symb,
     inc+cnt,next1+out+tbl+str+cnt;
   +.
\end{program}
\noindent
The double set of quote marks (\pp|""|) indicates that the corresponding
actual affix will be a file. The square brackets indicate that the
corresponding actual affix will be a table. We see that the only thing
\pp|put string 1| does is to create an environment for \pp|next1| to run in.
The right arrow in \pp|0->count| indicates the assignment of the value on
the left to the variable on the right, one of the primitive actions in \A.
\pp|next1| starts by calling \pp|string elem|. This (standard) rule
considers the string in \pp|tbl| designated by \pp|str| and determines
whether this string has a \pp|cnt|-th symbol. If so, it puts it in
\pp|symb|; if not, it fails. If the call fails, we know we reached the end
of the string and we are done. Otherwise the symbol is transferred to the
file indicated by \pp|out|, the counter \pp|cnt| is increased by \pp|1|
(through the external rule \pp|incr|) and \pp|next1| is called again with
the same affixes. Like at the first call of \pp|next1|, the value of
\pp|cnt| is the position in the string of the symbol to be processed.

The recursive call of \pp|next1| is a case of trivial right-recursion;
moreover all actual affixes are the same as the formal affixes (which are
left of the colon). In this case the recursive call is equivalent to a
straightforward jump: it does not even necessitate parameter transfers. For
this case there is a shorthand notation: a name of a rule preceded by a
colon denotes the re-execution of that rule with the affixes it had upon its
initial call (of course this is only allowed inside the same rule and only
if the recursion is trivial right-recursion). Now we can write a simplified
version
\begin{program}
'action'put string 2+""file+table[]+>string-count:
   0->count, next2+file+table+string+count.
\smallskip
'action'next2+""out+tbl[]+>str+>cnt-symb:
   string elem+tbl+str+cnt+symb,
     put char+out+symb, incr+cnt, :next2;
   +.
\end{program}
\noindent
The gain is twofold. We no longer have to write that tail of affixes
which only convey the information ``same as before'', and, more
importantly, the rule \pp|next2| is now called only in one place (in \pp|put
string 2|). This means that we could as well explicitly have written it there.
We now replace the call of \pp|next2| in \pp|put string 2| by the definition
of \pp|next2|: we parenthesize the rule, substitute for each formal affix
its corresponding actual affix and remove the formal affixes:
\begin{program}
'action'put string+""file+table[]+>string-count:
   0->count,
    (next-symb:
      string elem+table+string+count+symb,
        put char+file+symb, incr+count, :next;
      +).
\end{program}
\noindent
Note that this mechanism of replacing a call of a rule by its (slightly
modified) definition is not applied here for the first time. We have been
using it tacitly from the very first sample rule in \Ref{Section 1.2}. There
the rule \pp|expression| is a contraction of
\begin{program}
'action'expression1+res>:
   term+res,expression tail 1+res.
\end{program}
\noindent
and
\begin{program}
'action'expression tail 1+>res>-r:
   is symbol+/+/, expression1+r, add+res+r+res; +.
\end{program}
\noindent
which, according to the above recipe, would yield:
\begin{program}
'action'expression 2+res>:
   term+res,
    (expression tail 2-r:
      is symbol+/+/, expression 2+r, add+res+r+res;
      +).
\end{program}
\noindent
In a sense this is a more appropriate form than the one given in \Ref{Section
1.2}: now the affix \pp|r| occurs where it belongs, that is, in the
position of a local affix of the parenthesized part only. To obtain the
version in \Ref{Section 1.2} exactly one must start from
\begin{program}
'action'expression 3+res>-r:
   term+res,expression tail 3+res+r.
\end{program}
\noindent
and
\begin{program}
'action'expression tail 3+>res>+r>:
   is+symbol+/+/,expression 3+r,add+res+r+res;+.
\end{program}

\subsection{Variable number of affixes}\label{1.9}

An \A{} rule can be designated to handle an unspecified number of affixes.
We present a version of the rule \pp|put string| which can send an
unspecified number of strings to an \A{} file. The new rule could be
called as
\begin{program}
put many strings+file+table1+str1,
put many strings+file+table1+str1+table2+str2+table3+str3,
\end{program}
\noindent
and so on, where \pp|file| is an \A{} file, while (\pp|table1|, \pp|str1|),
(\pp|table2|, \pp|str2|), etc., specify the strings to be printed. Our rule 
simply calls \pp|put string| with the given \pp|file| and each string in the
affixes in turn.
\begin{program}
'action'put many strings+""file+@+table[]+>string:
   put string+file+table+string,
       (shift affix block+@, put many strings+file+@; +).
\end{program}
\noindent
The \emph{anchor} \pp|+@| in the rule head does not correspond to any actual
affix, it only marks the position from which affixes can repeat an
unspecified number of times in a call to the rule. Affixes following that
anchor form the \emph{repeat affix block}. This block behaves like a window
which is aligned, in all the times, with one of the actual affix blocks in
the rule call. Formal affixes of the repeat block are matched against the
actual affixes appearing in that window. Operations on these formal affixes
are performed on the actual affixes seen in the window. As an example, the
rule call
\begin{program}
   put string+file+table+string,
\end{program}
\noindent
in the first line of the body of our rule sends that string to \pp|file|
whose specification (table and pointer) is actually visible in this
window.

When the execution of our rule starts, the window is aligned with the first
variable block of affixes in the rule call. Thus the very first call to
\pp|put string| will send the first string to \pp|file|. The call to the
built-in rule \pp|shift affix block|, as the name suggests, shifts the
window to the right by one block, failing if there are no more blocks.
Affixes in the shifted out block are lost for this rule as the window cannot
be moved backward. If there is no next affix block, then the dummy action
\pp|+| finishes our rule. Otherwise it calls itself recursively with the
same \pp|file| and the anchor \pp|+@| representing the current (in this case
the second, as the first block has already been shifted out) and the still
unvisited (if any) affix blocks. As in rule in the previous Section, this trivial
right recursion can be written equivalently as the jump \pp|:put many
strings|.

Using that an anchor, as the last actual affix, represents the current and
all subsequent univisited affix blocks, we could easily write a rule which
sends an unspecified number of strings to a particular \A{} file, say to
\pp|STDOUT|, as follows.
\begin{program}
'action'print strings+@+table[]+>string:
   put many string+STDOUT+@.
\end{program}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Syntactical description of Aleph}\label{sec:2}

The syntax of the \A{} language is given in the form of a context-free
grammar. This type of grammar follows the well-known scheme: a grammatical
notion on the left hand side of the syntax rule is defined by the
alternatives on the right hand side. Alternatives are separated by
semicolons; successive notions in an alternative are separated by commas.
Each grammatical notion is written as one or more words connected with dash
characters. To make the grammar more succinct, enclosing one or more notions
in square brackets indicates that the group may or may not be present, i.e.,
it is optional. Similarly, either a notion, or a group ot notions enclosed
in parentheses, can be followed by a star \g{\ast} or by a plus \g{\plus}.
The star indicates that the notion, or the group of notions, can be repeated
zero or more times; while the plus requires at least one, but otherwise
arbitrary number of instances. Thus both \g{[notion\plus]} and
\g{notion\ast} require zero, one, two, etc., occurrences of \g{notion}. To
illustrate these conventions, the following part of the \A{} grammar, which
describes the global structure of an \A{} \emph{unit}
\begin{grammar}
\item unit: information\ast, root, information\ast, end-symbol.
\item information: declaration; prototype; pragmat.
\end{grammar}
\noindent
can be verbalized as follows: 
\begin{itemize}
\item\sl
A \g{unit} is a sequence of
\g{declaration}\/s, \g{prototype}\/s and \g{pragmat}\/s, ending with an
\g{end-symbol}, which contains exactly one \g{root}, and only the \g{root}
and the closing \g{end-symbol} are required.
\end{itemize}

\smallskip

A syntactically correct \A{} unit is the character representation of a
sequence of terminal notions produced by this grammar; \g{unit}\/s are
composed from one or more \emph{source files}. These terminal notions fall
into the following categories:

\begin{itemize}
\item[a)] \emph{symbols}, notions ending with \g{-symbol},
\item[b)] \emph{tags} (identifiers), notions ending with \g{-tag}, and
\item[c)] character, integer, and string \emph{denotations}, ending
with \g{-denotation}.
\end{itemize}
Representations of terminals and the description of formatting rules,
including where can comments be inserted and how the program text is
composed from the source files, are covered in \Ref{Chapter sec:7}.

There are two kinds of \A{} \g{unit}\/s. A \g{unit} is either a
\emph{module} or it is a \emph{main program}; module units include library
modules. The \A{} compiler \emph{compiles} a single \g{unit} and produces an
intermediate \texttt{ALICE} code. Complete \A{} programs are \emph{linked}
from the \texttt{ALICE} codes of a main program and several modules.



%\subsection{The Aleph unit}\label{3.1}
\smallskip

Syntax:
\begin{grammar}
\item unit: information\ast, root, information\ast, end-symbol.
\item information: declaration; prototype; pragmat.
\item root: root-symbol, actual-rule, point-symbol.
\item declaration: rule-declaration; data-declaration; external-declaration.
\item prototype: rule-prototye; data-prototype.
\end{grammar}
This grammar says that a \g{unit} must contain exactly one
\g{root}, and must end with an \g{end-symbol}. The order in which
\g{declaration}\/s, \g{prototype}\/s and the \g{root} appear is
immaterial. The position of \g{pragmat}\/s, however, can be
significant, see \Ref{Chapter sec:6}. Example of a \g{unit}:
\begin{program}
'charfile'output=>"result.txt".
'root'put char+output+/3/.
'end'
\end{program}
\noindent
The first line is a \g{data-declaration}, the second line is the \g{root},
and the third line contains the \g{end-symbol}. For complete examples see
\Ref{Chapter sec:8}.

The \g{unit} is a \emph{module} if it contains a \pp|module=.\!.\!.| \g{pragmat};
this pragmat defines both the module name and its name-space. The \g{unit}
is a \emph{main program} if it contains no such a pragmat; the above example
is a main program.

A complete \A{} program is \emph{linked} from a main program and from zero
or more modules. Execution of the linked program starts with processing all
\g{data-declaration}\/s in the main program and in the modules, in such an order
that no data item is used before its value has been established. If no such
an order exists the linker would have given an error message. After all constants,
variables, stacks, tables and files have thus been established, the
\g{actual-rule}\/s in the \g{root}\/s of the linked modules are executed
(\Ref{Section 3.2.2}) in some undefined order, allowing the modules to
perform some initialization. If any module \g{root} stops prematurely for
whatever reason, the program run is terminated. The order in which module
roots are executed is undefined, but can be synchronized using the Standard
Library rule \pp|wait\char32for|, see \Ref{Section 6.4.4}.

After all module roots finish with normal completion, the \g{actual-rule}
of the main program is executed. If it reaches its normal completion, the
program finishes with a termination state of \pp|0|. If program termination
is due to calling the Standard Library rule \pp|exit|, then the termination
state is specified by the value of the affix to this rule. In other cases
the termination state is not defined.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Program logic}\label{sec:3}

Rule definitions and applications constitute the basic mechanism which
determines the logical flow in an \A{} program. This section describes \A{}
primitives and the way how these primitives can be combined to form an
\g{actual-rule}.

\subsection{Rules} \label{3.2}

A \g{rule-declaration} defines what is to be done when the rule is called,
whereas applying the rule in an \g{affix-form} specifies that the rule is to
be called. A rule, when called and returns, will either succeed or fail;
while there are rules which never return.

\subsubsection{Rule declaration}\label{3.2.1}

Each rule in a \g{unit} must be defined either in a \g{rule-declaration} or
in a defining \g{rule-prototype}. Syntax:

\begin{grammar}
\item rule-declaration:

    typer, rule-head, actual-rule, point-symbol.
\item typer:

      action-symbol; function-symbol; predicate-symbol;

      question-symbol; exit-symbol.
\item rule-head: rule-tag, formal-affix-sequence.
\item rule-prototype:

     typer, rule-head, (comma-symbol, rule-head)\ast, point-symbol.
\end{grammar}
Example of a \g{rule declaration}:
\begin{program}
'action'put string+""file+table[]+>string-count:
   0->count,
   (next-symb:
      string elem+table+string+count+symb,
      put char+file+symb, incr+count, :next;
      +).
\end{program}
\noindent
Here the \g{typer} is \pp|'action'|, the \g{rule-tag} is \pp|put string|,
the \g{formal-affix-sequence} is \pp|+""file+table[]+>string| and the
\g{actual-rule} is the rest, excluding the point but including 
\pp|-count:|. Example of a \g{rule-prototype}:
\begin{program}
'function'square+>x+xx>,list size+T[]+n>.
\end{program}

Both the \g{rule-declaration} and the \g{rule-prototype} define the
\g{rule-tag} to be a rule of type designated by \g{typer}, to be identified
by the \g{rule-tag}, and to have the formal affixes given by its
\g{formal-affix-sequence}. A \g{rule-declaration}, in addition, specifies in
the \g{actual-rule} how to execute the rule when it is called.

There are five rule types: \emph{predicate}, \emph{question}, \emph{action},
\emph{function}, and \emph{exit}, each designated by the corresponding
\g{typer} symbol. These types arise from three criteria, each expressing a
fundamental property of the logical structure of the \g{actual-rule}. A rule
\begin{itemize}
\item[a)] either always succeeds or is capable of failing;
\item[b)] when it succeeds, it may or may not have side effects;
\item[c)] can never return.
\end{itemize}
Accordingly, a rule is of type
\begin{list}{}{\setlength\topsep{2pt}%
\setlength\partopsep{3pt}%
\setlength\parsep{0pt plus 2pt}%
\setlength\labelsep{0pt}%
\setlength\labelwidth{\parindent}%
\setlength\leftmargin{\parindent}}
\item[\emph{predicate}, ]
when it can fail \emph{and} has side effects (restrictions on the rule
structure typically prevent these side effects from becoming effective
when the rule fails);
\item[\emph{question}, ]
when it can fail \emph{and} has no side effect;
\item[\emph{action}, ]
when it always succeeds \emph{and} has side effects;
\item[\emph{function}, ]
when it always succeeds \emph{and} has no side effects;
\item[\emph{exit}, ]
when it never returns, consequently has side effects.
\end{list}
The rule type is checked against the logical construction of the
\g{actual-rule}. If an action or function is found to be able to fail, an
exit rule to be able to return, or a non-exit rule not able to return, an
error message is given. In other cases, if a discrepancy is found, a warning
is given.

%\subsubsection*{Examples}

With each of the following \g{rule-prototype} examples a summary of what the
rule does is provided. From this explanation it should be clear why the
rule was specified with the given type.

\smallskip\noindent
\begin{tabular}{lp{0.58\textwidth}}
\pp|'predicate'digit+d>.|
&
if the next symbol in the input file is a digit, its value is delivered in \pp|d|,
the input file is advanced by one symbol (side effect) and \pp|digit|
succeeds; otherwise it fails.
\\[3pt]
\pp|'question'is hexdigit+>d.|
&
if \pp|d| is a hexadecimal digit character, the rule succeeds, otherwise it fails.
\\[3pt]
\pp|'action'skip up to point.|
&
the input file is advanced until the next symbol is a point.
\\[3pt]
\pp|'function'add+>x+>y+sum>.|
&
the sum of \pp|x| and \pp|y| is delivered in \pp|sum|.
\\[3pt]
\pp|'exit'error+>n.|
&
give an error message and terminate.
\end{tabular}


\subsubsection{Actual rule}\label{3.2.2}

The \g{actual-rule} defines the local variables used exclusively by the
\g{rule-body}, and specifies one or more alternatives which determine the
control flow in the rule. Syntax:
\begin{grammar}
\item actual-rule: local-affix-sequence, colon-symbol, rule-body.
\item rule-body: alternative, (semicolon-symbol, alternative)\ast; 
      classification.
\item alternative:
     (member, comma-symbol)\ast, last-member.
\end{grammar}
Example of an \g{actual rule}:
\begin{program}
  -d:
    digit+d,mult+res+10+res, add+res+d+res,integer1+res;
    +.
\end{program}
\noindent
Here \pp|-d| is a \g{local-affix}, one \g{alternative} is
\begin{program}
    digit+d,mult+res+10+res, add+res+d+res, integer1+res
\end{program}
\noindent
and \pp|+| is another; \pp|add+res+d+res| is a \g{member}, and \pp|+| is a
\g{last-member}.

When an \g{actual-rule} is executed (through a call of the
\g{rule} of which it is the \g{actual-rule}, see \Ref{Section 3.5}), the
following takes place.
\begin{itemize}
\item[a)] First, space is allocated for every local affix.
\item[b)] Second, the \g{rule-body} is executed, which means
executing its alternatives or its classification.
\item[c)]
After the result of the \g{actual-rule} thus has been assessed, the
space reserved for the local affixes is returned.
\end{itemize}
Execution of \g{alternative}\/s is discussed here, for that of 
\g{classification}\/s see \Ref{Section 3.8}.

The execution of the \g{alternative}\/s starts with a search to determine which
of them applies in the present case. The applicable \g{alternative} is the
(textually) first one whose \emph{guard} succeeds. The guard
of an \g{alternative} is its first \g{member}, or if it has no \g{member},
its \g{terminator}. Thus the guard of the first \g{alternative} is executed:
if it succeeds, the first \g{alternative} applies. Otherwise the guard of
the second \g{alternative} is executed: if it succeeds, the second
\g{alternative} applies, etc. If none of the guards succeeds, the
\g{rule-body} fails.

The \g{alternative} found applicable is then elaborated further. Its guard
has already been executed. Now the rest of its \g{member}\/s and its
\g{last-member} are executed in textual order until one of following 
two situations is reached:
\begin{list}{}{\setlength\topsep{2pt}%
\setlength\partopsep{3pt}%
\setlength\parsep{0pt plus 2pt}%
\setlength\labelsep{0pt}%
\setlength\labelwidth{\parindent}%
\setlength\leftmargin{\parindent}}
\item[\emph{either} ] all its \g{member}\/s and its \g{last-member} have succeeded, 
in which case the \g{alternative} succeeds as well,
\item[\emph{or} ] a \g{member} or \g{last-member} fails: any (textually) following
\g{member}\/s 
or \g{last-member} in this
\g{alternative} will not be executed and the \g{alternative} fails.
\end{list}
If the chosen \g{alternative} succeeded, the \g{actual-rule} succeeds; if it
failed, the \g{actual-rule} fails. This completes the execution of the
\g{actual-rule}.

%Restrictions.
%
The sequence of \g{alternative}\/s must satisfy the following restrictions.
\begin{itemize}
\item[a)]
If the guard of an \g{alternative} cannot fail, the \g{alternative} must be
the last one.
\end{itemize}
This restriction ensures that all \g{alternative}\/s can, in principle, be
reached. Violating this restriction causes an error message.
\begin{itemize}
\item[b)]
If an \g{alternative} contains a \g{member} that cannot return, then this
\g{member} must be the last one.
\end{itemize}
This restriction ensures that in an \g{alternative} all \g{member}\/s can,
in principle, be reached. Violating this restriction causes an error
message.
\begin{itemize}
\item[c)]
If an \g{alternative} contains a \g{member} that has side-effects,
then this \g{member} may not, in the same \g{alternative},
be followed by a \g{member} that can fail.
\end{itemize}
The third restriction ensures that side-effects of a \g{member} cannot
materialize if the \g{member} fails; this in turn ensures that the tests
necessary to determine the applicable \g{alternative} do not interfere with
each other. Violating this restriction causes a warning. The programmer is
urged to either reconsider the formulation of the problem, or make sure that
the side effects will not have ill consequences.

\subsubsection{Member}\label{3.2.3}

\g{Member}\/s are units of action. Such an action is either a primitive 
operation, a rule call, or it is composed from other actions.
Syntax:
\begin{grammar}
\item member: affix-form; operation; compound-member.
\item last-member: member; terminator.
\end{grammar}
Example of a \g{member}:
\begin{program}
(declaration sequence option-type-idf:
   declaration+type+idf,enter+type+idf,
     :declaration sequence option;+)
\end{program}
\noindent
This \g{member} is a \g{compound-member}, the part
\begin{program}
   declaration+type+idf
\end{program}
\noindent
is an \g{affix-form}, \pp|:declaration sequence option| is a
\g{last-member}, as is \pp|+|.

The notion \g{last-member} has been introduced into the syntax to ensure that a
\g{terminator} (\Ref{Section 3.6}) will occur last in an \g{alternative}.

\subsection{Affixes}\label{3.3}

Formal and actual affixes constitute the communication between the caller of
a rule and the rule called. Local affixes are a means for creating
variables that are local to a given \g{rule-body}.

\subsubsection{Formal affix}\label{3.3.1}

Formal affixes define the number and the types of the affixes of a rule.
Syntax:

\begin{grammar}
\item formal-affix-sequence:
      formal-affix\ast, [anchor, formal-affix\plus{}].
\item formal-affix: plus-symbol, formal.
\item formal: formal-variable; 
      formal-stack; formal-table; formal-file.
\item anchor: plus-symbol, anchor-symbol.

\medskip
\item formal-variable: in-variable; out-variable; inout-variable.
\item in-variable: right-symbol, variable-tag.
\item out-variable: variable-tag, right-symbol.
\item inout-variable: right-symbol, variable-tag, right-symbol.
\item formal-table: [field-definition], table-tag, sub-bus.
\item formal-stack: sub-bus, [field-definition], stack-tag, sub-bus.
\item sub-bus: sub-symbol, bus-symbol.
\item formal-file: quote-image-symbol, file-tag.
\end{grammar}
Example of a \g{formal-affix} sequence:
\begin{program}
 +""file+table[]+>string
\end{program}
\noindent
Here \pp|file| is the tag of a \g{formal-file}, \pp|table| is the tag of a
\g{formal-table}, finally \pp|string| is the tag of an \g{in-variable}.

A \g{formal-variable} defines a \emph{variable}. An \g{in-variable} or an
\g{inout-variable} obtains an initial value from the calling rule; it is
\emph{initialized}. An \g{out-variable} has the attribute
\emph{uninitialized} at the beginning of each alternative in the
\g{actual-rule}. The value of an \g{out-variable} or an \g{inout-variable}
will be passed back to calling rule, so it must have attribute
\emph{initialized} attribute at the end of each \g{alternative} of the
\g{actual-rule} where the control can return, namely which does not end in a
\g{jump}, a \g{failure-symbol}, or an exit rule. Changes to an
\g{in-variable} do not materialize outside the \g{actual-rule}. An
\g{in-variable} behaves as if it were an initialized \g{local-variable}.

A \g{formal-stack} or a \g{formal-table} defines a stack or a table,
respectively. If the \g{field-definition} (\Ref{Section selectors}) is
absent, the formal list is supposed to have one \g{selector}: the tag of
this \g{selector} is the same as the tag of the formal list itself. For
example, \pp|[]list[]| has the same meaning as \pp|[](list)list[]|.
% If the
%formal affix has more than one \g{field-list pack}\/s, all must specify the
%same block length. The selectors they define, however, are accumulated.

A \g{formal-file} defines a file, which can be both character and data
file.

The \g{anchor}, if present, marks the affix position from where the
remaining affixes form the \emph{repeat affix block}. The \g{anchor} is not
matched against any \g{actual-affix}. In the example
\begin{program}
 +""file+@+table[]+>ptr
\end{program}
\noindent
the repeat affix block has length two and is formed by the affixes
\pp|table| and \pp|ptr|.

All affix tags %\g{variable-}, \g{stack-}, \g{table-} and \g{file-tag}s 
in the \g{formal-affix-sequence} must be different. The cannot have
qualifiers, and also must
be different from the \g{rule-tag} that precedes this sequence.

\subsubsection{Actual affix}\label{3.3.2}

\g{Actual-affix}\/es occur in rule calls specified in \g{affix-form}\/s, see
\Ref{Section 3.5}. Each \g{actual-affix} corresponds to some
\g{formal-affix} of the called rule. Syntax:
\begin{grammar}
\item actual-affix-sequence: actual-affix\ast, [anchor].
\item actual-affix: plus-symbol, actual.
\item actual: source; list-tag; file-tag; string-denotation.
\end{grammar}
Example of an \g{actual-affix-sequence}:
\begin{program}
+-511+/?/+alpha+beta*gamma[p]+<>list+\#
\end{program}
\noindent
In this example \pp|-511| is an \g{integral-denotation}, \pp|/?/| is a
\g{character-denotation}, \pp|alpha| may be a \g{file-tag}, \pp|beta*gamma[p]|
may be a \g{stack-element}, \pp|<>list| is a \g{calibre}, and \pp|\#| is a
\g{dummy-symbol}.

\g{Actual-affix}\/es derive their exact meaning from the corresponding
\g{formal-affix}\/es. The interrelation is discussed in \Ref{Section 3.5}.

\subsubsection{Local affix}\label{3.3.3}
Local affixes are variables local for the \g{actual-rule} or the
\g{compound-member} in which they are defined. Syntax:
\begin{grammar}
\item local-affix-sequence: local-affix\ast.
\item local-affix: minus-symbol, local-tag.
\end{grammar}
Example of a \g{local-affix-sequence}:
\begin{program}
  -count
\end{program}
\noindent
None of the tags in the \g{local-affix-sequence} can have a qualifier, and
all these tags must be different. A \g{local-tag}
has the attribute \emph{uninitialized} at the beginning of each
\g{alternative} of the \g{actual-rule} or \g{compound-member}. Its attribute
must be \emph{initialized} at the end of at least one \g{alternative},
meaning that the variable has been used.

\subsection{Operations}\label{3.4}

Operations are the primitive actions in the \A{} language. They are the
assignments (\g{transport}), comparing two integer values (\g{comparison}),
and adding new elements to a stack (\g{extension}). Syntax:
\begin{grammar}
\item operation: transport; comparison; extension.
\smallskip
%\item transport: source, (arrow-symbol, destination)\plus.
\item source: constant-source; destination.
\item constant-source: constant-value; table-element.
\item destination:

    variable-tag; stack-element; dummy-symbol.
\item constant-value:
   
   integral-denotation; character-denotation; constant-tag; limit.
%\item integral-denotation:
%
%   [minus-symbol], digit\plus; 
%
%   [minus-symbol], hex-symbol, hex-digit\plus;
%
%   manifest-constant.
%\item character-denotation: absolute-symbol, visible-character, absolute-symbol.
\item table-element:

 [selector, of-symbol], table-tag, [sub-symbol, source, bus-symbol].
\item stack-element:

 [selector, of-symbol], stack-tag, [sub-symbol, source, bus-symbol].
%\smallskip
%\item comparison: source, relation, source.
%\item relation:
%
%   lt-symbol; le-symbol; eq-symbol; ne-symbol; ge-symbol; gt-symbol.
%\smallskip
%\item extension: 
%   left-of-symbol, field-transport-list, right-of-symbol, stack-tag.
%\item field-transport-list:
% field-transport, (comma-symbol, field-transport)\ast.
%\item field-transport: source, (arrow-symbol, selector-tag)\plus.
\end{grammar}

\medskip
\noindent
Example of a \g{transport} (assignment):
\begin{program}
pnt->sel*list[q]->offset->ors*list[offset]->\#
\end{program}
\noindent
Example of a \g{comparison}:
\begin{program}
ext*list[pnt] != -0x3b7
\end{program}
\noindent
Example of an \g{extension}:
\begin{program}
(* pnt->sel, nil->ect->ors *)list
\end{program}

\subsubsection{Transport}\label{3.4.1}
A \g{transport} (assignment) is a \g{function} since it has no
(inherent) side effects and always succeeds. Syntax:
\begin{grammar}
\item transport: source, (arrow-symbol, destination)\plus.
\end{grammar}
The execution of a \g{transport} starts with the evaluation of its \g{source}.
A \g{source} is evaluated as follows.
\begin{itemize}
\item[a)]
If the \g{source} is an \g{integral-denotation}, its value is the numerical
value of \g{digit} sequence considered as a number in decimal notation,
negated if preceded by a \g{minus-symbol}; or the hexadecimal value of the
\g{hex-digit} sequence following the \g{hex-symbol}, also negated when preceded by
a \g{minus-symbol}; or the numerical value of the \g{manifest-integral} as
determined by the compiler.

\item[b)]
If the \g{source} is a \g{character-denotation}, the value is the
(numerical) code of the \g{visible-character} between the
\g{absolute-symbols} \pp|/|.

\item[c)]
If the \g{source} is a \g{constant-tag} or a \g{variable-tag}, its value is
the value of the constant or variable identified. If a formal or local
variable is identified, it must have the \emph{initialized} attribute.

\item[d)]
If the \g{source} is a \g{table-element} or a \g{stack-element}, its value
is determined as follows (see also \Ref{Section 4.1.5} and \Ref{Section
4.1.6}). Let $T$ be the \g{table-tag} or \g{stack-tag} in the
\g{source}, and denote by $L$ the (global or formal) list identified by $T$.
First, a selector $S$ is determined. If the \g{of-symbol} is present, $S$ is
the \g{selector} in front of it. If it is absent, then $S$ is the same as
$T$, this is the \emph{standard selector} of the list. If $S$ is not a
selector of the list $L$, then it is an error.

Next, an index $P$ is determined. If the \g{source} between the
\g{sub-symbol} and \g{bus-symbol} is present, it is evaluated, and the value
is $P$. Otherwise $P$ is set to the actual upper bound of $L$. As an
example, \pp|list| is equivalent to \pp|list*list[>>list]|.

Now consider the block $B$ in $L$ that has an address equal to $P$. If no such a
block exists, then it is an error. The value of the \g{list-element} is the
value identified by the selector $S$ in the block $B$.

\item[e)]
If the \g{source} is a \g{limit}, its value is described in \Ref{Section 4.1.7}.

\item[f)] If the \g{source} is a \g{dummy-symbol}, there is an error.
\end{itemize}

\medskip

The value of the \g{source} is called $V$. Now the assignments of the
\g{transport} are executed in textual order. A single assignment is executed 
as follows.

\begin{itemize}
\item[a)]
If the \g{destination} is a \g{variable-tag}, the value $V$ 
is put in the location identified by the variable. If the variable is formal
or local, then it  has the \emph{initialized} attribute 
in the rest of the \g{alternative} in which this \g{transport} appears.

\item[b)]
If the \g{destination} is a \g{stack-element}, a selector $S$ and a block
$B$ in the list $L$ identified by the \g{stack-tag} is determined as above.
The value $V$ is put into the location of the block $B$ identified by the
selector $S$.

\item[c)]
If the \g{destination} is a \g{dummy-symbol}, the assignment is a
dummy action.
\end{itemize}

Examples:

\smallskip\noindent
\begin{tabular}{lp{0.63\textwidth}}
\pp|0->cnt->res|
& now \pp|cnt| and \pp|res| are both zero
\\[2pt]
\pp|list->list[q]->q|
& the value at \pp|list*list[>>list]| is put in the location 
    identified by \pp|list*list[q]| (so \pp|list| must be a stack), and in (the location of) \pp|q|
\\[2pt]
\pp|p->q->list[q]|
& the value of \pp|p| is put in (the location of) \pp|q| and then in the 
 location identified by \pp|list*list[q]| which is now the same as \pp|list*list[p]|
\\[2pt]
\pp|list[p]->p->list[p]|
&  the value of \pp|list*list[p]| is put in \pp|p| and then put 
  in \pp|list*list[p]| using the new value of \pp|p|, with the result
  that now \pp|list*list[p]| contains a  pointer to itself
\end{tabular}

\subsubsection{Comparison}\label{3.4.2}

A \g{comparison} is a question, i.e., it has no side effects and may either
succeed or fail. Syntax:
\begin{grammar}
\item comparison: source, relation, source.
\item relation:

   lt-symbol; le-symbol; eq-symbol; ne-symbol; ge-symbol; gt-symbol.
\end{grammar}
Both \g{source}\/s are evaluated as described above.
The two resulting values are considered to be signed integers and compared using 
the specified \g{relation}:

\smallskip
\begin{tabular}{lll}
symbol        & example & succeeds if \\[2pt]
\g{lt-symbol} & \pp|x < y| & \pp|x| is less than \pp|y|
\\[2pt]
\g{le-symbol} & \pp|x <= y| & \pp|x| is less than or equal to \pp|y|
\\[2pt]
\g{eq-symbol} & \pp|x = y| & \pp|x| is equal to \pp|y|
\\[2pt]
\g{ne-symbol} & \pp|x != y| & \pp|x| and \pp|y| differ
\\[2pt]
\g{ge-symbol} & \pp|x >= y| & \pp|x| is greater than or equal to \pp|y|
\\[2pt]
\g{gt-symbol} & \pp|x > y| & \pp|x| is greater than \pp|y|
\end{tabular}

\medskip\noindent
The return value of a \g{comparison} is ``success'' if the relation holds
between the two values, and ``fail'' otherwise. Note that even if both
\g{source} values represent pointers to lists, the numerical
values of these pointers are compared, and not the values they point to.

\subsubsection{Extension}\label{3.4.3}

An \g{extension} is an action, i.e., it has side effects and always succeeds.
Syntax:
\begin{grammar}
\item extension: 
   left-of-symbol, field-transport-list, right-of-symbol, stack-tag.
\item field-transport-list:
 field-transport, (comma-symbol, field-transport)\ast.
\item field-transport: source, (arrow-symbol, selector-tag)\plus.
\end{grammar}
Call the stack indicated by the \g{stack-tag} $S$. All \g{selector-tag}\/s 
appearing in the \g{field-transport-list} must be selectors of $S$.

First, the \g{source}\/s in the \g{field transport}\/s are evaluated as
described in \Ref{Section 3.4.1} and their values are remembered. Subsequently a
block $B$ is created with as many empty locations as the calibre of $S$.
Next, all \g{field transport}\/s are executed; a \g{field-transport} is
executed by putting the value remembered for its \g{source} in the
location(s) in $B$ identified by the \g{selector-tag}\/s.

No more than one value may be put in a given location in $B$, and at the end
of the \g{extension} locations filled in $B$ must form an end-section of $B$
without holes. Violating this condition results in an error message.
Finally, the stack $S$ is extended by a (possibly incomplete) block
containing the filled locations. In the case when the block is incomplete,
a warning is issued.

\smallskip

Example: given a stack \pp|st| declared as \pp|[](sel,ect,or)st[]|, the
first of the three \g{extension}\/s
\begin{program}
   (* 3->ect, 5->sel->or *)st,
   (* 0->or *)st,
   (* 5->sel->ect *)st
\end{program}
\noindent
adds the block \pp|(5,3,5)| to \pp|st| and increases the actual upper bound
\pp|>>st| by 3. The second \g{extension} adds a single zero element to the
top of \pp|st| and increases \pp|>>st| by 1. The last
\g{extension} is incorrect as the mentioned \g{selector}\/s do not form an
end-segment of the block.

\subsection{Affix form}\label{3.5}
Calling (executing) a rule is done through an \g{affix-form}. It specifies
both the rule to be called and the actual affixes (parameters) the rule is
called with. Syntax:
\begin{grammar}
\item affix-form: rule-tag, [actual-affix-sequence].
\end{grammar}
Example:
\begin{program}
string elem+tbl+str+cnt+symb
\end{program}

Let $R$ be the rule identified by the \g{rule-tag} in the \g{affix-form}.
Executing the \g{affix-form} means calling $R$ so that its
\g{formal-affix}\/es are specified by the \g{actual-affix}\/es of the
\g{affix-form}. To establish the correspondence between the formal and
actual affixes the \g{actual-affix-sequence} is modified as follows. Each
\g{string-denotation} in the \g{actual-affix-sequence} is replaced by two
affixes: a \g{table-tag} identifying an internal table, and a
\g{constant-tag} pointing to an instance of the specified string in that
table. Furthermore the trailing \g{anchor} in the \g{actual-affix-sequence},
if present, is deleted.

After this preparation the correspondence between actual and formal affixes
is established in their textual order: the first actual corresponds to the first
formal, the second actual to the second formal, and so on. In this process
the formal \g{anchor} affix, if present, is skipped, and not matched against
any actual affix. If the formal affixes are exhausted while the actual
affixes are not, the formal affixes are reset to the affix immediately
following the formal \g{anchor}. If there is no formal \g{anchor}, then this
is an error. The matching process ends when there are no more actual affixes in
the prepared list. At this point \emph{either} the formal affixes must be exhausted
as well, \emph{or} both the last affix in the \g{actual-affix-sequence}, and the
next unprocessed \g{formal-affix} of the called rule must be an \g{anchor}.

For an illustration of the process, assume that the
\g{formal-affix-sequence} of the called rule is
\begin{program}
  +A[]+>B>+@+""C+D>+[]E[]
\end{program}
\noindent
which has a \emph{repeat affix block} of length 3, see \Ref{Section 3.3.1}.
The affixes in the following \g{actual-affix-sequence}\/s are correctly 
matched up with the formal affixes labelled by the corresponding upper case letters:
\begin{program}
  +a+b+@,
  +a+b+c+d+e,
  +a+b+c1+d1+e1+c2+d2+e2+c3+d3+e3+@.
\end{program}
\noindent
In the first case the matching parts of both the \g{actual-affix-sequence}
and the \g{formal-affix-sequence} end with an \g{anchor}; in the other two
cases both sequences are exhausted simultaneously. In the last case the
\g{formal-affix-sequence} is reset twice. The following affix sequences
do not match correctly with the above \g{formal-affix-sequence}
\begin{program}
  +a+b, +a+b+c+d, +a+b+c+d+@, +a+b+c1+d1+e1+c2.
\end{program}

If the \g{actual-affix-sequence} ends with an \g{anchor}, then the
\g{actual-rule}, of which this \g{affix-form} is a member, must also have an
\g{anchor} in its \g{formal-affix-sequence} (\Ref{Section 3.3.1}), and also
there must be an \g{anchor}
in the \g{formal-affix-sequence} of the rule $R$. These two
\emph{repeat affix blocks} must have the same number of elements, and are
also matched against each other in their textual order.

\smallskip

The matched actual and formal affixes must satisfy the following conditions.
\begin{itemize}
\item[a)]
The actual corresponding to a \g{formal-table} must be a \g{list-tag}
identifying a (global or formal) stack or a (global or formal) table. All
actions performed on the formal during the execution of the rule $R$ are
executed directly on the actual. If the formal has \g{field-definition},
then the block size (calibre) and the standard selector of the formal and
that of the actual must be equal, while the selectors other than the
standard selector, may differ. If the formal has no \g{field-definition},
then no calibre match is required. Regardless of mismatches, the value
delivered by the \g{calibre} (\pp|<>list|) is the calibre of the global list
to which the \g{formal table} corresponds, directly or indirectly.

\item[b)]
The actual corresponding to a \g{formal-stack} must be a \g{stack-tag}
identifying a (global or formal) stack. All actions performed on the formal
during the execution of $R$ are executed directly on the actual. Restriction
on calibre and selectors is the same as for \g{formal-table}\/s.

\item[c)]
The actual corresponding to a \g{formal-file} must be a \g{file-tag}
identifying a (global or formal) file. All actions performed on the
formal are executed directly on the actual.

\item[d)]
The actual corresponding to a formal \g{in-variable} must be a
\g{source}; the actual corresponding to a formal \g{inout-variable}
or a formal \g{out-variable} must be a \g{destination}. The
\g{dummy-symbol}, however, is not allowed for formal \g{inout-variable}\/s.
The \g{destination} for an \g{inout-variable} must have the
\emph{initialized} attribute.

\item[e)]
If the matching actual and formal affixes are both from the corresponding
\emph{repeat affix blocks}, then the actual corresponding to a formal
\g{inout-variable} must also be a (formal) \g{inout-variable}, and the
actual corresponding to an \g{out-variable} must be either an \g{out-variable}
or an \g{inout-variable}.
\end{itemize}

\smallskip
After establishing the correspondence between the actual and formal affixes,
the following steps are executed.


\begin{steps}{Step 1.}
Prepare the list of affixes to be passed to the called rule as follows.
\begin{itemize}
\item[a)]
If the last affix in the \g{actual-affix-sequence} is not an \g{anchor},
then this list consists of the (actual) affixes in their original order as
prepared above.
\item[b)]
If the \g{actual-affix-sequence} ends with an \g{anchor}, then first take
all affixes as prepared above. By the conditions the 
\g{actual-rule} of which this \g{affix-form} is a member, has
a \emph{repeat affix block}. The actual (visible) affixes in that block, 
plus all affixes in subsequent (pending) blocks are copied to the end of
the list.
\end{itemize}
\end{steps}

\begin{steps}{Step 2.}

The copying part of the affix mechanism is put into operation. For each
\g{actual-affix} in the list prepared in Step 1, if the corresponding
\g{formal-affix} is either an \g{in-variable}, or an \g{inout-variable}, a
\g{transport} (see \Ref{Section 3.4.1}) is executed with the actual as the
\g{source}, and the formal as its only \g{destination}.

\end{steps}

\begin{steps}{Step 3.}
Prepare repeat affix blocks. If the \g{actual-rule} rule $R$ (as
identified by the \g{rule-tag} in the \g{affix-form}) has a \emph{repeat
affix block} of length $S$, then \g{actual-affix}\/es corresponding to the
formal affixes in that affix block are grouped into blocks of length $S$
starting from the leftmost \g{actual-affix}. 
Elements of the first block are matched against the formals in the formal
\emph{repeat affix block}, while the remaining blocks, if any, are the
``pending'' or ``unseen'' blocks. If $R$ has no repeat affix block, this
step is skipped.

\end{steps}

\begin{steps}{Step 4.}
Subsequently the rule $R$ is executed.
If the \g{actual-rule} $R$ succeeds, the \g{affix-form} succeeds, if it
fails, the \g{affix-form} fails.

If the \g{affix-form} succeeds, the restoring part of the affix mechanism
is executed: for each \g{formal-affix} that is either \g{out-variable}
or \g{inout-variable} a \g{transport} is executed with the formal as its
\g{source} and the actual as its \g{destination}, in the order in which
these affixes appear. This copying is also executed for affixes in the
repeat affix block.
\end{steps}

\medskip\noindent
Example 1: Suppose the following rule and variable declarations:
\begin{program}
'function'sq+>a+>b>+c>: b->c, a->b.
'variable'x=0,y=1.
\end{program}
\noindent
The \g{actual-rule} \pp|sq+x+y+x| swaps the values of \pp|x| and \pp|y|.
Indeed, the copying part described in Step 2 executes the \g{transport}\/s
\pp|x->a|, \pp|y->b| \emph{before} calling \pp|sq|, and the \g{transport}\/s
\pp|b->y|, \pp|c->x| \emph{after} \pp|sq| successfully returns.

\medskip\noindent
Example 2: With the following declarations:
\begin{program}
'action'P+""file+@+T[]+>ptr: $ do something ...$.
'action'PP+@+T[]+>ptr: P+STDOUT+"first"+@.
\noindent
\end{program}
\noindent
the \g{actual-rule} \pp|PP+"str1"+"str2"| will call \pp|PP| with four
affixes; the first and the third are the internal table containing inline
strings, the second and fourth affixes are pointers pointing to
the (packed forms) of the strings \pp|"str1"| and \pp|"str2"|. The rule
\pp|PP|, in turn, calls \pp|P| with a total of seven affixes of which the
last four comes from the repeat affix blocks of \pp|PP| (two in the visible
block and two pending). The overall effect is the same as that of the
\g{actual-rule}
\begin{program}
  P+STDOUT+"first"+"str1"+"str2".
\end{program}



\subsection{Terminators}\label{3.6}
Syntax:
\begin{grammar}
\item terminator: jump; success-symbol; failure-symbol.
\item jump: repeat-symbol, rule-tag.
\end{grammar}
%Examples of \g{terminator}\/s:
%\begin{program}
%  :order
%  +
%  -
%\end{program}

\subsubsection{Jumps}\label{3.6.1}
The \g{rule-tag} after the \g{repeat-symbol} may be the \g{rule-tag} of the
rule in which the \g{jump} occurs or the \g{rule-tag} of (one of) the
\g{compound member}(s) in  which the \g{jump} occurs.

A \g{jump} to the \g{rule-tag} of a rule is an abbreviated notation
of a call to that rule, with actual affixes that correspond to the original
actual affixes. The abbreviation is only allowed if, after the execution of
the call, no more members in the rule can be executed. This condition
ensures that there will be no need for the recursive call mechanism to
be invoked.

\smallskip\noindent
Example: the rule
\begin{program}
'action'bad1: a,(b; :bad1), c; +.
\end{program}
\noindent
is incorrect. After returning from \pp|:bad1|, the \g{affix-form} \pp|c|
should be executed. If \pp|,c| is removed, the rule becomes correct. 
Likewise, the rule
\begin{program}
'question'bad2:(a,b,:bad2); c.
\end{program}
\noindent
is incorrect: after an unsuccessful return from \pp|:bad2|, the
\g{affix-form} \pp|c| should be executed. If the parentheses 
are removed, the rule becomes correct.

A \g{jump} to the \g{rule-tag} of a \g{compound-member} $C$ causes this
\g{compound-member} to be re-executed. The precise meaning can be assessed
by decomposing (see \Ref{Section 3.7}) the actual rule until $C$ turns into a
rule. Then the above applies.

\subsubsection{Success and failure symbols}\label{3.6.3}

The execution of the \g{success-symbol} \pp|+| always succeeds, the execution of
the \g{failure-symbol} \pp|-| always fails. Neither has side-effects.


\subsection{Compound members}\label{3.7}
\g{Compound-member}\/s serve to turn a composite \g{rule-body} into a
single \g{member}. Syntax:
\begin{grammar}
\item compound-member: open-symbol, [local-part, colon-symbol],

     rule-body, close-symbol.
\item local-part: rule-tag, local-affix\ast; local-affix\plus.
\end{grammar}
Example:
\begin{program}
(order-n: y<x,x->n,y->x,n->y;
          x=y,get next int+x,:order;+)
\end{program}
\noindent
A \g{compound-member} is an abbreviated notation for the call of a rule.
Loosely speaking, the rule that is called has the same meaning as the
\g{rule-body} of the \g{compound-member}, and has no formal affixes, and its
local affixes are specified in the \g{local-part}. The call then calls that
rule. The following statement expresses this more precisely.

\smallskip
A \g{rule-declaration} for the rule that is called can be derived from the
\g{compound-member} in the following way.
\begin{itemize}
\item[a)] The \g{open-symbol} and \g{close-symbol} are removed.
\item[b)] A \g{point-symbol} is placed after the \g{rule-body}.
\item[c)] If the \g{local-part, colon-symbol} is absent, a \g{colon-symbol}
is placed in front of the \g{rule-body}.
\item[d)] If the \g{rule-tag} is missing, a \g{rule-tag} is placed in front
that produces a \g{tag} that is different from any other \g{tag} in the
program.
\item[e)] The \emph{type} of the \g{rule-body} is determined, and the
corresponding \g{typer} (see \Ref{Section 3.2.1}) is placed in front of 
the \g{rule-tag}.
\end{itemize}

\noindent
Example: For the \g{compound-member}
\begin{program}
(1->n, m=n; incr+m, m=n)
\end{program}
\noindent
the created \g{rule-declaration} is
\begin{program}
'question'zzgrzl: 1->n, m=n; incr+m, m=n.
\end{program}
\noindent
Since the rule created from a \g{compound-member} has no formal affixes, the
copying mechanism does not prevent the side effects from materializing. If \pp|n| is a
local or formal tag, then if the guard of the first \g{alternative} in the rule body
\begin{program}
  (1->n,m=n);
  n=0, do something;
\end{program}
\noindent
fails (because the value of \pp|m| is not one)), the side effect of changing
\pp|n| remains in effect and the guard of the second \g{alternative} will
never succeed.

\smallskip
Neither the \g{rule-tag} nor any of the \g{local-tag}\/s in the
\g{local-part} can have qualifiers.



\subsection{Classification}\label{3.8}

A \g{classification} is similar to an \g{alternative-series} in that both
specify a series of \g{alternative}\/s only one of which will eventually
apply. The difference is twofold: in a \g{classification} exactly one
\g{alternative} applies (as opposed to one or zero in an \g{alternative
series}), and the choice of the pertinent \g{alternative} is based on a
single value (as opposed to the successive execution of guards).
\g{Classification}\/s allow a faster selection of \g{alternative}\/s at the
cost of a less versatile selection mechanism. Syntax:

\begin{grammar}
\item classification: classifier-box, class-chain.
\item classifier-box: box-symbol, source, box-symbol.
\item class-chain: (class, semicolon symbol)\plus, last-class.
\item class: area, comma-symbol, alternative.
\item last-class: class; alternative.

\smallskip

\item area: sub-symbol, zone, (semicolon-symbol, zone)\ast, bus-symbol.
\item zone: [constant-value], up-to-symbol, [constant-value]; 

       constant-value; list-tag.
\end{grammar}
\noindent
A \g{list-tag} in a \g{zone} must identify a global (and not local or
eternal) stack or table; moreover the \g{constant-value} cannot be an actual
upper or lower limit, nor an external \g{constant-tag} (as these values are
not known during compilation time.

\smallskip
\noindent
Example 1:
\begin{program}
(n:get+char,
   (=char=
    [/0/:/9/],        dgt->type;
    [/a/:/z/;/A/:/Z/],ltr->type;
    [/+/;/-/;/*/;///],op->type;
    [0:31;127],       :n;
    [:],              err->type))
\end{program}
\noindent
Example 2:
\begin{program}
=tag=
[var   decl], handle variable+tag;
[macro decl], handle macro call+tag;
[proc  decl], handle routine call+tag;
              handle bad tag+tag
\end{program}

The execution of a \g{classification} starts with the evaluation of the
\g{source} in its \g{classifier-box}. Let the resulting value be $V$.
The \g{area}\/s in the \g{classification} are searched in textual order for
the first \g{area} which ``contains'' $V$. If such an \g{area} is found, the
\g{alternative} following that \g{area} applies and is executed (see 
\Ref{Section 3.2.2}). If
there is no such an \g{area}, the \g{last-class} must be an \g{alternative},
which then applies and is executed. Otherwise the program run is aborted with
an error message.

A given \g{area}  contains the value $V$ if one of its \g{zone}\/s contains
$V$. Whether a given \g{zone} contains $V$ is determined as follows.

\begin{itemize}
\item[a)]
If the \g{zone} is a \g{constant-value}, then it contains $V$ if $V$ is
numerically equal to the \g{constant-value}.
\item[b)]
If the \g{zone} contains an \g{up-to-symbol}, it is designated by two
boundaries. The left boundary $L$ is the \g{constant-value}
before the \g{up-to-symbol} or, if it is missing, the smallest (negative)
representable integer.
The right boundary $R$ is the \g{constant-value} after the
\g{up-to-symbol} or, if it is missing, the maximal representable integer. 
The \g{zone} contains $V$ if $L\le V\le R$.
\item[c)]
If the \g{zone} is a \g{list-tag}, this \g{list-tag} must identify a global
(and not a formal) list. The \g{zone} contains $V$ if $V$ is in the virtual
address space (see \Ref{Section 4.1.4}) assigned to that list.
\end{itemize}
\g{Area}\/s may coincide partially, but it is an error if an \g{area} cannot
be reached by some value of the \g{source}.

A \g{classification} can fail only if one of its \g{alternative}\/s
fail; and has side-effects if at least one of the \g{alternative}\/s has
side-effects.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\section{Data} \label{sec:4}

The basic way of representing information in \A{} is through integers. There
are four integer-based data types:
\begin{itemize}
\item[a)] integers (constants),
\item[b)] variables that contain integers,
\item[c)] ordered lists of integers (tables), and
\item[d)] ordered lists of locations that contain integers (stacks).
\end{itemize}
Integers used in data declarations can be given in the form of expressions.

The basic way of routing information into and out of the program is through
files. There are two file types:
\begin{itemize}
\item[a)] charfiles, files containing only integers that correspond to
characters, and
\item[b)] datafiles, files containing integers and 
pointers to prescribed stacks and tables.
\end{itemize}
There are three primitive actions on integer-based data: \g{transport}
(assignment), \g{comparison}, and \g{extension}. Additional integer handling
(such as addition and multiplication) are done through external rules.
There are no primitive actions on files, all file handling is done through
externals. Syntax:

\begin{grammar}
\item data-declaration:

constant-declaration; variable-declaration; static-variable-declaration;

table-declaration; stack-declaration; static-stack-declaration;

table-filling; stack-filling;

file-declaration.
\item data-prototype:

constant-prototype; variable-prototype; static-variable-prototype;

table-prototype; stack-prototype; static-stack-prototype; 

file-prototype.
\end{grammar}

\subsection{Constants and variables}\label{4.1}

Constant and variable tags are initialized through expressions. Expressions
are evaluated during compilation.

\subsubsection{Expressions}\label{4.1.1}
Syntax:
\begin{grammar}
\item expression:
  [unary-operator], base, (binary-operator, base)\ast.
\item base: constant-value; open-symbol, expression, close-symbol.
\item unary-operator: minus-symbol; complement-symbol.
\item binary-opeator: times-symbol; by-symbol; plus-symbol; minus-symbol;

   or-symbol; and-symbol; xor-symbol.
\end{grammar}
Examples:
\begin{program}
-3 + 0x7f \& byte size
((/e/+1)*char size + /n/+1)*char size+/d/+1
/////// $ the code of / divided by itself\no$
\end{program}

The value of an \g{expression} is the integral value that results from
evaluating the \g{expression} according to the standard rules of arithmetic.
Operators applied in the order of their priorities; operators of equal
priority are applied from left to right. Unary operators have the highest
priority. They are followed by multiplication and division, then addition
and subtraction. The Boolean (bitwise) operators have the lowest
priority.

An \g{expression} through the \g{constant-value} (\Ref{Section 3.4}) cannot
contain actual upper or lower limits, and cannot contain external
\g{constant-tag}\/s. There is no restriction, however, on the usage of
\g{constant-tag}\/s exported by other modules.

\subsubsection{Constants}\label{4.1.2}

A \g{constant-declaration} specifies the integral value which is represented
by a \g{constant-tag}. This relationship is fixed and does not change.
Syntax:
\begin{grammar}
\item constant-declaration:   
   constant-symbol, constant-description,

     (comma-symbol, constant-description)\ast, point-symbol.
\item constant-description: constant-tag, equals-symbol, expression.

\smallskip
\item constant-prototype:
   constant-symbol, constant-tag,

   (comma-symbol, constant-tag)\ast, point-symbol.
\end{grammar}
Example for a \g{constant-declaration}:
\begin{program}
'constant'mid page = line width/2, line width=144.
\end{program}
\noindent
The value of the \g{expression} cannot depend on the \g{constant-tag}
being declared. Consequently, the declaration
\begin{program}
'constant' p=q, q=2-p.
\end{program}
\noindent
results in an error message. The \g{constant-tag} in a
\g{constant-prototype} should originate either from a \g{constant-declaration} or
from a \g{pointer-initialization}, see \Ref{Section filling}.


\subsubsection{Variables}\label{4.1.3}

An \A{} variable consists of a \g{variable-tag} and a location; the location
may or may not contain a value. If it contains a value, then the variable
\emph{has} that value. The content of the location may change. Once a
location has obtained a value it can't become empty again.

A global variable is declared in a \g{variable-declaration}; a
formal variable originates from a \g{formal-affix-sequence}, and a
local variable originates from a \g{local-affix-sequence}.

\begin{grammar}
\item variable-declaration: variable-symbol, variable-description, 

    (comma-symbol, variable-description)\ast, point-symbol.
\item variable-description: variable-tag, equals-symbol, expression.
\item static-variable-declaration:
    static-symbol, variable-declaration.

\smallskip
\item variable-prototype: variable-symbol, variable-tag,

   (comma-symbol, variable-tag)\ast, point-symbol.
\item static-variable-prototype: 
   static symbol, variable-prototype.
\end{grammar}
Examples:
\begin{program}
'variable'tag pnt=nil, median code=(<code+ >code)/2.
'static''variable'line cnt=0, page cnt=0.
\end{program}
\noindent
For each \g{variable-description} a location is created with
the \g{variable-tag} as its label, and filled with the value of the \g{expression}.
Variables can be used in \g{source}\/s and \g{destination}\/s. They cannot be
used in \g{expression}\/s.

A static \g{variable-tag} behaves as a variable in the module it is
declared, but in other modules it behaves like a \g{constant-tag}. The content
of a \g{variable-tag} can only be manipulated by rules in its defining module;
in other modules such a variable is ``read only''.

\subsection{Tables and stacks}

\subsubsection{The address space}\label{4.1.4}

\A{} stacks and tables together are called \emph{lists}. Items in lists are
identified by unique addresses; these addresses come from a range of integer
values called \emph{virtual memory space}. The range starts at some small
positive number and ends at a large positive number. Lists occupy separate
consecutive locations in this virtual memory. List elements are identified
(indexed) by their virtual memory addresses. Variables in \A{} have no
virtual addresses as they are not stored in the virtual memory space.

When an \A{} program is compiled, the complete available virtual memory
space is distributed among the lists in the program with almost no control
of the programmer. The chunk of memory addresses assigned to a list is its
\emph{virtual address space}. Frequently only a part of this virtual space
is in use, which is called the \emph{actual address space} of the list.

The virtual memory is distributed among all lists as follows.
\begin{itemize}
\item[a)] For each table and for each stack with empty \g{size-estimate} 
in its declaration, the
size of the actual address space is determined by its \g{filling}\/s. The
allocated virtual space is the amount necessary to store elements of those
fillings.
\item[b)] For a stack with an \g{absolute-size} the allocated virtual space
is the maximum of the given value and the total size of the fillings.
\item[c)] The remainder of the virtual address space is distributed over the
rest of the stacks proportionally to the specified \g{relative-size}.
\item[d)] External tables and stacks set up their own virtual limits from
a separate virtual memory range.
\end{itemize}
For each list the largest address in its virtual address space is its
\emph{virtual upper limit}, while the lowest address plus the \g{calibre}
(block size) minus one is its \emph{virtual lower limit}. These values are
determined at compile time and do not change.

The initial values of the \emph{actual limits} of the list are calculated as
follows. The \emph{actual lower limit} is set to the \emph{virtual lower
limit}. The initial value of the \emph{actual upper limit} is calculated
from the \g{filling}\/s of the list. These fillings are positioned next to
each other at the beginning of the virtual address space. The \emph{actual
upper limit} is set to the largest (rightmost) occupied virtual address. If
the list has no \g{filling}, then its \emph{actual upper limit} is set to
its virtual lower limit minus the \g{calibre}. This value is one less than the
lowest virtual address assigned to the list, thus does not point into the
list's address space.

The actual limits of a table are equal to its virtual limits and do not
change. Actual limits of a stack can change, but they always remain within
its virtual limits.

Suppose, for example, that the following list declarations (see \Ref{Section
4.1.5} and \Ref{Section 4.1.6}) occur in the program:
\begin{program}
'table' pw[]=(1,10,100,1000).
'stack' [= 5 =] dg []=(0),
        [ 30  ] st [],
        [ 50  ] (num,denom) ax[] =
                ((365,113):pi, (191,71):e).
\end{program}
\noindent
Assuming that the virtual memory is indexed from 10000 to 99999, the
virtual address space could have the following layout:

\begin{center}%
\small
\def\K#1{\hbox to 3em{\hss\tt#1}}%
\let\tt\tft
\def\a#1{{\tft #1~~}}%
\begin{tabular}{rcccl}
address ~~ & contents & belongs to & selector & pointer \\[2pt]
%\K{-16}& ---        & ---       & ---        & \tt nil \\[-1pt]
\a{10000}& \K{1}      & \tt pw & \tt pw & \pp|<pw|, \pp|<<pw|\\[-1pt]
\a{10001}& \K{10}     & \tt pw & \tt pw &               \\[-1pt]
\a{10002}& \K{100}    & \tt pw & \tt pw &               \\[-1pt]
\a{10003}& \K{1000}   & \tt pw & \tt pw & \pp|>pw|, \pp|>>pw|\\
\a{10004-10009}& \K{---} & \multicolumn{2}{l}{ unassigned } & \\
\a{10010}& \K{0}      &\tt dg &\tt dg  & \pp|<dg|, \pp|<<dg|, \pp|>>dg|\\[-1pt]
\a{10011-10013}& \K{---}      & \tt dg  &      &               \\[-1pt]
\a{10014}& \K{---}            & \tt dg  &      &  \pp|>dg|\\
\a{10015-10018}& \K{---}  & \multicolumn{2}{l}{ unassigned } & \\
\a{10019}& \K{---} & \multicolumn{2}{l}{ unassigned }& \pp|>>st|\\[-1pt]
\a{10020}& \K{---}        &\tt st     &     & \pp|<st|, \pp|<<st|\\[-1pt]
\a{10020-32327}& \K{---}  &\tt st   &     &               \\[-1pt]
\a{32328}& \K{---}        &\tt st   &     & \pp|>st| \\
\a{32329}& \K{---} & \multicolumn{2}{l}{ unassigned } & \\
\a{32330}& \K{355} &\tt ax    &\tt num~~  &               \\[-1pt]
\a{32331}& \K{113} &\tt ax    &\tt denom   & \pp|<ax|, \pp|<<ax|, \pp|pi|\\[-1pt]
\a{32332}& \K{191} &\tt ax    &\tt num~~   &               \\[-1pt]
\a{32333}& \K{71}  &\tt ax    &\tt denom   & \pp|>>ax|, \pp|e|\\[-1pt]
\a{32334-99998}& \K{---} &\tt ax  &  &                   \\[-1pt]
\a{99999}& \K{---}       &\tt ax  &   &  \pp|>ax|       \\
\end{tabular}
\end{center}

A stack can be extended to the right while raising its actual upper limit
through an \g{extension} (\Ref{Section 3.4.3}). Items can be removed from
the right of a stack through a call of a run in the Standard Library (see
\Ref{Section 5.2.4}) such as \pp|unstack| or \pp|unstack to|, after which
the discarded address space can be reclaimed again, but not the values in
it.

\subsubsection{Selectors}\label{selectors}

Elements of an \A{} table or stack are subdivided into consecutive blocks.
The address of the rightmost item in a block is the block address, and
values in the block are referenced through the block address and a
\g{selector-tag}. The \g{selector-tag} identical to the \g{list-tag} is
called the \emph{standard selector}. The available selectors, which might
miss the standard selector, are specified in a \g{field-definition}.

\g{Field-definition}\/s can be used in a \g{formal-affix-sequence} to
specify the block structure of a formal table or stack; in list declarations
and prototypes; and in \g{filling}\/s. If no \g{field-definition} is
specified in a declaration, then the blocks in the list have a single
element, and the selector of that element is the standard selector. Syntax:

\begin{grammar}
\item field-definition: field-list-pack\plus.
\item field-list-pack:

   open-symbol, field, (comma-symbol, field)\ast, close-symbol.
\item field: dummy-symbol; selector-tag, (equals-symbol, selector-tag)\ast.
\end{grammar}
\noindent
Examples for \g{field-definition}\/s:
\begin{program}
(s1,s2=t1,s3=t2)
(s1,s2,s3)(\#,t1,t2)
\end{program}

A \g{field-definition} contains one or more \g{field-list-pack}\/s. Each of
them defines the \g{calibre} of the list as the number of the \g{field}\/s
in it, this number must be the same for each \g{field-list-pack} in the
\g{field-definition}.

Selectors of the block elements are specified from left to right by the
\g{selector-tag}\/s in the \g{field-list-pack}. The same block element can
be identified by multiple selectors; the additional selectors are specified
after the initial selector using an \g{equals-symbol}, see the first
example. The second example specifies the same block structure with the same
selectors, emphasizing which selectors are used together. The
\g{dummy-symbol} \pp|\#| is used as a placeholder.

If a list is defined with a \g{field-definition}, then a matching prototype
must also contain a \g{field-definition}, while a \g{list-filling} may omit
it. All \g{field-definition}\/s of the same list must define the same
\g{calibre} (block size), and the same standard selector, but could define
different selector names which accumulate: any of the specified selectors
can be used to identify elements in the list. Nevertheless, all
\g{field-definition}\/s must be consistent on the standard selector.

\subsubsection{Limits}\label{4.1.7}

\g{Limit}\/s provide the block size, the virtual and actual limits of a
list as constant values. The actual limits of a stack can change by an
\g{extension} (\Ref{Section 3.4.3}), or by stack-manipulating externals
(\Ref{Section 5.2.4}).
Syntax:
\begin{grammar}
\item limit: limit-token, list-tag.
\item limit-token: static-limit; dynamic-limit.
\item static-limit: vlwb-symbol vupb-symbol; calibre-symbol.
\item dynamic-limit: alwb-symbol; aupb-symbol.
\end{grammar}
Examples:
\begin{program}
>table, <>blocksize, <<stack.
\end{program}

\noindent
The calibre is the block size of the list. Static limits are determined
during compilation; actual limits of a stack may change during the program
run as a consequence of actions that change the stack size. Actual limits of
a table do not change.

If the \g{list-tag} in the \g{limit} is a formal affix, the returned value
is the \g{limit} of the corresponding global list. In particular, the
\g{calibre} of a \g{formal-affix} is the calibre of the corresponding global
list, and not the calibre of the local affix.

\subsubsection{Tables}\label{4.1.5}

Tables originate from \g{table declaration}\/s. They contain values that
are determined at compile time and cannot change. Syntax:
\begin{grammar}
\item table-declaration: table-symbol, table-description,

  (comma-symbol, table-description)\ast, point-symbol.
\item table-description: table-head, sub-bus, [equals-symbol, filling].
\item table-head: [field-definition], table-tag.

\smallskip
\item table-prototype: table-symbol, table-head,

  (comma-symbol, table-head)\ast, point-symbol.
\end{grammar}

\noindent
Examples:
\begin{program}
'table'(s1,s2,s3)(\#,t2,t3) T[]. $ declaration\no$
'table'(up,down=S) S.  $ prototype\no$
\end{program}
\noindent

The \g{calibre} of the table \pp|T| is three. The first element of a block
of \pp|T| can be accessed by the selector \pp|s1| only; the last element by
both selectors \pp|s3| and \pp|t3|. The table \pp|T| has no standard
selector, consequently using the \g{list-element} \pp|T[ptr]| results in an
error. The table \pp|S| has \g{calibre} two, and the standard selector
identifies the last element of its block.

\smallskip

A \g{table-declaration} declares a table, specifies the block size
(calibre), selectors, and whether it has a standard selector or not. The
content of the table is specified by \g{filling}\/s, one of which can be
optionally added at the declaration. The final order in which the different
\g{filling}\/s are stored in the table is unspecified.

\subsubsection{Stacks}\label{4.1.6}
Stacks originate from \g{stacks-declaration}\/s. Syntax:
\begin{grammar}
\item stack-declaration: stack-symbol, stack-description,

   (comma symbol, stack-description)\ast,  point-symbol.
\item static-stack-declaration:

  static-symbol, stack-declaration.
\item stack-description:

    sub-symbol, size-estimate, bus-symbol, stack-head, sub-bus,

    [equals-symbol, filling].
\item stack-head: [field-definition], stack-tag.

\smallskip
\item size-estimate:

   empty; absolute-size; relative-size.
\item absolute-size: box-symbol, constant-value, box-symbol.

\item relative-size: constant-value.

\smallskip

\item stack-prototype: [static-symbol], stack-symbol, stack-head,

  (comma-symbol, stack-head)\ast, point-symbol.
\end{grammar}
Examples:
\begin{program}
'stack'[= line width =](char)print line[]. $ declaration\no$
'stack'BUFFER, (flag,data) RULE.  $ prototype\no$
\end{program}

\noindent
The stack \pp|print line| has a fixed number of elements specified by the
\g{constant-tag} \pp|line width|, it has one-element blocks, and no
standard selector. This stack cannot grow beyond its specified limit,
however it can still shrink. In the prototype two stacks are specified.
For \pp|BUFFER| no \g{field-definition} is given, the same prototype
can be written equivalently as \pp|(BUFFER)BUFFER|.

\smallskip

A \g{stack-declaration} declares a stack, specifying the required virtual
memory. If the \g{size-estimate} is empty, the allocated virtual memory will
be determined by the total size of \g{filling}\/s. The \g{absolute-size}
specifies the number of requested virtual locations (not blocks); this
number must be positive. The \g{relative-size} must be positive and at most
100. The \g{constant-value} in the \g{size-estimate} cannot depend on values
which are determined after the distribution of the virtual memory, such as
virtual limits or pointer constants.

A static \g{stack-tag} behaves as a stack in the module it is declared, but
in other modules it behaves like a \g{table-tag}: neither the list itself,
nor its content can be modified.

\subsubsection{Filling}\label{filling}

The initial content of lists is defined in \g{filling}\/s. \g{Filling}\/s of
the same list can spread across the program, even across different
modules. Each \g{filling} is stored in the designated list at consecutive
locations, but the order in which the different \g{filling}\/s appear is
unspecified. A \g{filling} may contain \g{pointer-initialization}\/s which
define a \g{constant-tag} with the value of the virtual address of the block
it follows.

\begin{grammar}
\item table-filling:

  table-symbol, table-head, equals-symbol, filling.

\item stack-filling:

  stack-symbol, stack-head, equals-symbol, filling.

\item filling: open-symbol, filling-unit, 

     (comma-symbol, filling-unit)\ast, close-symbol.
\item filling-unit: 

    constant-value, [multiplier], pointer-initialization\ast;

    open-symbol, compound-block, close-symbol, 

    ~ ~ ~  [multiplier], pointer-initialization\ast;

    string-denotation, pointer-initialization\ast.

\item compound-block: value-block; selector-block.
\item multiplier: times-symbol, constant-value.
\item pointer-initialization: colon-symbol, constant-tag.
\smallskip
\item value-block:

   (constant-value, comma-symbol)\ast, constant-value, 

   ~ ~ ~  [times-symbol], (comma-symbol, constant-value)\ast.

\item selector-block:

   fill-transport, (comma-symbol, fill-transport)\ast.

\item fill-transport: constant-value, (arrow-symbol, selector-tag)\plus.
\end{grammar}

\noindent
Examples:
\begin{program}
'stack'(ch,p)optor=
  ( (/+/->ch,3->p),(3->p,/-/->ch),(5->p,/^/->ch) ).
\smallskip
'table'messages=("tag undefined":bad tag).
\end{program}

\noindent
Values in the \g{filling} specify the content of consecutive locations of the
designated list. Each \g{filling-unit} defines one or more blocks of the
list which are added to the list in the order they appear. Each
\g{filling-unit} can be followed by \g{pointer-initialization}\/s. If
present, all \g{constant-tag}\/s in it are defined to have the virtual address
of the block.

If the \g{filling-unit} is a \g{constant-value}, then it defines a single
element block with the specified content. If there is a \g{multiplier}, then
the block is repeated by the specified value, which must be at least one.

If the \g{filling-unit} is \g{compound-block}, then it specifies a complete
block, the number of elements must be equal to the calibre of the list. In a
\g{value-block} the block elements are specified in a left to right order.
One of the elements can be followed by the \g{times-symbol} \pp|*|
indicating that this element should be repeated, if necessary, to get the
required number of block elements. Example: the \g{filling}
\begin{program}
'stack'(a,b,c,d,e,f,g,h)big block=( (1,0*,1)*100 ).
\end{program}

\noindent
adds 100 blocks to the stack \pp|big block|, each consisting of a \pp|1|,
six \pp|0|, and another \pp|1|. The block can also be written as
\pp|(1,0*6,1)|.

If the \g{compound-block} is a \g{selector-block}, then the
\g{constant-value}\/s are stored at the location(s) specified by the
\g{selector-tag}(s). One of the selectors can be replaced by the
\g{times-symbol} \pp|*| to mean that the value should be copied to all
selectors not mentioned explicitly in the \g{selector-block}.

If a \g{value-block} specifies less elements or more elements than the
calibre, a warning is given. If a \g{selector-block} specifies less elements
than the calibre, then those elements must form an end-segment of the block,
and a warning is given.

If the \g{filling-unit} is a \g{string-denotation}, the string is stored, in
compressed form, at several consecutive locations, forming a
\emph{string block}. As other blocks, the string block is also identified by
the address of its last (rightmost) element. String blocks can be
manipulated by Standard Library rules, see \Ref{Section 5.2.3}.

\subsection{Files}\label{4.2}

\A{} files originate from \g{file declaration}\/s. They are associated with
file-system elements through an explicit or implicit call to the Standard
Library rule \pp|open file|, and detached by the rule \pp|close file| (see
\Ref{Section 5.2.5}). Files can be opened for \emph{reading}, when the
content of the associated file is made available for the \A{} program, or for
\emph{writing}, when the data written to the \g{file} is stored in the
associated computer file. A \g{file} cannot be opened for
reading and writing simultaneously. Syntax:

\begin{grammar} \item file-declaration:
file-typer, file-description,

    (comma-symbol, file-description)\ast, point symbol.
\item file-typer: charfile-symbol; datafile-symbol.
\item file-description: file-tag, [file-area], equals-symbol,

  [right-symbol], string-denotation, [right-symbol].
\item file-area:

   sub-symbol, list-tag, (semicolon-symbol, list-tag)\ast, bus-symbol.

\smallskip
\item file-prototype:

  file-typer, file-tag, (comma symbol, file-tag)\ast, point-symbol.

\end{grammar}
Examples:
\begin{program}
'charfile'OUTPUT=>"result.txt", INPUT="data/survey.txt">.
\smallskip
'datafile'TEMP[tag;link]= >"/tmp/xbcrq.bin">.
\end{program}

A \g{file-description} declares a \g{file} of the type indicated by the
\g{file-typer}. The \g{file-area} can be used in \g{datafile} declarations
only.

If an \A{} \g{file} is not opened explicitly, then the first file operation
using the \g{file-tag} tries to associate it with the file-system element
specified in the \g{string-denotation}. The optional \g{right-symbol}\/s
before and after the \g{string-denotation} restrict this implicit opening:
the \g{file} is opened for \emph{writing} only if there is a
\g{right-symbol} before the string (indicating the data is allowed to flow
into the specified string), and opened for \emph{reading} only if there is a
\g{right-symbol} after the string (indicating that data can flow from the
string). When the \g{file} is opened explicitly by a call of \pp|open file|,
this restriction does not apply.

\A{} contains no explicit \g{file} handling statements: all file handling is
done through rules in the Standard Library, see \Ref{Section 5.2.5}. Files
are read and written sequentially. When a file is opened for reading, it can
be positioned to a previously visited location; in particular it can be
reset and reread from the beginning. Files opened for writing cannot be
positioned. Writing to a file ends when the file is closed, or when the program
terminates.

\subsubsection{Character files}\label{4.2.1}

An \A{} character file is a sequence of unicode characters stored using
UTF-8 encoding. A \g{charfile} returns and accepts unicode characters,
converting these characters to and from UTF-8 encoding on the fly.
Standard Library rules allow two ways of processing a character file.
\begin{list}{}{\setlength\topsep{2pt}%
\setlength\partopsep{3pt}%
\setlength\parsep{0pt plus 2pt}%
\setlength\labelsep{0pt}%
\setlength\labelwidth{\parindent}%
\setlength\leftmargin{\parindent}}
\item[Characterwise: ]
when a character file \pp|file| is opened for reading, each call of the
external predicate \pp|get char+""file+ch>| yields the next unicode
character in \pp|ch|, failing when the end of file is reached. When opened
for writing, the action \pp|put char+""file+>ch| adds the unicode character
\pp|ch| to the file written, ignoring the request if \pp|ch| is illegal or
zero.

\item[Linewise: ]
the predicate \pp|get line+""file+[]stack[]+ch>| extends the \pp|stack| with
the character codes of a complete line in the following way. If there are no
more characters in the file, then the rule fails, and the \pp|stack| is
unchanged. If the next character in the \pp|file| is a \pp|newline|, then it
is skipped, and \pp|ch| is set to the code of the newline character; if the next
character is not a \pp|newline|, then \pp|ch| is set to the value \pp|rest
line|. Subsequently unicode characters are read from \pp|file| until either
the end of file, or until the next character would be a \pp|newline|. Codes
of the characters read are put on the top of \pp|stack| in the order they
are read, and then \pp|get line| returns with success.

The action \pp|put line+""file+table[]+>ch| assumes that all elements in
\pp|table| are codes of unicode characters, appends all of these characters
to \pp|file|, and also a character with code \pp|ch|, except when \pp|ch| is
\pp|rest line|, which is ignored.
\end{list}

\smallskip

Character files \pp|STDIN| and \pp|STDOUT| defined in the Standard Library
read from the standard input and write to the standard output, respectively;
typically it means reading from and writing to the console.

\subsubsection{Data files}\label{4.2.2}

An \A{} datafile consists of a list of \emph{data items}. A data item is an
integer value and an indication about its meaning. This indication is either
\pp|numerical|, in which case the integer value stands for itself, or it is
a serial number identifying an \A{} \g{list}, in which case the integer value
is an offset from the left end of that list.

A data item is written to a \g{datafile} by a call of the action \pp|put
data+""file+\allowbreak>item+\allowbreak>type|. The data item is constructed
from the \pp|item| and \pp|type| affixes and from the \g{file-area} in the
\g{file-description} of the \pp|file| in the following way.

If the affix \pp|type| equals \pp|numerical|, then the data item consists of
the value of the \pp|item| affix and indication \pp|numerical|.

If the affix \pp|type| equals \pp|pointer|, then the value of \pp|item| must
either be zero (indicating the null pointer), or be an address in the
virtual address space of one of the lists whose \g{list-tag} is enlisted in
the \g{file-area}. The data item then consists of the offset from the left
end of that list and the serial number of the list in the \g{file-area}.

Data items are read from a datafile by calls of the predicate \pp|get
data+\allowbreak""file+\allowbreak{}item>+\allowbreak{}type>|. If there are
no more data items on the datafile, the predicate fails. If there is still a
data item on \pp|file|, it is read and the \pp|item| and \pp|type| are
reconstructed, using the lists in their order of appearance in the
corresponding \g{file-area}.

Datafiles can be used to transfer information from one \A{} program to
another. Pointers to lists that occupy different virtual addresses in the
programs are adjusted automatically during the transfer.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Externals}\label{sec:5}

External items can be used in the same way as internally declared ones. An
external rule differs from an internal rule in that its body is not given by
the \A{} construct, but is instead obtained from some external source. In the
same way values of other external items are obtained from external
sources. The necessary information for correct compilation is supplied by
the \g{external-declaration}\/s. Since the correct usage requires special
knowledge about the low level details of the compiled code,
\g{external-declaration}\/s are restricted to \emph{library mode} only. Many
items in the Standard Library are realized by externals. Syntax:

\begin{grammar}
\item external-declaration:

external-rule-declaration; external-data-declaration.

\item external-rule-declaration:

   external-symbol, typer, external-rule-description,

    ~ ~ ~   (comma-symbol, external-rule-description)\ast, point-symbol.

\item external-rule-description:

rule-head, equals-symbol, string-denotation.
\end{grammar}

\noindent
Example:
\begin{program}
'external''function'add+>x+>y+z>   = "\#3=\#1+\#2",
                    subtr+>x+>y+z> = "\#3=\#1-\#2".
'external''exit'exit+>code = "\_exit(\#1)".
\end{program}

An \g{external-rule-description} defines a rule of the type specified by
\g{typer} and known to the \A{} program by the name \g{rule-tag}. The
\g{string-denotation} describes, in an implementation dependent way, how
calls of the \g{rule-tag} are handled. It is the responsibility of the
supplier of the \g{string-denotation} to see that it translates to actions
which are in accordance with the type of the rule and that no side effects
will occur when a call of the rule fails.

\smallskip

An \A{} program can access and manipulate system data using
\g{external-data-declaration}\/s. For example, the external table
\pp|STDARG| is pre-filled with the command line arguments specified when the
\A{} program is launched. Syntax:

\begin{grammar}

\item external-data-declaration:

   external-symbol, data-typer, external-data-description,

   ~ ~ ~ (comma-symbol, external-data-description)\ast, point-symbol.

\item data-typer: constant-symbol; variable-symbol; 

  table-symbol; stack-symbol; file-symbol.

\item external-data-description:

       data-head, equals-symbol, string-denotation.

\item data-head:

       [field-definition], list-tag;

       constant-tag;

       variable-tag;

       file-tag.
\end{grammar}
Examples:
\begin{program}
'external''table'(head,tail)graph="initGraph".
'external''constant'sys time="return time()".
\end{program}

The \g{string-denotation} in the \g{external-data-description} specifies, in
an implementation dependent way, how the declared item is accessed. In the
external table declaration above, \pp|initGraph| is the name of an
external procedure which is responsible to prefill the table with
content and set its virtual and actual limits. Using the external
constant \pp|sys time| as a \g{constant-source} either in a \g{transport} or as an
\g{actual-affix} would supply the actual system time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\X{\smallskip\noindent}
\newcommand\XX{\smallskip\noindent\pp}
\newcommand\Y{\par\hangindent=\parindent\hangafter=0\noindent}
\newcommand\XP{\smallskip\noindent\pp|'pragmat'\no}

% page 67
\newpage
\section{Pragmats}\label{sec:6}

Pragmats control many aspects of the compilation. The exact position of 
a pragmat in the program may be significant. Syntax:

\begin{grammar}
\item pragmat: pragmat-symbol, pragmat-item,

    (comma-symbol, pragmat-item)\ast, point-symbol.
\item pragmat item:

pragmat-tag, equals-symbol, pragmat-value;

pragmat-tag, equals-symbol, pragmat-value-list.

\item pragmat-value-list: open-symbol, pragmat-value, 

 (comma-symbol, pragmat-value)\ast, close-symbol.
\item pragmat-value:

tag;

integral-denotation;

string-denotation.
\end{grammar}
Example:
\begin{program}
'pragmat'module=basic,
    require=("mod1","mod2),
    macro=(show integers, is value, set all bits).
\end{program}
\noindent
The \g{tag} in a \g{pragmat-value} must be an identifier, this \g{tag} cannot have a
qualifier. 

Before a \g{pragmat} is evaluated, it is preprocessed: the
\g{pragmat-value-list} is removed in the following way.

For every \g{pragmat-value-list} which is preceded by an \g{equals-symbol}
preceded by a \g{pragmat-tag}, the \g{equals-symbol} and \g{pragmat-tag} are
removed and inserted in front of each \g{pragmat-value} in the
\g{pragmat-value-list}. Subsequently all \g{open-symbol}\/s and
\g{close-symbol}\/s are removed.

The \g{pragmat-item} \pp|require=("mod1","mod2")| thus has the same meaning
as \pp|require="mod1", require="mod2"|.

\subsection{Compiler output}

Pragmats in this group control the output of the \A{} compiler.

\XP|tab width=|\g{integer}.\Y
The right hand side of the \pp|tab width| \g{pragmat} must be a positive
integer less than 100. The value will be used as the tab size for 
program text printing. The default value is \pp|8|.

\XP|right margin=|\g{integer}.\Y
Sets the right margin for program text and dictionary printing. 
The default value is \pp|120|.

\XP|list=on/off.|\Y
The \g{tag} on the right hand side of the \pp|list| \g{pragmat} can be
\pp|on| or \pp|off|. The program text source is printed when this value is
\pp|on|. The default is \pp|off|.

\XP|dictionary=on/off.|\Y
The \g{tag} in the pragmat can be \pp|on| or \pp|off|. When it is
\pp|on|, each \g{tag} with the corresponding source line number is stored in
a dictionary. The dictionary, if not empty, is printed when the compilation
finishes. The default is \pp|off|.

\XP|warning level=|\g{integer}.\Y
Set the warning level between \pp|0| and \pp|9|, \pp|0| being the most verbose.
The default value is 4.

\XP|error=|\g{string-denotation}.\Y
Issues a compilation error with the given message.

\XP|warning=|\g{string-denotation}.\Y
Issues a compilation warning at level 9 with the given message.

\subsection{Compilation pragmats}\label{6.1}

Pragmats in this group control aspects of code generation.

\XP|bounds=on/off.|\Y
Turn index checking on or off. If it is \pp|on|, list indices are checked to
point into the actual address space of the list. When it is \pp|off|, no
checking is performed. The default value is \pp|off|. Index checking cannot be
turned on or off inside an \g{actual-rule}.

\XP|count=on/off.|\Y
Turn profiling on or off. If it is \pp|on| when compiling 
an \g{actual-rule}, a counter is added which counts the number of
calls to this rule. These call numbers are printed out after the run of the 
compiled program terminates. The default value is \pp|off|.

\XP|trace=on/off.|\Y
Turn tracing on or off. If it is \pp|on| when compiling an \g{actual-rule},
code is added which prints out the rule name and the value of its \g{in-} and
\g{inout-affix}\/es whenever the rule is called. The default value is
\pp|off|.

\XP|macro=|\g{rule-tag}.\Y
In the compilation unit of this \g{pragmat}, calls of the \g{actual-rule}
corresponding to the specified \g{rule-tag} are implemented by textual
replacement. The replacement, however, can result in a syntactically
incorrect program text or in a different semantics, see \Ref{ection macros}.
The \g{rule-tag} cannot have a qualifier.

\XP|library mode=on/off.|\Y
Turn library mode on or off. The value
determines whether library extensions are allowed or not. The default of
\pp|off|.\Y
If \pp|library mode| is \pp|on|, the \pp|@| character is considered to be a
letter, thus private tags can be created. Directory listing ignores tags
starting with \pp|@|. More importantly, \g{external-declaration}\/s and the
\pp|front matter| and \pp|back matter| pragmats are allowed in library mode
only.

\XP|front matter=|\g{string-denotation}.\Y
The string, without quote marks, is copied to the front of the
generated code. In the string the character pair \pp|\%n| is replaced by the
newline character. This pragmat is accepted only when \pp|library mode| is
\pp|on|. The order in which strings from different \pp|front
matter| pragmats appear is unspecified.

\XP|back matter=|\g{string-denotation}.\Y
This pragmat is handled similarly to \pp|front matter|, only the supplied
string is copied to the end of the generated code.

\subsection{Conditional pragmats}\label{cond-pragmat}

\def\pgaaif#1{\pp|'pragmat'#1=}
%\def\pgaif#1{\setbox0\hbox to 30em{\pgaaif{#1}\endgroup\g{tag}\hfil}\unhbox0}
\def\pgaif#1{\hbox to 0.3\textwidth{\pgaaif{#1}\endgroup\g{tag}.\hfil}}
\def\pgif#1{\rule{0pt}{0pt}\pgaif{#1}\pgaif{else}\pgaif{endif}}


Conditional pragmats can be used to instruct the compiler to ignore certain
parts of the source file. They have the syntax

\medskip

\pgif{if}
%\pp|'pragmat'if=TAG.     'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pgif{ifnot}
%\pp|'pragmat'ifnot=TAG.  'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pgif{ifdef}
%\pp|'pragmat'ifdef=TAG.  'pragmat'else=TAG.   'pragmat'endif=TAG.|


\noindent or

\pgif{ifndef}
%\pp|'pragmat'ifndef=TAG. 'pragmat'else=TAG.   'pragmat'endif=TAG.|

\medskip
\noindent
The \g{tag} in \pp|if| and \pp|ifnot| pragmats can be one of \pp|compile|,
\pp|module|, \pp|library mode|, \pp|list|, and \pp|dictionary|. The program
text between the \pp|if| and \pp|else| pragmats is processed if \g{tag} is
(or is not) in effect, otherwise it is skipped; and the opposite is true for
the text between \pp|else| and \pp|endif|. The \pp|else| part may be
missing. The \g{tag} in \pp|ifdef| and \pp|ifndef| pragmats can be any
identifier, and the compiler checks if this \g{tag} has (has not)
been defined at this point by a declaration, an import prototype, or by a
\pp|define| pragmat.

\XP|define=|\g{tag}.\Y
Mark the specified \g{tag} as ``defined'' for use in an \pp|ifdef|
pragmat.

\smallskip\noindent
Example for a conditional pragmat:
\begin{program}
'pragmat'if=module,include="private",else=module,
                   include="public",endif=module.
\end{program}
\noindent
It adds the source file \pp|private| among those to be processed if a
\pp|module| pragmat has been processed previously, otherwise it adds the
\pp|public| source file.

The \pp|if.\!.\!.endif| pragmats must be nested properly, and the
skipped text must be syntactically correct (as it is scanned to find the
closing pragmat). The \pp|'end'| symbol marking the end of the source file
is never ignored: conditional pragmats do not extend over the end of the
current file.



\subsection{Module pragmats}\label{6.4}

\XP|compile=on/off.|\Y
The value of this pragmat is set automatically to facilitate module
handling, see \Ref{Chapter sec:units}. It cannot be manipulated directly in
the program text.

\XP|title=|\g{string-denotation}.\Y
This pragmat is ignored if the pragmat \pp|compile| is \pp|off|, otherwise it
sets the title of the unit under compilation. The default title, if none is
specified, is \pp|"aleph"|. The title string is not used explicitly, but it
can be included in the program text by the \g{manifest-string}
\pp|\_title\_|, and it also appears in the intermediate \texttt{ALICE} code, as
well as in the linked final code.

\XP|std library=on/off.|\Y
Enable or disable Standard Library source files. The default value is
\pp|on|. This pragmat is accepted only when \pp|compile| is \pp|on|.

\XP|module=|\g{tag}.\Y
If \pp|compile| is \pp|on|, the current compilation unit is defined to be a
module and the value of the \pp|prototype| pragmat is set to \pp|public|.
The \g{tag} in the pragmat defines both the module name and its namespace.
After the pragmat has been processed, the condition \pp|if=module| holds in
subsequent conditional pragmats. If \pp|compile| is \pp|off|, the
\pp|module| pragmat specifies the name and namespace of the invoked module,
and also sets the \pp|prototype| pragmat to \pp|import|.

\XP|require=|\g{string-denotation}.\Y
The string specifies a filename, and the \A{} source in that file must be a
\emph{module}. The module is added to the \emph{module hierarchy} of the
\g{unit} under compilation, and the filename is added, if it is not there, 
to the pool of the \emph{required} source files to be processed.

\XP|library=|\g{string-denotation}.\Y
Add the filename specified by the string, if it is not there, to the pool of
\A{} source files to be processed as a \emph{user library}. This \g{pragmat}
is accepted only if \pp|compile| is \pp|on|.

\XP|include=|\g{string-denotation}.\Y
Add the filename specified by the string to the pool of \A{} source files to
be processed as an addendum to the current source file.

\XP|prototype=import/public/none/reverse.|\Y
This pragmat has three possible values: \pp|import|, \pp|public|, and
\pp|none|; the default value is \pp|none|. The pragmat determines how the
compiler handles \g{prototype}\/s. The case \pp|prototype=import| indicates
that the \g{tag} in a \g{prototype} has a declaration outside this \g{unit}
(and then it cannot occur in a \g{declaration} in this \g{unit}). In the
case \pp|prototype=public| a \g{tag} appearing in a \g{prototype}
automatically gets the \emph{public} flag, and must be declared in this unit
(in particular, it cannot be imported, and this unit must be a module). When
\pp|prototype=none|, prototypes are used for type checking only, and do not
imply any specific behavior. Finally, \pp|prototype=reverse| swaps the
current prototype value between \pp|import| and \pp|public|, while keeping
\pp|none| unchanged.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Units}\label{sec:units}

\subsection{Source files}

Translating an \A{} \g{unit} may require processing several files. The
compiler maintains a pool of source files to be processed. Files in this
pool are handled one at a time: a source is read, processed and closed
before opening the next one. Once opened, a source file is read until either
the end of file or an \g{end-symbol} is encountered. Everything after the
\g{end-symbol} is ignored. Initially the pool contains the source file(s)
submitted for compilation. Additional source files are added to the pool by
the \pp|require|, \pp|library|, and \pp|include| pragmats, see \Ref{Section
6.4}. Processing of library modules starts only after all non-library
sources have been completed. Files provided by \pp|require| and
\pp|include| pragmats inside a library module are treated as library files.

Before opening a source file, all \g{pragmat}\/s are reset to their
default values (see \Ref{Chapter sec:6}), except for the \pp|compile| and
\pp|prototype| pragmats, which are handled as follows.

\begin{itemize}
\item[a)]
If the source file was submitted directly for compilation, these pragmats are set
to \pp|compile=on|, and \pp|prototype=none|.
\item[b)]
If the source file was added by a \pp|request| or by a \pp|library| pragmat,
their values are \pp|compile=off| and \pp|prototype=import|.
\item[c)]
If the source file was added by an \pp|include| pragmat, both \pp|compile| and
\pp|prototype| are reset to the values they took when the \pp|include|
pragmat was executed.
\end{itemize}

\subsection{Modules}

According to the best practice the name of the source file containing the
source text of the module should resemble the module name. It is
particularly relevant in \A{} as modules are invoked by specifying file
names, and not module names. While not recommended, different module
\g{unit}\/s (that is, modules in different source files) can share the same
module name, and, consequently, the same namespace.

The first non-comment line in a typical \A{} module is a \pp|module|
\g{pragmat}, specifying both the module name and the namespace. This pragmat
is followed by the public part of the module, or the \emph{module head}. The
head contains the prototypes of the (public) tags to be exported by, and defined
in, this module. The module source is concluded by the private part, or
\emph{module body}, which defines the exported items together with the
optional auxiliary, unexported items. The body is enclosed between
\pp|ifdef=compile| and \pp|endif=compile| conditional pragmats.

The module is compiled by submitting its source file to the \A{} compiler.
The source file is opened with \pp|compile=on| and \pp|prototype=none|. The
leading \pp|module| pragmat informs the compiler that it is handling a
\emph{module}. Executing this pragmat sets the module name (and namespace)
as well as the pragmat \pp|prototype| to \pp|public|. The \g{prototype}\/s
in the module head specify items to be exported. The conditional pragmat
\pp|if=compile| enclosing the body holds, thus the body is processed as
well. The compiler checks that items with the \emph{public} flag (that is,
which have \g{prototype}\/s in the head) are indeed defined correctly.

When the module is \emph{required} by a \pp|require| pragmat, its source is
opened with \pp|compile=off|. The leading \pp|module| pragmat specifies the
name and namespace of the invoked module, and sets the \pp|prototype|
pragmat to \pp|import|. Due to this setting the subsequent \g{prototype}\/s
are considered to have declarations outside the \g{unit} under compilation,
as is the case now. Reaching the \pp|if=compile| conditional pragmat the
condition fails, thus the module body is skipped.

Next to \g{prototype}\/s, the module head may contain additional \A{}
constructs. A \pp|require| pragmat in the head automatically re-exports
the imported items (using their original namespace), while declarations in
the head are compiled into the invoking program locally, using the module's
namespace. It may happen, without any program, that the head of module
\pp|A| requires module \pp|B|, while the head of module \pp|B| requires
module \pp|A|.

\subsection{The module hierarchy}\label{subsec:hierarchy}

An \A{} \g{unit} (a \emph{main program} or \emph{module}) may require
several modules. Any module may also require other modules in its head,
which modules may also require additional modules, and so on. The ``\pp|X|
required module \pp|Y|'' relation defines a hierarchy among the involved
units. In this hierarchy \pp|A| is \emph{below} \pp|B| if there is a
``require'' chain from \pp|A| to \pp|B|. Resources provided by module \pp|B|
are automatically available for every unit below \pp|B| in this hierarchy.

When \pp|A| needs a resource, that resource might be provided by several
modules. In the basic case, among the potential offers that module is chosen
which is above \pp|A| and has the \emph{smallest rank}, that is, which
requires the smallest number of ``require'' hops to reach it from \pp|A|. By
default, \pp|A| has rank zero above itself.

The same module can be required by different modules, in which
case this module appears in the hierarchy at several places. Nevertheless,
it is still processed only once. Modules added as \emph{user library}
using the \pp|library| pragmat, and modules required recursively by
these library modules, form a second hierarchy. Elements of this hierarchy
are \emph{above} all elements of the first one by a very high hop number.
Using this arrangement, resources defined by a library module are available
to every plain module, but only as a last resort: if no other definition can
be found, then consult the offers in library modules. On the top of the user
library hierarchy there is still another hierarchy: the Standard 
Library providing the realization of many basic operations.

\subsection{Tag definitions}\label{subsec:qualifier}

Global \g{tag}\/s can have a \emph{qualifier} specifying the
\emph{namespace} this tag belongs to, such as \pp|q{\cc}x|, where \pp|q| is
the qualifier. Without providing an explicit qualifier, \g{tag}\/s in
definitions (\g{declaration}\/s and import \g{prototype}\/s) inherit the
actual namespace. This namespace is empty in the main program; otherwise it
is the same as the module name as defined by the \pp|module| pragmat. The
explicit qualifier, if present, cannot be empty. A \g{tag} with a qualifier
identifies only those definitions where the same implicit or explicit
qualifier is used.

The process of finding the defining occurrence of a \g{tag} in the module
hierarchy goes as follows. Suppose the \g{tag} with identifier \pp|x| occurs
in \pp|A|, where \pp|A| is either a module or the main program, and the
\g{tag} has qualifier \pp|q| which is either explicit or implicit. (In case \pp|A|
is the main program, the implicit qualifier is empty.) First, check modules
which are \emph{strictly below} \pp|A|. If some of them defines \pp|q{\cc}x|
(where the qualifier in the definition can be either explicit or implicit),
then the one with the \emph{smallest absolute rank} (having the minimal
number of ``require'' hops from the main program, see \Ref{Section
subsec:hierarchy}) is chosen.

If this step does not give result, then consider \pp|A| and the modules
\emph{above} \pp|A|. If \pp|x| has no explicit qualifier, then it matches
any definition of \pp|x| in those modules; if \pp|x| has an explicit
qualifier \pp|q{\cc}x|, then it matches only those definitions where the
qualifier is (explicitly or implicitly set to) \pp|q|. Among the candidate
modules that one is chosen which has the smallest rank above \pp|A|.
If this search does not yield a unique definition, then it is an error.

\smallskip

This procedure is illustrated in the table below. Both modules in source
files \pp|"f1"| and \pp|"f2"| have the first line
\begin{program}
'pragmat'module=t.
\end{program}
\noindent
which sets the module name to \pp|t| for both; \pp|"f2"| is required by the
module in \pp|"f1"|, and \pp|"f1"| is required by the main program. Tags
(with the indicated explicit qualifier) in the ``definition'' column are
defined in the module head; the numbers below them identify the definition.
Numbers below the tags in the ``usage'' column show their defining
occurrences.

\begin{center}%
\def\x#1#2{\raisebox{-5pt}{$\hbox{\GREEN\tt
#1}\atop{\rule{0pt}{7pt}\scriptstyle(#2)}$}}
\begin{tabular}{|cccll|}
\hline
\rule{0pt}{10pt}file & require & module & definition & usage \\
\hline
\rule{0pt}{12pt}\GREEN "f2" & & \GREEN  t & \x b1 \x v2  & \x a3 \x v4 \x x6
\\[8pt]
\GREEN "f1" & \GREEN "f2" &  \GREEN t &  \x a3 \x v4  & \x a3 \x b1 \x x6 
\\[8pt]
main     & \GREEN "f1" &  & \x a5  \x{t{\cc}x}6 \x x7 & \x a5 
      \x{t\cc a}3 \x b1 \x v4 \x x7
\\[8pt]
\hline
\end{tabular}
\end{center}

\noindent
The \g{tag} \pp|a| used in the module from file \pp|"f1"| (and also in the
module from file \pp|"f2"|) has the implicit qualifier \pp|t|, therefore it
does not match definition (5) in the main program. The \g{tag}
\pp|x| in these modules matches definition (6) of \pp|t{\cc}x| in the main
program, but not definition (7) of \pp|x| (which is without qualifier).
Observe that definition (2) is not used at all; each occurence of \pp|v| in 
\pp|"f2"| uses definition (4) from \pp|"f1"|.

\subsection{Macro rules}\label{macros}

To improve efficiency, calls of rules declared in the same compilation
\g{unit} can be implemented by textual substitution. When the rule name
appears in a \pp|macro| \g{pragmat} (\Ref{Section 6.1}), calls to this rule
in the current compilation unit are replaced by the \g{rule-body}, and replacing
the \g{formal-affix}\/es by the actual ones. The substitution, however, can
result in a syntactically incorrect program text, or in a different
semantics. The following examples illustrate these cases and explain the
additional restrictions a macro rule must satisfy.

\begin{itemize}%
%\def\becomes{$\Rightarrow$\space}%
\def\HH{\noindent\hbox to 0.25\linewidth\bgroup\hskip 10pt}%
\def\HE{\hfil\egroup$\Rightarrow$\qquad}%
\item[a)]
In a macro, a formal \g{in-variable} affix cannot be assigned to.
Indeed, suppose the rule \pp|macro| is defined as
\begin{program}
'function'macro+>x+y>: 1->y->x,x->y.
\end{program}
\noindent
After textual substitution the replacement can be syntactically wrong as in

\HH \pp|macro+1+z|\HE \pp|(1->z->1,1->z)|.

\item[b)] There is a problem with the \g{dummy-symbol} \pp|\#| as
\g{actual-affix}. Using the same \pp|macro| rule as above, the following
substitution results in incorrect syntax:

\HH \pp|macro+u+\#| \HE \pp|(u->\#->u, u->\#)|.

\item[c)] While a macro rule can have a variable number of affixes, neither
\pp|shift affix block| nor \pp|get affix blockno| can be used in a macro
text as illustrated by the following example. The rule
\pp|is zero| below checks whether one of its arguments has
value zero; while rule \pp|math| computes the product of its arguments if none of
them is zero, otherwise it computes their sum:
\begin{program}
'question'is zero+@+>x: x=0; shift affix block+@,:is zero.
\smallskip
'function'math+y>+@+>x:
  is zero+@,0->y,(nxt:add+x+y+y,shift affix block+@,:nxt;+);
  1->y,(nxt:mult+x+y+y,shift affix block+@,:nxt;+).
\end{program}
If \pp|is zero| were substituted verbatim in rule \pp|math|, it would shift
out all affixes and then the computation in \pp|math| would not be carried over.
%
Similarly, suppose the rule \pp|macro| is defined as
\begin{program}
'function'macro+a>+@+>q: q->b, get affix blocno+a+@.
\end{program}
\noindent
where \pp|b| is some global variable. After verbatim substitution the 
repeat block could vanish completely causing syntax error: 

\HH\pp|macro+b+2+T| \HE 
   \pp|(2->b,get affix blockno+b+2+T)|

\item[d)] Standard selectors are not carried over. Example:
\begin{program}
'function'macro+t[]+x>: t[ptr]->x.
\end{program}

where \pp|ptr| is some global variable. After textual substitution

\HH \pp|macro+S+z|\HE \pp|(S[ptr]->z)|

\smallskip

while \pp|S| might not have a standard selector.

\item[e)] Out affixes get their values only after returning from a call.
%
The rule call \pp|swap+x+y+x| swaps the value of \pp|x| and \pp|y| if it is
defined as
\begin{program}
'function'swap+>a+>b>+c>: b->c,a->b.
\end{program}
\noindent
but as a macro it does \pp|(y->x,x->y)|, with a completely different result.
\end{itemize}

\smallskip

Items a) and c) are checked during compilation, and error messages are
issued if the conditions are violated. For b), if the actual affix is the
dummy affix \pp|\#|, the formal out affix in the macro is replaced by a
newly created anonymous local variable (which may be removed during
optimization). For d) the macro substitution mechanism remembers the last
substituted formal affix and uses that value for the standard selector
what the rule call would do. For e) and other side effects, no warning is, or
can be, given, but substitution clearly changes the semantics. So use macros
with care.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Standard Library}\label{5.2}

Items in the Standard Library can be used in all programs without further
notice. Any of these items, except for the variable affix handling rules,
can be redeclared.

\subsection{Integers}\label{5.2.1}



\subsubsection{Constants}

\XX|'constant' max int, min int, int size.|\Y
\pp|max int| is the largest representable integer, \pp|min int| is the
smallest (most negative) representable integer. \pp|int size| is the number
of decimal digits necessary to represent \pp|max int|.

\subsubsection{Arithmetical operations}

\XX|'function'add+>x+>y+z>, subtr+>x+>y+z>, mult+>x+>y+z>, div+>x+>y+z>.|\Y
These functions compute the standard arithmetic functions yielding the
result in the last affix
\pp|x+y->z|; \pp|x-y->z|; \pp|x*y->z|; integer part of \pp|x/y->z|.

\XX|'function'addmult+>x+>y+>z+u>, divrem+>x+>y+q>+r>.|\Y
\pp|addmult| yields \pp|x*y+z| in \pp|u|; \pp|divrem| returns the quotient
in \pp|q| and the remainder in \pp|r|: \pp|x/y->q|, \pp|x-y*q->r|.

\XX|'function'incr+>x>, decr+>x>, get abs+>x+y>, min+>x+>y>, max+>x+>y>.|\Y
\pp|incr| increases, \pp|decr| decreaseseases its affix by one; \pp|get abs| yields
the absolute value of \pp|x| in \pp|y|; \pp|min| and \pp|max| yield \pp|min(x,y)|
and \pp|max(x,y)|, respectively, in \pp|y|.

\subsubsection{Comparison}

\XX|'question'less+>p+>q, lseq+>p+>q, equal+>p+>q, not equal+>p+>q,|
\par\noindent
\pp|          mreq+>p+>q, more+>p+>q.|\Y
These rules succeed if the corresponding relation holds between the integer
values \pp|p| and \pp|q|.

\XX|'question'is+>x, is true+>x.|\Y
succeeds if \pp|x| is \emph{not} zero, equivalent to the \g{comparison} \pp|x!=0|.

\XX|'question'is false+>x.|\Y
succeeds if \pp|x| is zero, equivalent to the \g{comparison} \pp|x=0|.

\subsubsection{Bit operations}\label{5.2.2}

\XX|'function'bool invert+>x+y>.|\Y
The bitwise complement of \pp|x| is stored in \pp|y|.

\XX|'function'bool and+>x+>y+>z>, bool or+>x+>y+z>, bool xor+>x+>y+z>.|\Y
Bitwise Boolean operations.

\XX|'function'left clear+>x>+>n.|\Y
Shift \pp|x| (including the sign bit) left by \pp|n| positions; zeros 
enters from right. \pp|n| must be positive and at most 32.

\XX|'function'right clear+>x>+>n.|\Y
Shift \pp|x| (including the sign bit) right by \pp|n| positions; zeros 
enter from left. \pp|n| must be positive and at most 32.

\subsection{Tables and stacks}\label{5.2.4}

\XX|'question'was+T[]+>p.|\Y
Succeeds if \pp|p| is between \pp|<<T| and \pp|>>T|, inclusive. This rule
can be used to test if \pp|p| points into the list \pp|T|.

\XX|'function'next+T[]+>p>, previous+T[]+>p>.|\Y
The calibre of \pp|T| is added to, or subtracted from, \pp|p|, moving the
pointer to the next or previous block, respectively.

\XX|'function'list length+T[]+len>.|\Y
The number of actual elements (not blocks) in \pp|T| is yielded in \pp|len|.
This value equals \pp|-1\,+\,<>T\,+\,>>T\,-\,<<T|.

\XX|'action'unstack+[]st[].|\Y
The stack \pp|st| must contain at least one block. The right-most block of
\pp|st| is removed; this operation decreases \pp|>>st| by \pp|<>st|. The 
location of the removed block can be reclaimed by an \g{extension}, its 
contents are lost.

\XX|'action'unstack to+[]st[]+>ptr.|\Y
Zero or more blocks are removed from the right hand side of \pp|st|, so that
\pp|>>st| becomes equal to \pp|ptr|. If this cannot be done, an error
message follows.

%\X\pp|'action'unqueue+[]st[].|\Y
%The stack \pp|st| must contain at least one block. The left-most block of
%\pp|st| is removed. Its (virtual) locations and its contents are lost.
%
%\X\pp|'action'unqueue to+[]st[]+>pnt.|\Y
%Zero or more block are removed from the left hand side of \pp|st|, so that
%the \pp|min limit| of \pp|st|  becomes equal to \pp|pnt|. If this cannot be
%done, an error message follows.

\XX|'action'scratch+[]st[].|\Y
All blocks in \pp|st| are removed. The locations can be reclaimed through
\g{extension}\/s, but the contents are lost. After this operation \pp|>>st|
will be equal to \pp|-1\,+\,<<st\,-\,<>st|.

\XX|'action'release+[]st[].|\Y
All blocks in \pp|st| are removed, as in a call of \pp|scratch|.
Additionally, the memory allocated for \pp|st| is also returned to the
operating system.

\XX|'predicate'request space+[]st[]+>n|\Y
After a successful return the allocated actual memory of the stack \pp|st|
is guaranteed to hold \pp|n| additional locations. The rule fails if the
requested memory would go beyond the virtual limits of \pp|st|, or the
operating system cannot provide the requested memory.

\subsection{Strings}\label{5.2.3}

Strings are stored in lists as special \emph{string blocks}. In a list a
string block is identified by the address of its last (rightmost) element,
and contains the characters of the string in a packed form. All string
handling rules assume that the affixes determine a string block; in case
they discover some discrepancy, the program run is aborted.

\XX|'function'string length+T[]+>p+n>.|\Y
The pointer \pp|p| must point to a string block in \pp|T|. The number of
unicode characters in the string is yielded in \pp|n|.

\XX|'function'string width+T[]+>p+n>.|\Y
The number of locations in the string block (the block size) is yielded in
\pp|n|.

\XX|'action'previous string+T[]+>p>|\Y
The pointer \pp|p| must point to a string block; \pp|p| is moved to the
(possibly non existing) location just before the string block. It is
achieved by subtracting \pp|string width| from \pp|p|.

\XX|'function'compare string+T1[]+>p1+T2[]+>p2+cmp>.|\Y
The two strings are compared lexicographically. If the first string is
smaller than the second one, then \pp|cmp| will be a negative number; if they are
equal then \pp|cmp| will be zero; if the first string is greater than the
second one then \pp|cmp| will be a positive number.

\XX|'function'compare string n+T1[]+>p1+T2[]+>p2+>n+cmp>.|\Y
The two strings are compared lexicographically, but before comparison they
are truncated to contain at most \pp|n| characters. The value of \pp|n| must
be non-negative.

\XX|'question'string elem+T[]+>p+>n+c>.|\Y
The pointer \pp|p| must point to a string block in \pp|T|. If the string
has an \pp|n|-th character counting from 0, the code of that character is
yielded in \pp|c| and \pp|string elem| succeeds; otherwise it fails.

\XX|'action'unstack string+[]st[].|\Y
The last block in the stack \pp|st| (pointed by \pp|>>st|) must be a string
block. This block is removed from \pp|st|. After this operation \pp|>>st|
decreased by the width of the string block.

\XX|'action'pack string+from[]+>n+[]to[].|\Y
The rightmost \pp|n| elements of \pp|from| must be values that correspond to
nonzero unicode codes; \pp|n| must be non-negative. Characters with these
codes are packed into a string block, and the stack \pp|to| is extended with
this block. After \pp|pack string| returns, the new string is pointed by
the actual upper limit \pp|>>to|.

\XX|'action'unpack string+T[]+>p+[]to[].|\Y
The pointer \pp|p| must point to a string block in \pp|T|. The string is
unpacked yielding a sequence of \pp|m| unicode characters, where \pp|m| is
the string length. The stack \pp|to| is extended by the \pp|m| character
codes in left-to-right order.

\XX|'action'copy string+T[]+>p+[]to[].|\Y
The stack \pp|to| is extended by a string block identical to the one pointed
by \pp|p| in the list \pp|T|.

%\X\pp|'question'may be string pointer+text[]+>p>|\Y
%Succeeds if \pp|p| points into \pp|text| and can be interpreted as the
%address of a packed string. Otherwise fails.

\subsection{Files}\label{5.2.5}

An \A{} \g{charfile} or \g{datafile} is associated with a file-system
element by an explicit or implicit call to the \pp|open file| rule, and
detached by a call to \pp|close file|, or when the program terminates. Each
\A{} \g{file} has an associated error variable, and each file operation sets
it. The error code is zero when the operation succeeds, otherwise it is
different from zero and the value indicates the type of the error.

\subsubsection{General}\label{6.4.1}

\XX|'predicate'open file+""f+>mode+T[]+>p.|\Y
Associate the \g{file} \pp|f| with the file-system element specified by the
string pointed to by \pp|p| in the list \pp|T|. The \pp|mode| specifies how
the file should be opened. It is \pp|/r/| for reading, \pp|/w/| for writing,
and \pp|/a/| for appending. Only character files can be opened for
appending. The rule \pp|open file| succeeds when the file was successfully
associated with \pp|f|. If the rule fails, the error code in \pp|f|
indicates the reason.\Y
The special filenames \pp|"<<stdin>>"|, \pp|"<<stdout>>"| and
\pp|"<<stderr>>"| associate the \A{} \g{charfile} \pp|f| with the three standard
streams, typically reading from, and printing to the console. The first can
be opened for reading only, the other two for writing only.

\XX|'predicate'open temp file+""f+[]T[]+>p.|\Y
Associate \pp|f| with a temporary file and open it for
writing. The supplied string must end with six uppercase \pp|X| letters,
and it must be on a stack since the rule replaces these characters with
other ones to make the filename unique.

\XX|'action'close file+""f.|\Y
Detaches the \g{file} \pp|f|, possibly after writing out some buffered data.
When the rule returns \pp|f| is detached, but there might be file-system
errors indicated by a non-zero error code.

\XX|'function'get file error+""f+err>.|\Y
Return the error code of the last operation on \pp|f|. The code is zero if
the operation was successful, otherwise it indicates the error condition.

\XX|'function'get file pos+""f+pos>.|\Y
Retrieve the actual file position in \pp|pos|. The yielded value is correct
only when \pp|f| is opened for reading. The position is maintained
internally, so there is no overhead in determining it. The position at the
beginning of the file is zero.

\XX|'action'set file pos+""f+>pos.|\Y
If the \g{file} \pp|f| is opened for reading, set the position to \pp|pos|.
The next item to be retrieved from \pp|f| is the same as the next item when
position was retrieved by \pp|get file pos|. Setting file position to zero
resets \pp|f| before the first item.

\XX|'action'unlink file+T[]+>p.|\Y
Delete the file specified by the string in \pp|T| pointed by \pp|p|. Check
the error code for success.

\subsubsection{Character input and output}\label{6.4.2}

An \A{} character file is a sequence of unicode characters stored using
UTF-8 encoding. A \g{charfile} returns and accepts unicode characters,
converting these characters to and from UTF-8 encoding on the fly. The
unicode character with zero code is not allowed in an \A{} character file.
Character handling rules require a character file at their \g{formal-file}
affix.

\XX|'constant'new line, rest line.|\Y
The \A{} character with code \pp|new line| marks the end of a line; it is
identified with the \emph{newline} unicode character with code 10. The
\g{constant-tag} \pp|rest line| is reserved for administrative purposes; its
value is not a valid character code.

\XX|'predicate'get char+""f+char>, fgetc+""f+char>.|\Y
These rules are equivalent. 
If the file associated with \pp|f| is not exhausted, the code of the next
unicode character is delivered in \pp|char|, and the file is advanced by one
character. The rule fails if there are no more characters in the file.

\XX|'predicate'ahead char+""f+char>|.\Y
If the file associated with \pp|f| is not exhausted, the code of the next
unicode character is delivered in \pp|char|, but the file is not advanced;
a subsequent call to \pp|ahead char| will deliver the same code. The rule
fails if there are no more characters in the file.

\XX|'predicate'get line+""f+[]st[]+cint>.|\Y
If the file associated with \pp|f| is exhausted, \pp|get line| fails.
Otherwise the next character is read. If it is a newline character, its code
is assigned to \pp|cint| and the character is skipped, otherwise \pp|cint| is
set to \pp|rest line|. Then zero or more characters are read until either
the end of file, or until the next character would be a newline. The
stack \pp|st| is extended with these characters in a left-to-right order.

\XX|'predicate'get int+""f+int>.|\Y
A call of \pp|get int| will read and skip any number of spaces and newline
characters until it finds a digit, plus-sign or minus-sign. If no such
character was found, \pp|get int| fails. Otherwise the rule will read and
collect one or more digits until a non-digit is found: this non-digit is not
read. The optional sign and the digits are considered as a signed decimal
number; the value is delivered in \pp|int|.

\XX|'action'put char+""f+>char, fputc+""f+>char.|\Y
These rules are equivalent. 
The value of \pp|char| must be a positive valid unicode character. 
This character is written to the file associated with \pp|f|.

\XX|'action'put line+""f+T[]+>cint.|\Y
The list \pp|T| must only contain positive unicode values. These
characters are written, in a left-to-right order, to the file associated
with \pp|f|. If \pp|cint| is not \pp|rest line|, this character is appended
at the end.

\XX|'action'put int+""f+>int.|\Y
Exactly \pp|intsize+1| characters are written to \pp|f|. These characters
are: zero or more spaces, the minus sign if \pp|int| is negative, followed
by the characters of the decimal representation of the absolute
value of \pp|int|.

\XX|'action'put string+""f+T[]+>p, fprint string+""f+T[]+>p.|\Y
These rules are equivalent.
The pointer \pp|p| must point into a string block in the list \pp|T|.
Characters of this string are written to the file associated with \pp|f|.

\XX|'action'fprintf+""f+t[]+@+>p.|\Y
This rule provides a rudimentary formatted printing. The first two affixes 
after the \g{file} \pp|f| specify a \emph{format string}. Characters in this
string
are written to \pp|f|, except for the following format character pairs, which
specify how the additional \g{in-affix}\/es of the rule will be written.
\begin{center}\begin{tabular}{cl}
  format & the next affix is written as\\[2pt]
   \pp|\%c| & character, \\
   \pp|\%d| & decimal integer without leading spaces,\\
   \pp|\%x| & hexadecimal, \\
   \pp|\%n| & newline (no affix is consumed).
\end{tabular}\end{center}

\subsubsection{Standard input and output}

The following rules communicate directly with standard input and output.

\XX|'charfile'STDIN, STDOUT.|\Y
These character files are associated with the character streams
\emph{standard input} and \emph{standard output}. Characters sent to
\pp|STDOUT| typically appear on the console; characters read from \pp|STDIN|
are the ones entered at the console. \pp|STDIN| is line-buffered.

\XX|'predicate'getc+char>.|\Y
Get the next character from \pp|STDIN|.

\XX|'action'putc+>char, print char+>char.|\Y
Both rules send the character \pp|char| to \pp|STDOUT|.

\XX|'action'print int+>n, print string+T[]+>p, printf+t[]+@+>p.|\Y
Corresponding to \pp|put int|, \pp|put string|, and \pp|fprintf|.
These rules write to \pp|STDOUT| an integer, a string, and formatted
output, respectively.


\subsubsection{Data input and output}\label{6.4.3}

\XX|'constant'numerical, pointer.|\Y
These constants are predefined values that can be used as type indications
in \g{datafiles}. For their usage see \Ref{Section 4.2.2}.

\XX|'predicate'get data+""file+data>+type>.|\Y
The file \pp|file| must be a datafile. If the file is not exhausted, the
next data item is read, its value delivered in \pp|data| and its type in
\pp|type|. When the rule fails the error variable associated with \pp|file|
gives information about the reason.

\XX|'action'put data+""file+>data+>type.|\Y
The file \pp|file| must be a datafile. A data item is written to the file,
consisting of the value \pp|data| and the type \pp|type|. For a more
detailed description see \Ref{Section 4.2.2}. When the request cannot be
executed (possible reasons are: the file-system is full; \pp|file| was 
not opened and cannot be opened automatically; a pointer data is 
not covered in the \g{file-area}), the program run is terminated.

\XX|'predicate'put datap+""file+>data+>type.|\Y
Performs the same action as \pp|put data|, but in case of an error
fails and sets the error variable associated with \pp|file|.

\subsection{Miscellaneous}\label{6.4.4}

\XX|'question'shift affix block+@.|\Y
The actually visible repeat affix block is shifted out, and the next block is
moved into its place, assuming that there is still a pending, unseen block.
If there is no more blocks, the rule fails. This rule cannot be redefined.

\XX|'function'get affix blockno+n>+@.|\Y
The number of pending, unseen affix blocks is yielded in \pp|n|. This number is
always positive, and it is 1 if and only if \pp|shift affix block| would
fail. This rule cannot be redefined.

\XX|'exit'exit+>code.|\Y
This is the only Standard Library rule which is guaranteed not to return.
The call of this rule closes all open files and terminates the program run
with the specified \pp|code|.

\XX|'table'STDARG.|\Y
The table \pp|STDARG| contains, in reverse order, the command-line arguments
as string blocks. Consequently, the upper limit \pp|>>STDARG| of the table
points to the first argument. The following \g{compound-member} walks
through the arguments in their original order, and calls \pp|cmdarg| with
each of them:

\begin{program}
  (-ptr: >>STDARG->ptr, (nxt:ptr< <<STDARG;
           cmdarg+STDARG+ptr,previous string+STDARG+ptr,:nxt))
\end{program}


\XX|'action'msleep+>ms.|\Y
This rule sleeps for the specified amount of milliseconds before returning.
As this rule clearly makes no ``global changes'', it would be tempting to
declare it as a \pp|'function'|. In that case, however, the compiler would
complain that a function without \g{out} or \g{inout} formal affixes is a
no-op and can be discarded.

\XX|'action'backtrack.|\Y
If the \A{} program is linked with the \pp|-g| flag, additional code is
added which maintains the \emph{call stack}, the list of embedded rule calls
starting from the \g{root} of the main program and ending at the
\g{actual-rule} which is currently executed. In this case a call of the rule
\pp|backtrack| provides a printout of the rule names in this stack. If the
program was not linked with the \pp|-g| flag, this rule does nothing and 
returns immediately.

\XX|'action'wait for+T[]+>p.|\Y
The pointer \pp|p| must point to a string in the table \pp|T|. The rule
checks if there is a linked module with the specified name (as defined by
the \pp|module=.\!.\!.| \g{pragmat}) whose \g{root} has not been executed
yet. If yes, it calls those \g{root}\/s and returns after all is finished;
otherwise it returns immediately. The rule \pp|wait for| aborts the program run
if two module \g{root}\/s would wait for each other producing a deadlock.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Program representation}\label{sec:7}

%\subsection{The program layout}\label{7.1}

The program, produced by the notion \g{program}, consists of a series of
terminals. Terminal notions fall into the following categories:
\begin{itemize}
\item[a)] \g{symbol}\/s,
\item[b)] \g{tag}\/s (identifiers),
\item[c)] \g{denotation}\/s.
\end{itemize}
An \A{} program is a textual representation of the sequence of terminals
sprinkled with \emph{comments} and \emph{formatting}. \A{} has quite liberal
formatting rules. Any number of white spaces (tabs, space and newline
characters) are allowed before and after any terminal notion; spaces and
tabular characters (but no newlines) are allowed (and ignored) inside
identifiers, decimal, and hexadecimal constants. Thus
\begin{itemize}\item
\pp|new\char32 line|, \pp|newline|, and \pp|ne\char32 wli\char32 ne|
\end{itemize}
represent the same \g{tag}. Similarly, 
\begin{itemize}\item
\pp|1\char32 000\char32 000| 
\end{itemize}
is a legal representation of the
number one million. There can be no space, however, in the head \pp|0x| of a
hexadecimal constant (since it is the representation of the \g{hex-symbol}
which is required to appear exactly), while there can be spaces after it and
between the hexadecimal digits, such as \pp|0x\char32 ff\char32 e8|.

Any number of \emph{long comments} can be added before and after a terminal
notion. A long comment starts with a dollar-sign \pp|$\no$|, and ends at the
next dollar sign or at the end of the line, whichever comes first. A short
comment consists of a sharp-sign \pp|\#| followed by spaces, letters and
digits so that it contains at least one non-space character. Short comments
can be inserted before another comment or before a terminal notion, assuming
either that the short comment ends with a newline, or the representation of
the subsequent terminal does not start with a letter or digit.

\subsection{Symbols}\label{7.2}

The character representation of terminals ending with \g{-symbol} is either
a single character, such as the obvious representations of \g{point-symbol}
or \g{colon-symbol}; two consecutive characters, such as the representation
\pp|->| of the \g{arrow-symbol}; or a ``bold word'' written between
apostrophes such as the representation \pp|'end'| of the \g{end-symbol}.
When more than one representation is listed, any of them can be used with
the same meaning. If the symbol has multi-character representation, no
additional characters are allowed between the listed characters. For
example, \pp|0x| is the representation of the \g{hex-symbol} which indicates
a hexadecimal number, while \pp|0\char32 x| is a digit zero followed by the
letter \pp|x|.

\medskip

\begin{keywords}
\K{symbol} representation	\\[3pt]
\G{absolute}		\pp|/|		\\
\G{action}		\pp|'action'| or \pp|'act'| or \pp|'a'|	\\
\G{actual-affix}	\pp|+|		\\
\G{alwb}		\pp|<<|		\\
\G{anchor}		\pp|@| (at sign)	\\
\G{and}			\pp|\&| (ampersand)	\\
\G{arrow}		\pp|->|		\\
\G{aupb}		\pp|>>|		\\[3pt]
\G{box}			\pp|=|		\\
\G{bus}			\pp|]|          \\
\G{by}			\pp|/|		\\[3pt]
\G{calibre}		\pp|<>|		\\
\G{charfile}		\pp|'charfile'|	\\
\G{close}		\pp|)|		\\
\G{colon}		\pp|:|		\\
\G{comma}		\pp|,|		\\
\G{complement}		\pp|~| (tilde)	\\
\G{constant}		\pp|'constant'| or \pp|'cons'| \\[3pt]
\G{datafile}		\pp|'datafile'|	\\
\G{dummy}               \pp|\#| or \pp|?|   \\[3pt]
\G{end}			\pp|'end'|	\\
\G{eq}			\pp|=|		\\
\G{equals}		\pp|=|		\\
\G{exit}		\pp|'exit'| or \pp|'e'|	\\
\G{external}		\pp|'external'| or \pp|'x'|	\\[3pt]
\G{failure}		\pp|-|		\\
\G{formal-affix}	\pp|+|		\\
\G{function}		\pp|'function'| or \pp|'fct'| or \pp|'f'| \\[3pt]
\G{ge}			\pp|>=|		\\
\G{gt}			\pp|>|		\\
\G{hex}			\pp|0x|		\\
\G{le}			\pp|<=|		\\
\G{left}		\pp|<|		\\
\G{left-of}		\pp|(*|		\\
\G{local-affix}		\pp|-|		\\
\G{lt}			\pp|<|		\\[3pt]
\G{minus}		\pp|-|		\\
\G{ne}			\pp|!=|		\\[3pt]
\G{of}			\pp|*|		\\
\G{open}		\pp|(|		\\
\G{or}			\pp|\char"7C| (pipe)	\\[3pt]
\G{plus}		\pp|+|		\\
\G{point}		\pp|.|		\\
\G{pragmat}		\pp|'pragmat'|	\\
\G{predicate}		\pp|'predicate'| or \pp|'pred'| or \pp|'p'| \\[3pt]
\G{qualifier}		\pp|\cc|	\\
\G{question}		\pp|'question'| or \pp|'qu'| or \pp|'q'| \\
\G{quote}		\pp|"|		\\
\G{quote-image}		\pp|""|		\\[3pt]
\G{repeat}		\pp|:|		\\
\G{right}		\pp|>|		\\
\G{right-of}		\pp|*)|		\\
\G{root}		\pp|'root'|	\\[3pt]
\G{semicolon}		\pp|;|		\\
\G{stack}		\pp|'stack'|	\\
\G{static}		\pp|'static'|	\\
\G{sub}			\pp|[|          \\
\G{success}		\pp|+|		\\[3pt]
\G{table}		\pp|'table'|	\\
\G{times}		\pp|*|		\\[3pt]
\G{up-to}		\pp|:|		\\
\G{variable}		\pp|'variable'| or \pp|'var'|\\
\G{vlwb}		\pp|<|		\\
\G{vupb}		\pp|>|		\\
\G{xor}			\pp|\char"5E| (caret)	\\
\end{keywords}



\subsection{Tags}\label{repr:tags}

Identifiers in \A{} are non-empty sequences of digits and latin letters
starting with a lower or upper case letter. Inside identifiers spaces and
tab characters (but not newlines) are allowed and ignored. A
\emph{qualifier} is an identifier followed by the \g{qualifier-symbol}; a
\emph{qualified identifier} is an identifier preceded by a qualifier. The
representation of a local \g{tag} (that is, formal and local affixes and
labels) is an identifier; the representation of a global \g{tag} is either
an identifier, or a qualified identifier. Global \g{tag}\/s without explicit
qualifiers have an implicit one. The implicit qualifier is the name of the
module where the \g{tag} is defined, or it is empty (with no corresponding
explicit qualifier) when the \g{tag} is defined in the main program. 

\subsection{Denotations}\label{repr:denotations}

Denotations specify a value which is determined during compilation. A
denotation is either explicit, such as a sequence of decimal digits
determining an integral constant, or implicit when the value is supplied by
the compiler depending on the exact location of the denotation. Syntax:

\begin{grammar}
\item denotation:

   integral-denotation; character-denotation; string-denotation.

\item integral-denotation:

   [minus-symbol], digit\plus;

   [minus-symbol], hex-symbol, hex-digit\plus;

   manifest-integral.

\item character-denotation:
   absolute-symbol, visible-character, absolute-symbol.

\item string-denotation:

   quote-symbol, string-elem\ast, quote-symbol.

   manifest-string.

\item string-elem:

   non-quote-character; quote-image-symbol.
\end{grammar}
\noindent
Example of \g{integral-}, \g{character-} and \g{string-denotation}\/s:
\begin{program}
-0xffef, /t/, """quoted string""", \_file\_,
\end{program}
\noindent
the last one is a \g{manifest-string}. The implemented manifest
constants and strings are the following.

\smallskip

\begin{tabular}{lp{0.74\textwidth}}
\pp|\_line\_| & integral, the source line number this constant appears,\\
\pp|\_file\_| & string, the name of the source file,\\
\pp|\_module\_| &  string, module name as set by the \pp|module=.\!.\!.|
\g{pragmat}, \\
\pp|\_title\_| & string, the title as set by the \pp|title=".\!.\!."|
\g{pragmat}, \\
\pp|\_rule\_| & string, the rule name (without the qualifier) if used 
inside an \g{actual-rule}.
\end{tabular}


\smallskip\noindent 
Only the listed characters and no spaces are allowed between the underscore
characters. The string returned by \pp|\_module\_| and \pp|\_title\_| is the
empty string before encountering the \pp|module| or the \pp|title| pragmats.
The manifest string \pp|\_rule\_| similarly returns the empty string if used outside
an \g{actual-rule}.

\smallskip

Integral denotations use decimal and hexadecimal digits. Decimal \g{digit}\/s
are the characters from \pp|0| to \pp|9|; \g{hex-digit}\/s contain,
additionally, both the lower case letters from \pp|a| to \pp|f| and the
upper case letters from \pp|A| to \pp|F|. The value of an
\g{integral-denotation} is the decimal or hexadecimal value of the sequence,
negated if the \g{minus-symbol} precedes it. Spaces and tabular characters
are allowed (and ignored) between the digits and also after the
\g{minus-symbol}, but no spaces are allowed between \pp|0| and \pp|x| in
\pp|0x| marking a hexadecimal number, as it is the representation of the
\g{hex-symbol}.

\smallskip

A \g{visible-character} is any unicode character which occupies a single
character position. It includes the space character, but excludes the
newline, tabular, and other control characters. The \g{character-denotation}
provides the code of the character between the two \g{absolute-symbol}\/s
\pp|/|.

\smallskip

A \g{non-quote-character} is a \g{visible-character} different from the
quote mark \pp|"|. A proper string is a (possibly empty) sequence of
\g{non-quote-character}\/s and \g{quote-image-symbol}\/s (the
latter is two consecutive quote marks) enclosed in quote marks. There is no
escape character in \A{}, therefore the newline character (and other control
characters) cannot occur in a \g{string-denotation}.

\A{} allows strings between \g{quote-symbol}\/s to be split into shorter ones. 
Consecutive strings enclosed in \g{quote-symbol}\/s and
separated by white spaces (even if they are in different lines) are
concatenated. Strings to be concatenated must be properly separated since
inside a string two consecutive quote marks denote a single quote mark. Thus
\medskip

\begin{tabular}{lp{0.78\textwidth}}
\pp|"a" "b"| 
&is concatenated resulting in the two-character string \pp|"ab"|\,, while
\\[2pt]
\pp|"a""b"|
& is a single string with three characters: \pp|a|
\pp|"| and \pp|b|\,.
\end{tabular} 





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Examples}\label{sec:8}

\subsection{Towers of Hanoi}\label{8.1}
\begin{program}\input{ex1.ale}\end{program}


\subsection{Printing Towers of Hanoi}\label{8.2}
\begin{program}\input{ex2.ale}\end{program}

\subsection{Symbolic differentiation}\label{8.3}
\begin{program}\input{ex3.ale}\end{program}

\subsection{Quicksort}\label{8.4}
\noindent
Module:
\begin{program}\input{ex4.ale}\end{program}

\noindent
Main program:
\begin{program}\input{ex4a.ale}\end{program}

\subsection{Permutations}\label{8.5}
Module:
\begin{program}\input{ex6.ale}\end{program}

\noindent
Main program:
\begin{program}\input{ex6a.ale}\end{program}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{References in the manual}
\begin{thebibliography}{9}
%\bibitem{bohm77}
%A.~P.~W.~B\"ohm, 
%ALICE: An Exercise in Program Portability,
%IW 91/77, \emph{Mathematical Centre}, Amsterdam, 1977

\bibitem{alephcomp}
L.~Csirmaz, \emph{Aleph Compiler, v2.4},
available at \hfill\allowbreak{\tt https:/\!/lcsirmaz.github.io\allowbreak/aleph/\allowbreak alephcomp.html}

\bibitem{manual}
D.~Grune, R.~Bosch, L.~G.~L.~T~ Meertens.
\emph{Aleph Manual} in:
D.~Grune, R.~Bosh: \emph{On the design of ALEPH}, 
\emph{Mathematical Centre}, Amsterdam, 1986

%\bibitem{GGV78}
%R.~Glandorf, D.~Grune, J.~Verhagen,
%A W-grammar of \A, IW 100/78, \emph{Mathematical Centre}, Amsterdam, 1978

%\bibitem{koster71a}
%C.~H.~A.~Koster, 
%A Compiler Compiler, 
%MR 127/71, \emph{Mathematical Centre},
%Amsterdam (1971)

\bibitem{koster71b}
C.~H.~A.~Koster, 
Affix-grammars, in: \emph{ALGOL 68 implementation}, ed.
J.~E.~L.~Peck, North-Holland Publ. Co., Amsterdam (1971)

\bibitem{watt77}
D.~A.~Watt,
The parsing problem for affix grammars,
\emph{Acta Inf.} {\bf 8}, pp 1--20, 1977

%\bibitem{wichmann77}
%B.~A.~Wichmann,
%How to call procedures, or second thoughts on Ackermann's function,
%\emph{Software -- Practica \& Experience}, {\bf 7} pp 317--329 (1977)

\end{thebibliography}

\end{document}


\ignore
\subsubsection{Use of tags}\label{3.1.2}

A \g{tag} is a sequence of letter and digits, the first of which is a
letter. Symbols in a tag can be separated by spaces and tabular characters. 
These white spaces inside the tag are ignored, and two sequences differing
only in white spaces denote the same \g{tag}. A \g{tag}, however, cannot
spread over multiple lines. Thus
\begin{program}
long name
l o ngn a m e
  l o n g n a m e
\end{program}
\noindent
all denote the same \g{tag}, while
\begin{program}
long
name
\end{program}
\noindent
denotes two consecutive \g{tag}\/s (which cannot occur in a syntactically
correct \A{} program).

All \g{tag}s defined by \g{rule-declaration}s, \g{pointer-initialization}s,
\g{constant-description}s, \g{variable-description}s,
\g{table-head}s, \g{stack-heads} (except for those in
\g{field-list-definition}\/s), \g{stack-head}s
\g{file-description}s,
\g{external-rule-description}s
and \g{external-constant-description}s must differ from each
other.

\endignore

\ignore
Example: Suppose the following \g{rule}\/s are defined:
\begin{program}
'question'if a: $ some question $.
'question'if b: $ another question $.
'function'give value1+n>: 1->n.
'function'give value2+n>: 2->n.
'action'use value+>n: print+n.
'action'print+>n:
    $ some actual rule that prints the value of n $.
\end{program}
\noindent
In the \g{actual-rule}
\begin{program}
-loc: if a, give value1+loc, use value+loc, print+loc;
      if b, give value2+loc, use value+loc.
\end{program}
\noindent
\pp|loc| is \emph{uninitialized} at the colon and likewise at the first
comma, \emph{initialized} at the second comma because of the restoring done
by the call of \pp|give value1|, and keeps the attribute \emph{initialized}
until the end of the \g{alternative}. Its value can be copied over to
\pp|use value| and \pp|print|. At the beginning of the second alternative it
is still has the attribute \emph{uninitialized} (still \emph{uninitialized},
not again, since, if the beginning of the second \g{alternative} is reached,
the initialization in the previous \g{alternative} will not have taken
place). It keeps the attribute \emph{uninitialized} until the call of
\pp|give value2| after (and by) which it obtains the attribute
\emph{initialized}. Its subsequent application in \pp|use value| is correct.

The \g{actual-rule}
\begin{program}
-loc:if a, use value+loc, give value1+loc, print+loc.
\end{program}
\noindent
is incorrect. \pp|loc| still has the attribute \emph{uninitialized} at the first comma and
is then used as a \g{source} in the copying done by the call of \pp|use value|.
\endignore


\ignore
The \g{formal-affix-sequence} mentioned in point e.~above is constructed as
follows.
\begin{itemize}
\item[a.] A list is made of all tags in the \g{rule-body} that do not refer
to global items and do not occur in the \g{local-affix-sequence} of $C$, if
present.
\item[b.] If the list is empty, the \g{formal-affix-sequence} is empty.
\item[c.] For each tag in the list, if the corresponding item
\begin{itemize}
\item[c1.] is used as a \g{source} (either directly or through the affix
mechanism) and is
used as a \g{destination} (either directly or through the affix mechanism), it
is entered
into the \g{formal-affix-sequence} preceded and followed by a
\g{right-symbol};
\item[c2.] is used as a \g{source} (either directly or through the affix
mechanism), it is
entered into the \g{formal-affix-sequence} preceded by a \g{right-symbol};
\item[c3.] is used as a \g{destination} (either directly or through the affix
mechanism),
it is entered into the \g{formal-affix-sequence} followed by a
\g{right-symbol};
\item[c4.] is used as a \g{stack-tag} (or \g{table-tag}), it is entered into
the \g{formal-affix-sequence} as a
\g{formal-stack} (or \g{formal-table}, respectively) with the same \g{field-list-pack}
as that of the corresponding (formal or actual) stack (or table);
\item[c5.] is used as an \g{actual-affix} where a file is required, it is
entered into the \g{formal-affix-sequence} as a \g{formal-file}.
\end{itemize}
\item[d.] The items in the \g{formal-affix-sequence} are preceded by
\g{formal-affix-symbol}\/s.
\end{itemize}
\endignore 

\ignore
This also implies that, if a \g{compound-member} fails, the changes it made
to formal and local variables do not become effective. Compare
\begin{program}
   0->n,((1->n,-);
         n=0,do something)
\end{program}
\noindent with
\begin{program}
   0->n,(spoil and fail+n;
         n=0,do something)
\end{program}
\noindent where
\begin{program}
   'question'spoil and fail+n>:1->n, -.
\end{program}
\noindent
Both cases behave in exactly the same way: the rule \pp|do something| will
be called.

\smallskip
The \g{rule-tag}, if any, in a \g{compound-member} $C$ must be different
from:
\begin{itemize}
\item[a.] the \g{rule-tag}\/s, if any, and all the \g{variable-tag}\/s in the
\g{local-affix-sequence}\/s, if any, of all the \g{compound-member}\/s, if any, in which
$C$ occurs,
\item[b.] the \g{rule-tag} and all the \g{variable-tag}\/s,
\g{stack-tag}\/s, \g{table-tag}\/s and \g{file-tag}\/s in the 
\g{formal-affix-sequence}, if any, of the \g{rule-declaration} in which $C$ occurs.
\end{itemize}
\endignore

\ignore
\subsection{Criteria for side effects, failing and return}\label{3.9}

This section describes the conditions for side effects, failing and return.

%Where a list of conditions is given in this paragraph, the requirements for
%this list are fulfilled if at least one of the conditions is fulfilled.

\def\HI{\smallskip\noindent\hangindent 10pt}

\subsubsection{Criteria for side effects}\label{3.9.1}
In essence, a rule \emph{has side effects} if it changes some global
information.

\HI
A rule has side effects if its \g{rule-body} has side effects.

\HI
A \g{rule-body} (i.e., an \g{alternative-series} or \g{classification}) has
side effects if it contains at least one \g{member} that has side effects.

\HI
A \g{member} has side effects if at least one of the following conditions
holds:
\begin{itemize}
\item[a)] it is an \g{affix form} that has side effects;
\item[b)] it is a \g{transport} that has side effects;
\item[c)] it is an \g{extension};
\item[d)] it is a \g{compound-member} the \g{rule-body} of which has side
effects.
\end{itemize}

\HI
An \g{affix-form} has side effects if at least one of the following holds:
\begin{itemize}
\item[a)] the rule called is an \emph{action}, a \emph{predicate}, or an
\emph{exit};
\item[b)] the restoring part of the affix mechanism (see \Ref{Section 3.5}) causes a
\g{transport} that has side effects.
\end{itemize}
A \g{transport} has side effects if (one of) its \g{destination}(s) identifies
a global variable or is a \g{stack-element}.

\subsubsection{Criteria for failure}\label{3.9.2}

\HI
A \g{member} can fail if
\begin{itemize}
\item[a)] it is an \g{affix-form} the rule of which is a
\emph{predicate} or a \emph{question},
\item[b)] it is a \g{comparison},
\item[c)] it is a \g{compound-member} the \g{rule-body} of which can fail.
\end{itemize}

\HI
A \g{terminator} can fail if
\begin{itemize}
\item[a)] it is the \g{failure-symbol} \pp|-|; or
\item[b)] it is a \g{jump} to a rule or \g{compound-member} that can fail.
\end{itemize}

\HI
A \g{rule-body} can fail if its \g{alternative-series} or \g{classification}
can fail.

\HI
An \g{alternative-series} can fail if either
\begin{itemize}
\item[a)] the guard of its last \g{alternative} can fail; or
\item[b)] it contains an \g{alternative} that contains a
\g{member} or a \g{terminator}, other than its guard, that can fail.
\end{itemize}

\subsubsection{Criteria for return}\label{3.9.3}

\HI
A \g{member} cannot return if it is an \g{affix-form} the rule of 
which is an \emph{exit}.

\HI
A \g{terminator} cannot return if it is a \g{jump} or it is the
\g{failure-symbol} \pp|-|.

\HI
An \g{alternative} cannot return if its \g{last-member} cannot return.

\HI
An \g{alternative-series} or a \g{classification} cannot return 
if none of its \g{alternative}\/s can return.

\HI
A \g{rule-body} cannot return if the

\endignore

\ignore


A \emph{stack} is a (possibly empty) sequential list of locations that
contain integral values. The structure of this list and its addressing
scheme is parallel to that of a table. The initial values in the locations
are determined by the \g{filling-list-pack} is a way analogous to that used
for tables. the \pp|max limit| is equal to the address of the right-most
location, the \pp|min limit| is equal to the address of the left-most
location minus one plus the \pp|calibre| of the stack. Again these values
are chosen by the compiles and are unique to the given stack.

The value of the \g{expression} in the \g{size-estimate} must not depend,
directly or indirectly, on the value of any \g{constant-tag} defined in a
\g{pointer-initialization}.

The values in the locations in a stack can be altered by transporting
(\Ref{Section 3.4}) a value into an element of that stack. For ways of changing
the size of the stack see \Ref{Section 4.1.4}.

A \g{stack-tag} can be used in a \g{stack-element}, a \g{limit} or an
\g{extension}, or as an \g{actual} in an \g{affix-form}, or to designate a
\g{zone} in a \g{classification} or \g{file-description}.



Examples:
\begin{program}
'table'messages =
   ("tag undefined": bad tag,
    "wrong number of parameters": wrong  parameters,
    "quote "" where not allowed": bad quote).
\smallskip
'table'hexadec=
   (/0/,/1/,/2/,/3/,/4/,/5/,/6/,/7/,
    /8/,/9/,/a/,/b/,/c/,/d/,/e/,/f/).
\smallskip
'table'(wind,next)four winds=
   ((north wind,east): north,
    (east wind,south): east,
    (south wind,west): south,
    (west wind,north): west).
\end{program}

\subsubsubsection{The table head}\label{4.1.5.1}
A \emph{table} is a sequential list of integral values. For referencing
purposes these values are numbered sequentially. The numbers which can be
used as addresses are chosen by the compiler and are unique for the given
table, i.e., no two integral values in tables have the same address. The
right-most item in the table has the largest address, which is known as the
\pp|max limit| of the table. The left-most item has the smallest address,
the smallest address minus one plus the calibre is known as the \pp|min
limit| of the table. Consequently the number of values in the table is
\pp|max limit - min limit + calibre|.

If the \g{field-list-pack} is missing, a \g{field-list-pack} of the form
\begin{grammar}
\item open symbol, table tag, close symbol
\end{grammar}
where \g{table-tag} is the same is that of the \g{table-head}, is supposed to be present.
For example, \pp|'table' messages| means \pp|'table'(messages)messages|.

\subsubsubsection{The field list pack and the filling list}\label{4.1.5.2}

The following applies to tables and stacks alike.

\smallskip

All \g{tag}\/s in a \g{field list pack} must differ one from another.

The \pp|calibre| $C$ of a list is the number of \g{field}\/s in the
\g{field-list-pack}. The list is considered to be subdivided into blocks of length
$C$; this implies that \pp|max limit - min limit| is an integral multiple of
$C$. The address of the right-most item in a block is considered the address
of that block. Each value in a block can be referenced through a
\g{selector}: the \g{field}\/s in the \g{field-list-pack} correspond, in that
order, to the values in the block. A \g{field} is indicated by one of its
\g{selector}\/s.

\medskip\noindent
Example 1:
The \g{table-declaration} for \pp|for winds| (example 3 above) gives rise to
the following list:
\begin{center}%
\def\K#1{\hbox to 6em{\tt~~#1\hss}}%
\def\L#1{\hbox to 4.5em{\tt~~#1\hss}}%
\begin{tabular}{ccc}
address & selector & value \\[2pt]
          & \tt wind & \K{north wind}\\[-1pt]
\L{north} & \tt next & \K{east}       \\
          & \tt wind & \K{east  wind} \\[-1pt]
\L{east}  & \tt next & \K{south}      \\
          & \tt wind & \K{south wind} \\[-1pt]
\L{south} & \tt next & \K{west}       \\
          & \tt wind & \K{west wind}  \\[-1pt]
\L{west}  & \tt next & \K{north}     
\end{tabular}
\end{center}
and \pp|wind*four winds[next*four winds[west]]| has the value \pp|north
wind|.

\medskip\noindent
Example 2: the \g{table-declaration}
\begin{program}
'table'strings=("abcdefg":letters, "01234":digits)
\end{program}
\noindent
could in some version on some computer generate:
\begin{center}%
\def\K#1{\hbox to 6em{\tt~~#1\hss}}%
\def\ditto{\raisebox{-1pt}{\tt "}}%
\begin{tabular}{ccc}
address & selector & value \\[2pt]
          & \tt strings &\K{13 14 15 16}\\[-1pt]
          & \ditto      &\K{17 20 21 00}\\[-1pt]
\K{letters}& \ditto     &\K{00 07 00 02}\\
          & \ditto      &\K{01 02 03 04} \\[-1pt]
          & \ditto      &\K{05 00 00 00} \\[-1pt]
\K{digits}& \ditto      &\K{00 05 00 02}
\end{tabular}
\end{center}

A \g{table-tag} can be used in a \g{table-element} or a \g{limit}, or as an
\g{actual} in an \g{affix-form}, or to indicate a \g{zone} in a
\g{classification} or \g{file-description}.

\endignore



Examples for \emph{manifest constants} and \emph{manifest strings} are
\pp|\_line\_|, \pp|\_file\_|, etc. They denote either an integer or a string
supplied by the compiler; the concrete value depends on where they appear in
the program text. Manifest constants, strings, and their values are listed
in Section \ref{7.3}.

A \emph{visible character} is any unicode character which occupies a single
character position. It includes the space character, but excludes the
newline and tabular (and other control) characters. A
\g{character-denotation} requires such a single visible character between
two \g{absolute-symbol}\/s (\pp|/| characters), and provides the code of
that character as an integer.

Aa \A{} string is a sequence of \g{non-quote-character}\/s and
\g{quote-image-symbol}\/s (the latter is two consecutive quote marks) enclosed
in quote marks. These \g{non-quote-character}\/s are just the visible
characters except for the quote mark. Since in \A{} there is no escape
character, the newline and other control characters cannot occur in an \A{}
string.

Next to the \emph{decimal digits}, which are the characters from \pp|0| to
\pp|9|, both the lower case letters from \pp|a| to \pp|f|, and the upper
case letters from \pp|A| to \pp|F| are accepted as additional
\emph{hexadecimal digits}.

The formatting rules in \A{} are quite liberal. Any number of white spaces
(space characters, tabs, new lines) are allowed before and after any
terminal notion; spaces and tabular characters (but no newlines) are allowed
(and ignored) inside identifiers, decimal, and hexadecimal constants. Thus
\pp|new line|, \pp|newline|, and \pp|ne wli ne| represent the same \g{tag}.
Similarly, \pp|1 000 000| is a legal representation of the number one
million. There can be no space, however, in the head \pp|0x| of a
hexadecimal constant (since it is the representation of the \g{hex-symbol}
which is requiredto appear exactly), while there can be spaces after it and
between the hexadecimal digits, such as \pp|0x ff e8|.

Comments can be inserted as well before and after any terminal symbol. A
long comment starts with a dollar sign \pp|\$| and ends either at the next
dollar sign or at the end of the line, whichever comes sooner. A short
comment starts with a sharp sign \pp|\#|, followed by letters, digits and
spaces only, but a short comment must have at least one letter or digit.
Naturally, a short comment cannot be followed by a \g{tag}, or a decimal or
hexadecimal constant in the same line.

Additional formatting rule allows long strings to be split into shorter
ones. Consecutive string separated by white spaces (even if they are in
different lines) are concatenated. Strings to be concatenated must be
properly separated since in an \A{} string two consecutive quote marks,
a \g{quote-image}, denotes a single quote mark. Thus


\ignore
at the notion \g{program}, with additional formatting rules, including
instructions about how to insert comments and how to split the text into
several

together with additional formatting, including 
sprinkled with 

The abstract program produced by the \A{} grammar is a sequence of
\emph{terminals}, that is, grammatical notions in the followiong categories:

A syntactically correct \A{} \emph{compilation unit} is a character representation of the
A \emph{syntactically correct} \g{program} is a character representation of
the terminal sequence with additional formatting rules, including
instructions about how to insert comments and how to split the program text
into several files.

Identifiers in \A{} start with a lower- or uppercase latin letter, and
contain letters and digits only. A \emph{qualified} identifier is a
\emph{qualifier}, followed by a \g{qualifier-symbol}, followed by an
identifier. An example is \pp|q\cc id|, where the qualifier is \pp|q|.
Terminals ending with \g{-tag} produce such identifiers, while providing
additional contextual information about what kind of \g{tag}\/s are allowed
at that place.

A character denotation is a \emph{visible} character between two
\g{absolute-symbol}\/s; and example is \pp|/\#/|. An integral denotation is a
decimal number with an optional minus sign, or it is a hexadecimal number
preceded by \pp|0x| (the representation of the \g{hex-symbol}). Strings are
enclosed between quote marks, cannot contain newline characters, and
quote marks inside a string must be doubled.

\A{} formatting rules are quite liberal. Any number of space characters,
tabs, and new lines are allowed before and after a terminal symbol; spaces
and tabular characters (but no newlines) are allowed (and ignored) inside
identifiers, decimal, and hexadecimal constants. Thus \pp|new\char32 line|,
\pp|newline|, and \pp|ne\char32 wli\char32 ne| represent the same \g{tag}.

Comments, which are not part of the grammar, can appear before and after any
terminal symbol, but not inside a \g{tag} or a \g{denotation}. A comment
starts with a dollar sign \pp|\$| and ends either at the next dollar sign or
at the end of the line, whichever comes sooner.

 A short
comment starts with a sharp sign \pp|\#|, followed by letters, digits and
spaces only, but a short comment must have at least one letter or digit.
Naturally, a short comment cannot be followed by a \g{tag}, or a decimal or
hexadecimal constant in the same line.
\endignore

