\documentclass{article}
\newcommand\A{{\sf ALEPH}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% grammar is typeset in \sf font.
%% the {grammar} environment uses lines with \tem
% add extra sapce around []
{\catcode`\[=\active\catcode`\]=\active%
\gdef\mkoptions{\catcode`\[\active\def[{\kern0.05em\char91\kern0.12em\relax}%
\catcode`\]\active\def]{\kern0.1em\char93\kern0.05em\relax}%
}}%
\newcommand\g[1]{{\sf #1}}
\newcommand\no[1]{}

\newenvironment{grammar}{%
\begin{list}{}{%
\setlength\leftmargin{18pt}%
\setlength\rightmargin{-5pt}%
\setlength\listparindent{20pt}%
\setlength\itemsep{1pt plus0.2ex}%
\setlength\parsep{0pt plus 2pt}%
\setlength\labelsep{-5pt}%
}\sf\mkoptions%
}{\end{list}}
\renewenvironment{itemize}{\begin{list}{}{%
\advance\leftmargin by -8pt%
\setlength\itemsep{0ex plus 0.2ex}%
\setlength\partopsep{3pt}%
\setlength\topsep{2pt plus 2pt}%
\setlength\parsep{0pt plus 2pt}%
}}{\end{list}}
\newenvironment{witemize}{\begin{list}{}{%
\advance\leftmargin by 16pt%
\setlength\itemsep{0ex plus 0.2ex}%
\setlength\partopsep{3pt}%
\setlength\topsep{2pt plus 2pt}%
\setlength\parsep{0pt plus 2pt}%
}}{\end{list}}
\def\square{\raisebox{0.7ex}{\setlength\fboxsep{2pt}\framebox[4pt]{}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% bibliography is a subsection, demoving the section head
\makeatletter
\renewenvironment{thebibliography}[1]
     {\list{\@biblabel{\@arabic\c@enumiv}}%
           {\settowidth\labelwidth{\@biblabel{#1}}%
            \leftmargin\labelwidth
            \advance\leftmargin\labelsep
            \@openbib@code
            \usecounter{enumiv}%
            \let\p@enumiv\@empty
            \renewcommand\theenumiv{\@arabic\c@enumiv}}%
      \sloppy
      \clubpenalty4000
      \@clubpenalty \clubpenalty
      \widowpenalty4000%
      \sfcode`\.\@m}
     {\def\@noitemerr
       {\@latex@warning{Empty `thebibliography' environment}}%
      \endlist}
\renewcommand\labelenumi{\theenumi)}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% program listing is done using lmtt fixed font
%%   words within '' are typeset in bold
%%   disabling '' and ,, and << >> ligatures.
\DeclareFixedFont{\tt}{T1}{lmtt}{m}{n}{10pt}
\DeclareFixedFont{\tft}{T1}{lmtt}{m}{n}{8pt}
\DeclareFixedFont{\bt}{T1}{lmtt}{b}{n}{10pt}
%% \mkbold sets space, comma, apostrophy active
%%   and defined words between '' to be typeset in bold
%% \pp|text| is an inline program
%% \begin{program} ... \end{program} is a displayed program
{\catcode`\'=\active\catcode`\ =\active\catcode`\,=\active%
\catcode`\$=12\catcode`\<\active\catcode`\>\active%
\gdef\mkbold{\catcode`\'\active\def'##1'{\char39\relax{\bt##1}\char39\relax}%
\catcode`\,\active\def,{\char44\relax}%
\catcode`\<\active\def<{\char60\relax}%
\catcode`\>\active\def>{\char62\relax}%
\catcode`\$=12\catcode`\#=12\catcode`\^=12%
\catcode`\ \active\def {\nobreakspace}}}
\newenvironment{program}{%
\ignorespaces
\par\vskip 2pt plus 2pt minus 2pt
\leftmargin=20pt
\parindent=0pt\tt
\catcode`\$=12\catcode`\^=12
\mkbold
\obeylines
\leftskip 8pt
\baselineskip=0.9\baselineskip
\everypar\expandafter{\the\everypar\unpenalty}%
}{\vskip 2pt plus 2pt minus 1pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\catcode`\'=\active\catcode`\ =\active\catcode`\,=\active%
\catcode`\$=12\catcode`\^=12\catcode`\|=\active\catcode`\<\active\catcode`\>\active%
\gdef\pp#1{\relax\begingroup
\catcode`\$=12\catcode`\~=12\catcode`\^=12%
\catcode`\|\active\let|\endgroup
\catcode`\ \active\def {\space}%\nobreakspace
\catcode`\'\active\def'##1'{\char39\relax{\bt##1}\char39\relax}%
\catcode`\<\active\def<{\char60\relax}%
\catcode`\>\active\def>{\char62\relax}%
\catcode`\#=12\catcode`\^=12%
\tt
}%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subsubsubsection
\makeatletter
\renewcommand\subsection{%
\@startsection{subsection}{2}{\z@}%
   {-3.25ex\@plus -1ex \@minus -.2ex}% {3.25ex \@plus1ex \@minus.2ex}
   {1ex \@plus .5ex}%             {-1em}
   {\normalfont\normalsize\bfseries}}
\setcounter{secnumdepth}{4}
\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\@arabic\c@subsubsubsection}
\newcommand\subsubsubsectionmark[1]{}
\newcommand\subsubsubsection{%
\@startsection{subsubsubsection}{4}{\z@}%
   {-3.25ex\@plus -1ex \@minus -.2ex}% {3.25ex \@plus1ex \@minus.2ex}
   {1ex \@plus .5ex}%             {-1em}
   {\normalfont\normalsize\bfseries}}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% keywords in two columns (7.2)
\makeatletter
\newenvironment{keywords}{%
\gdef\\{\@ifnextchar[{\@finishline}{\@finishline[0pt]}}%
\gdef\@finishline[##1]{\par\vskip ##1}%
\gdef\G##1{\noindent\rule{30pt}{0pt}\hbox to 0.25\linewidth{\g{ ##1 symbol}\hfil}
   \qquad }%
\gdef\K##1{\noindent\rule{30pt}{0pt}\hbox to 0.25\linewidth{\g{ ##1}\hfil}
   \qquad }%
}{}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{{An \A} Compiler}
\author{L. Csirmaz}
\date{May, 2020}

\begin{document}
\maketitle

\section{Preface}

In the early 1980's computer languages appeared in large numbers. Only a few
of them survived and is in use even today. \A, an acronym for 
``\underline{\sf A} \underline{\sf L}anguage
\underline{\sf E}ncouraging \underline{\sf P}rogram \underline{\sf
H}ierarcy'', almost completely disappeared, and this work is an attempt to
resurrect it.

As a programming language, \A{} has an interesting structure, unusual
parameter passing mechanism, and a limited range of constructs. \A{} compilers
have been constructed for a wide range of computer architectures (which had
a much larger variety at that time than it has today), these compilers
generated efficient and
succinct code (an important requirement those days). Designed by D.~Grune,
R.~Bosch and L.G.L.T.~Meertens in the Mathematisch Centrum, Amsterdam in the
late seventies, it was ``suitable for any problem that suggests top-down
analysis (parsers, search algorithms, combinatorial problems, artificial
intelligence problems, etc)''. It is no wonder, that an early \A{} compiler
has been written in \A{} itself.


\section{Language features}

\A{} has some interesting features which cannot be found in today's
mainstream languages. This section discusses some of them: calling
mechanism, virtual memory, and datafiles.

\subsection{Call-then-store calling mechanism}\label{subsec:calling}

The first, and probably the most prominent distinguished feature of \A{}
is its parameter passing mechanism. Arguments -- called \g{affix}es -- 
of \A{} routines -- called \g{rules} -- fall into two main category:
\emph{incoming} and \emph{outgoing} ones (some of the arguments can be both).
Inside the routine arguments behave like
local variables, and it is the caller's responsible to store the outgoing
parameters' value in their final destination, and it is done only if the
called routine reports success.

This feature handles routines with several return values naturally without
the need of introducing compound structures tailored for each such routine.
If not needed, the caller can discard any of the out values. The basic
example is the \pp|divrem| function with two in and two out arguments: the
first out argument is the result of the integer division, and the second one
is the remainder. This function is typically implemented as a single machine
instruction, leaving the two results in two different registers.

\A's \emph{call then store} calling mechanism automatically controls the
side effects through parameters. When a parameter is passed by reference,
any change in the parameter's value takes effect immediately; and changing
the value of the global variable which has been passed as argument, changes
the parameter's value as well -- sometimes creating a bug impossible to
find. In \A{} a parameter's value changes only when it is changed explicitly;
and that change does not escalate (thus revocable) until the routine
returns.

\subsection{Tractable data flow}\label{subsec:flow}

Data flow in \A{} is quite restricted: a simple case selection -- reminiscent
of LL$(1)$ parsing --, and a jump which is an abbreviation for tail recursion.
No repetitive statements are in \A; iteration is handled by recursion. It means
that the data flow inside a routine is tractable: liveliness and
reachability properties can be checked statically during compilation. 
In particular, an \A{} compiler can check that
\begin{itemize}
\item[$\cdot$] all instructions are reachable;
\item[$\cdot$] the flow can reach a return point;
\item[$\cdot$] when a local variable or parameter is used it has a value assigned to it
 (it is not ``uninitialized'');
\item[$\cdot$] out parameters got values when the routine reaches any of
its return points;
\item[$\cdot$] if a local variable (or parameter) got a value, it is actually used.
\end{itemize}

There are no uninitialized global values in an \A{} program. Variables and
\g{table}s are initialized when they are declared; and a \g{stack} can be 
extended only by supplying values for the extension.

\subsection{\A{} data types}\label{subsec:blocks}

The basic data type in \A{} is \emph{integer}, which is a synonym for the
target machine's \emph{word}. An integer can be considered as a \emph{bit
string} (which has a positive, zero, or negative value), or as a
\emph{pointer} to some location inside a \g{table} or a \g{stack} which,
again, contains an integer (see Section \ref{subsec:virt-mem} how pointers
are handled). Consecutive memory locations in a \g{table} or \g{stack} can
be grouped to a data block, or to a string. Such a group is pointed by its
last (topmost or rightmost) element. Block elements are identified relative
to the block's address by a \g{selector}. Strings, on the other hand, behave
like a black box, and can be manipulated by built-in routines
(\g{external}s) only. This way string elements are not restricted to bytes
(or wide characters), and can contain elements of an arbitrary character set.
This implementation uses the Unicode character set, strings are
stored using utf-8 encoding. (It also means that extracting string
elements is an expensive operation.) Changing the character set (or the
encoding) is completely transparent to the \A{} program.

A \g{stack}, or integer array can be extended by adding a block (specifying
the value of each block element), or by a string (specifying characters in
the string in some way). Composite objects are referred to by pointers to
their last element. There are no special data type for such pointers.

As mentioned above, \A{} has \g{table}s and \g{stack}s as fixed and
extendable array of integer values. For communicating with the outside world
it has \g{charfile}s and \g{datafile}s.

\subsection{Virtual memory}\label{subsec:virt-mem}

\A{} pointers can only refer to elements in \g{table}s and \g{stack}s. The
complete \emph{virtual memory space} -- the allowed range of indices -- is
distributed among the arrays of the program. Virtual limits are fixed
and do not change during the program run, and pointers refer to a list
element using its virtual address. The virtual address space of different lists
are disjoint, thus a pointer uniquely identifies the list it points into.

A \g{stack} does not necessarily occupies completely its virtual space.
Existing locations (which correspond to locations in the machine memory)
form a presumably much smaller continuous subrange, the \emph{actual memory
range}. \g{Stack}s can be extended to the right (upwards) until the end of
its virtual memory part, or until there is enough physical memory available.
They can shrink from the right when their actual upper limit is lowered; the
released virtual memory can be reclaimed again. \g{Stack}s can also shrink
from the left (behaving like queues), but in this case the released virtual
space is lost (for the rest of the program run) and cannot be reclaimed
again.

Virtual addresses refer to list elements (i.e., integers), and not directly
to the memory. It means that to get a pointer to the next (previous) list element,
the given pointer should be increased (decreased) by 1. Using
32 bit word size, the virtual address space is limited to $2^{32}$ words
(not bytes). This implementation assumes 32 bit word size. The
virtual address space consists of the positive integers between $M$ and
$2^{32}-M$ where $M$ is around one million. This has been chosen so that
pointers and small values (e.g., characters) are different; a typical
non-pointer value will not be accepted as a pointer. The actual memory an
\A{} program can access at the same time is around 8 Gbyte.

\subsection{Datafiles}\label{subsec:datafile}

An \A{} programs communicate with the outside world through \emph{files}. 
\A{} distinguishes two file types: character and data. Character files 
accept and read
characters from the used character set; in this version Unicode characters.
Datafiles can be used to communicate between different \A{} programs.
Data files are written and read one item a time, where an item is either an
integer or a pointer. As the programmer does not have direct control over
how virtual addresses are distributed, the datafile should not store the
pointer's value but the \emph{list} the pointer points to and the {\emph 
relative address} of the pointed item in that list. From these information
the pointer can be restored independently of the virtual address
distribution.

In a \g{datafile} declaration all lists must be specified to which this
datafile can have pointers. By storing the lists in the datafile first, 
each additional item
requires a single extra bit only, which tells whether this item is a
pointer or not. When opening an \A{} datafile, stored lists are be paired
with the specified ones so that the appropriate pointer transformation could
be made. How the pairing should be done is not specified by \A{} Manual. One
possibility is match them by position, another one is match them by name.
This implementation uses the second possibility. Actually, not the list
name, but a 32 bit hash value of the name is stored in the file. When
opening a datafile, each specified list is matched to the one with the same
hash. It is an error if a pointer in the file has no matching list.

\section{Syntax}

The \A{} programming language is defined in \emph{Manual} which has been
published several times by the Mathematisch Centrum, Amsterdam, from 1974
until 1982. Implementations of any computer language frequently add new
features, restrict or left out others. This happened with \A{} as well;
these changes are also reflected in the different printings of the Manual.
The \A{} language implemented -- and used -- by the present compiler is no
exception. To enable modular programming -- as opposed to the monolith
program idea at the time of the creation of \A{} -- required some new
features. Other extensions and restrictions come up naturally; some of them
date back to the time of the first \A{} compilers in the early 80's. Changes
introduced by here respect the original design ideas and philosophy as much
as possible.

\subsection{Program text representation}

\A{} is an Algol-like language in which key words are distinguished by a
different typeface. In practice coding is typically done using
a single (monospace) typeface. There are several approaches to distinguish
keywords from the surrounding text, but
none of them
is perfect. In this implementation bold face keywords are enclosed between
apostrophe characters, such as
\begin{program}
'variable'x=0.
'root'print int+STDOUT+x.
'end'
\end{program}
\noindent
Other approaches are using \pp|CAPITAL| letters for keywords (as it happens
in several {\sf PASCAL} implementations); restricting keywords (as in {\sf
C} and related languages); using an initial escape character only and
whitespace at the end (e.g., forget about the closing apostrophe); etc.

Characters in \A{} are not restricted to eight bits, and character strings
cannot be indexed. In this implementation any utf-8 character can be a
string character. According to the \A{} Manual \pp|newline| and \pp|newpage|
are not characters. This implementation relaxes this restriction, the
newline characters can be part of a string, but not of a \g{string
denotation} (strings in the program text). All strings should be closed in
the same line they started. Two separate consecutive strings (even if they
are in different lines) are concatenated, thus strings can be continued on
the next line.

\subsection{Hexadecimal constants}

Whenever integers are accepted, constants in hexadecimal notation are
recognized and accepted as well. An example is \pp|0x1234abcd|. A 
minus sign \pp|-| can also appear before a hexadecimal constant.

\subsection{Relations}\label{subsec:relations}

\def\HH{\noindent\hbox to 0.25\linewidth\bgroup~~~~~}
\def\HE{\hss\egroup}
The external rule \pp|equal+x+y| tests the equality of \pp|x| and \pp|y|.
The same test can be done by using the \g{identity} \pp|x=y|.
Similar shorthand were added (not present in the original language)
for the other comparison operators:

\smallskip

\HH\pp|x!=y| or \pp|x-=y|\HE  for \pp|x| and \pp|y| differ;

\HH\pp|x<=y|\HE               for \pp|x| is less than or equal to \pp|y|;

\HH\pp|x<y|\HE  for \pp|x| is smaller than \pp|y|;

\HH\pp|x>y|\HE  for \pp|x| is greater than \pp|y|;

\HH\pp|x>=y|\HE for \pp|x| is greater than or equal to \pp|y|.


\subsection{Lists in scalar context}

In an affix position where a single integer is required, a list \pp|L|
(a  \g{table} or \g{stack}) can appear with the meaning that the value is
that of its topmost 
(rightmost) element. namely \pp|L[>>L]|. Similar abbreviation exists for 
lists with selectors. Thus the rule call
\begin{program}
add + a*L + b*L + L
\end{program}
\noindent
is equivalent to
\begin{program}
add + a*L[>>L] + b*L[>>L] + L*L[>>L]
\end{program}
\noindent
This extension means that occasionally a \g{stack} visually looks -- and
behaves -- like a variable, making stack operations write and comprehend
more easily.

This extension come naturally, and was really handy in cases when the
content of a newly added block on the top of a \g{stack} had to be
manipulated. In cases when the list was entered by mistake, the extension
prevents the compiler from complaining about affix type mismatch. The
implicit reference to the topmost list block came, unexpectedly, as an extra
complication during macro substitution.

\subsection{Actual and virtual limits}

Each \g{table} and \g{stack} has a \emph{virtual address space} assigned by
the compiler (with almost no control of the programmer) which is fixed
during the run of the program. The \emph{actual address space} of \g{stack}s
changes when the stack is extended or shrunken, see Section
\ref{subsec:virt-mem}. For a list \pp|L| the constructs \pp|<<L| and
\pp|>>L| return the actual lower and upper bounds of \pp|L|, respectively.
To get the \emph{virtual} limits of the same list, one can use \pp|<L| and
\pp|>L| (with a single \g{left symbol} and \g{right symbol}). In constant
expressions only virtual limits can be used (as the actual limit can change
during program run).

For \g{table}s the actual and virtual limits are always equal. In case of
\g{stack}s actual limits are always within the virtual limits. Fixed stacks
(i.e. stacks without size estimate) have equal actual and virtual limits.

\subsection{Dummy affix}

When the value of an out formal affix is not needed (the value can be thrown
away), rather than forcing the programmer to invent some dummy variable,
the \g{dummy symbol}
can be used. This symbol has representation \pp|?| by the Manual, this
implementation also accepts the sharp-sign \pp|\#|. Visually it looks
better, not indicating any uncertainty. Compare the two lines below:
\begin{program}
 divrem+a+5+\#+rem,  
 divrem+x+10+?+q.
\end{program}


\subsection{String as actual affix}

A \g{string denotation} can be used as an actual affix. This extension
simplified to write some program texts, and, hopefully, made it more
transparent by bringing the string definition and usage closer.
Without this feature strings are typically put into a \g{table} with a
pointer constant pointing to the string, and then use the table name 
and the string pointer:
\begin{program}
'table'MESSAGE=("unknown identifier":unknown tag).
\smallskip
'action'tag error:error+MESSAGE+unknown tag.
\end{program}
\noindent
With this extension the string can appear as an argument:
\begin{program}
'action'tag error:error+"unknown identifier".
\end{program}
\noindent
Actually, as an actual affix a string translates to two affixes: first a 
special table and second a pointer which points to the string in that table. 
The specified string is automatically added as a filling
to that table. The compiler might (or might not) merge identical strings.

\subsection{Root rule}

The \g{root} of an \A{} program (the only directly executable instruction)
can have local affixes and a \g{rule body}. As it is executed only
once, thus there is no need to designate a separate rule for this purpose.
An example is:
\begin{program}
'root'(rep:put line+STDOUT+V+newline,
         (next perm+<<V+V,:rep;+)).
\end{program}

\subsection{Matching formal and actual list affixes}

Every \g{table} and \g{stack} has an associated \emph{block structure} which
determines the block size of that list together with the set of \g{selector}s. By
default, the block size is 1, and the selector is the same as the list name.
Otherwise the list definition must have a selector list which contains the
selectors in a left to right order. For example, the \g{formal stack} definition
\begin{program}
[](tag,left,right)tags[]
\end{program}
\noindent
specifies that the block structure of the \g{formal stack} \pp|tags| has
three elements with selectors \pp|tag|, \pp|left|, and \pp|right|, where
\pp|right| is the rightmost element of the block. Also, the list \pp|tags| has no
\emph{standard selector}, namely a selector with the name of the list.

Neither in a formal definition nor in a declaration the list's \g{selector list
pack} can be the empty \pp|()| (the \A{} Manual allows this in formal list
definition). The \g{selector list pack}, however, can be missing completely.
The blocks of the formal and of the actual lists are compared as follows.
\begin{itemize}
\item[$\cdot$] the formal list has no \g{selector list pack}:

there is no restriction on the actual list. Observe, however, that in this
case the standard selector of the formal and the actual might be different.
Suppose we have the rule declaration
\begin{program}
'action'set zero+[]st[]: 0->st.
\end{program}
\noindent
which sets the topmost element of the \g{stack} \pp|st| to zero. (It is an
\g{action} as it makes a global change.) With the
declaration \pp|'stack'(L,b)L| the assignment \pp|0->L| clears the second to
last element of \pp|L|, while \pp|set zero+L| clears the last element of the
list.
\item[$\cdot$] the formal list has a non-empty \g{selector list pack}:

the actual list must have the same block size and the same standard selector
(selector names, however, can be different). If this restriction is
violated, a warning is issued; if the called rule is a macro, then this is an
error.
\end{itemize}

\subsection{Extension syntax}

An \g{extension} adds a new block to the top of a (formal or global) stack. It
is specified as a sequence of assignments where the destinations are the
selectors of the block; it is enclosed between \pp|*| symbols, followed by
the list tag. If the \g{stack} \pp|st| has three selectors \pp|sel|, \pp|ect|,
and \pp|ors|, then the extension
\begin{program}
  * pnt->sel, 0->ect->ors * st
\end{program}
\noindent
extends \pp|st| with a block of three elements. To make such \g{extension}s
more appealing visually, parentheses can be inserted \emph{before} and
\emph{after} the \pp|*| as follows:
\begin{program}
  (* pnt->sel, 0->ect->ors *) st
\end{program}
\noindent
This change destroys the $LL(1)$ property of the \A{} syntax, as a \pp|(*|
sequence can be either the start of an \g{extension}, or that of a \g{compound
block} which has an \g{extension} as its first \g{member}. Nevertheless the
improved readability of \A{} programs justifies the additional parser work.

\subsection{Expressions}\label{subsec:expression}

In \A{} an \g{expression} must have a value which can be determined during
compilation. Originally \g{expression}s can be used at several places; this
implementation restricts them to \g{constant} and \g{variable declaration}s
only. It is not an essential restriction as new constant tags can be declared
with the desired values. 

An \g{expression} must evaluate to a constant value. An expression can refer
to a constant tag declared later (or in another module), but cannot depend
on itself. Thus
\begin{program}
'constant'a=b+2.
'constant'b=/a/.
\end{program}
\noindent
is accepted (here \pp|/a/| is the value of the character \pp|a| in the used
coding), while
\begin{program}
'constant'p=q+1,q=1-p.
\end{program}
\noindent
is not, and gives an error message.

Next to the usual arithmetic operators \pp|+|, \pp|-|, \pp|*| and  \pp|/|,
the following Boolean operators can be used:
\begin{itemize}
\item[$\cdot$] \pp|~x| for the (binary) complement of \pp|x|;
\item[$\cdot$] \pp|x\&y| and {\tt x|y} for the bitwise \g{and} and bitwise \g{or};
\item[$\cdot$] \pp|x^y| for the bitwise \g{xor} (modulo 2 addition) operator.
\end{itemize}
They have lower priorities than the arithmetic operators.

In expressions integer denotations (both decimal and hexadecimal),
constant tags, pointer constants (defined in fillings), virtual bounds and
list block size (caliber) can be used.  List size estimates and repeat
numbers (see Section \ref{subsec:filling}) are evaluated before the virtual
bounds are determined, thus these values cannot depend on these bounds.

\subsection{Stack size estimate}\label{subsec:size-estimate}

A \g{stack declaration} specifies the virtual address space size this stack
requires. This \g{size estimate} can either be \emph{fixed} or
\emph{relative}. In both cases it must be an integer denotation or a
constant tag; no expression is allowed.

The \emph{fixed size} is specified between \pp|=| symbols; its value
cannot be larger than 1,000,000 (and, of course, must be positive). The
compiler reserves at least as much virtual space for the stack. (The final
virtual space can be larger if the stack has fillings which totals to a
larger amount.)

The \emph{relative size} estimate should give a positive integer not bigger
than 100. After reserving virtual addresses for \g{table}s and fixed size
\g{stack}s, the remaining space is distributed proportional to the requested
relative amount.


\subsection{Filling}\label{subsec:filling}

Next to selectors and block size, a
\g{table} and \g{stack} declarations may specify the initial content of the
list. This \g{filling} is a sequence of integer denotations, constant tags
(including pointers), strings, and
blocks. Each one can be followed by the \g{repeat symbol} \pp|*|, followed by
either an integer or by a constant tag specifying how many times this item
should be repeated. Then the optional \g{pointer initialization} follows: a colon
\pp|:| and a constant tag which is defined to have the the value of virtual address
of the last defined list item. Example:
\begin{program}
'constant'tsize=10.
'stack'T=(0*tsize:tzero,1*tsize,"string":tstring).
\end{program}
\noindent
adds ten zeroes, ten ones, followed by the internal representation of the
string \pp|string|. It also declares \pp|tzero| to be the (virtual) address of the
lastly added \pp|0|, and \pp|tstring| to be the (virtual) address of the last 
element of \pp|T| (which, if no further filling is added, is the same as \pp|>>T|). 

In the \g{filling} a \g{compound block} defines the content of a list block.
The \g{compound block} must have exactly as many elements as the list block has
(violating this requirement will result in a warning). A block element must be either
an integer or a constant tag (possibly a pointer constant). In the block the
constant value is followed by an \g{arrow symbol} \pp|->| and the
selector where it must be stored. Example:
\begin{program}
'stack'(ch,prio)optor=(
 (/+/->ch,3->p), (3->p,/-/->ch),(5->p,/^/->ch)).
\end{program}
\noindent
which adds three blocks of size two to the stack \pp|optor|.

The original block syntax is also accepted: the \g{compound block} of the
\g{filling} contains, in the left to right order, the values which should be
added to the list. One of the integer values can be followed by the
\g{repeat symbol} \pp|*| with the meaning that this element will be repeated
as many times as necessary to fill the whole list block. Example:
\begin{program}
'stack'(a,b,c,d,e,f,g,h)big block=( (0*)*100 ).
\end{program}
\noindent
adds 100 blocks to the \g{stack} \pp|big block|, each consisting of eight zeroes.

\subsection{Multiple list filling}\label{subsec:spread-filling}

Fillings for a list can spread across the program (actually, can spread
across several modules). A list description (without size estimate),
followed by \pp|=| and a filling can appear multiple times across the
program. Fillings specified this way are accumulated. Their order is
unspecified, but within a single filling the order of the added elements is
kept intact.

If a \g{stack} has no declaration, namely a list head with a size estimate,
then its virtual size will be equal to the total size of the fillings. The
stack can still shrink, but cannot expand beyond its virtual upper limit.

\subsection{Exit rule type}\label{subsec:exit}

Executing the \g{terminator} \pp|'exit'16| causes the program to terminate
with exit value 16. The \pp|'exit'| statement is replaced internally by a call of
the \g{external rule} \pp|exit|, in this case as \pp|exit+16|. Consequently 
\pp|'exit'| must be followed by an \g{actual affix}, and not by an \g{expression}.

In general, next to the four rule types \emph{predicate}, \emph{question},
\emph{action}, and \emph{function}, a fifth is added: \emph{exit}. A rule is
of type \emph{exit} if it never returns. Thus the (external) rule
\pp|exit| is of type \emph{exit}, as well as the rule
\begin{program}
'exit'was error+>x:
   x>=0,exit+0;
   put string+STDERR+"Error:",put int+STDERR+x,exit+-1.
\end{program}
\noindent
This rule prints some additional message before terminating the program run.
A rule of type \emph{exit}
\begin{itemize}
\item[$\cdot$] should not have out or inout affixes (as there is no way to
use the returned values); and
\item[$\cdot$] cannot return.
\end{itemize}
When an exit rule is defined, these conditions are checked. When such a rule
is used, it is treated as a \g{terminator} which can neither succeed nor
fail.

\subsection{Classification}\label{subsec:area}

A classification chooses exactly one of the possible alternatives based on the value
of a \g{source} included in the \g{classifier box}. An example is
\begin{program}
(= last*L[n] =
 [0;1],   action 1;
 [-10:10],action 2;
 [L;1000],action 3;
 [:],     action 4)
\end{program}
\noindent
The \g{area} in the square brackets determines whether the alternative
following it will be chosen. No \g{expression} is allowed in an \g{area}, only
integer denotation (decimal or hexadecimal), constant tag (including constant
pointer)
and global (not formal) list. This latter stands for its virtual
address range. All values in an area are determined during compilation, and
the compiler gives an error message if some of the alternatives cannot be
reached (this happens, for example, if the first two \g{area}s in the above
example are swapped); and gives a warning if it is possible that none of the
alternatives are chosen. When running the program and none of the
alternatives succeeds the program run is aborted with an error message.

\subsection{File area, file string}\label{subsec:datafiles}

In a \g{file declaration} an \g{area} can be given which restricts what
values are allowed to send to or receive from that file. In this
implementation no \g{area} is allowed for character files, and the \g{area}
of a datafile should contain only those lists (\g{table}s and \g{stack}s) to
which pointers will be sent to or received from. How datafiles work is
discussed in Section \ref{subsec:datafile}.

The \g{string denotation} and the direction (the \pp|>| symbol before and
after the string) is used as follows. Files can be opened by the external
rule
\begin{program}
  'a'open file+""file + >mode + t[]+>ptr.
\end{program}
\noindent
where \pp|mode| is the character \pp|/r/| for reading, \pp|/w/| for writing,
and \pp|/a/| for appending (appending is implemented for character files only);
the last two arguments specify the file name string (with possible path 
information).

Without explicitly opening the file, the first file operation tries to
open it. The \g{string denotation} gives the file name, and the
\g{direction} restricts the access: the file opens automatically for reading
only if there is a \pp|>| \emph{before} the string, and for writing if
there is a \pp|>| \emph{after} the string. 

\subsection{Static stack and static variable}

\g{Variable}s and \g{stack}s can be declared to be \g{static} by adding the
\pp|'static'| keyword before their declaration, such in
\begin{program}
'static''variable'resources=0.
'static''stack'[=20=]values.
\end{program}
\noindent
Static variables and stacks behave identically to variables and stacks in
the module they are declared. In other modules, however, they are ``read
only'', which means that other modules cannot change the value of a
\g{static variable}, and cannot modify, extend, shrink, or manipulate
otherwise a \g{static stack}.

\subsection{Prototype}\label{subsec:prototype}

A \g{prototype} informs the compiler about a tag. A \g{table} or 
\g{stack prototype}
has no size estimate and filling; a \g{constant}, \g{variable}, \g{file
prototype} has no data (or initial value); a \g{rule
prototype} has no \g{actual rule}. They look like an external declaration without
the \pp|'external'| keyword and the string denotation. Example:
\begin{program}
'charfile'PRINTER.
'action'print tag+>tag.
'constant'max tag pointer.
\end{program}


Prototypes are used to inform the compiler about tags which are defined in
other modules, see Section \ref{subsec:module} more on modules.

\subsection{Pragmats}\label{subsec:pragmats}

Pragmats are used to control certain aspects of the compilation; their
semantics changed significantly compared to the \A{} Manual. The following 
pragmats are recognized by this implementation:

\def\HH{\noindent\hbox to 0.3\linewidth\bgroup~~~}
\smallskip

\HH\pp|tab size=8| \HE sets tab size for program text printing

\HH\pp|library=on/off| \HE switch to library mode

\HH\pp|stdlib=off| \HE don't read the standard library

\HH\pp|list=on/off| \HE switch program text printing

\HH\pp|warning level=8| \HE set warning level between 0 and 9

\HH\pp|dictionary=on/off| \HE collect where each tag occurred in the program

\HH\pp|compile=on/off| \HE pragmat flag, see below

\HH\pp|title="title"| \HE specify program title

\HH\pp|module="title"| \HE specify module name, switch to module mode

\HH\pp|bounds=on/off| \HE compile with index checking

\HH\pp|count=on/off| \HE count how many times rules are called

\HH\pp|trace=on/off| \HE trace rule calls and affixes

\HH\pp|include="file"| \HE add \pp|file| to the sources to be read

\HH\pp|require="file"| \HE require module headers from \pp|file|

\HH\pp|prototype=none| \HE specify how prototypes are handled (Section
\ref{subsec:prototype})

\HH\pp|macro=rule|   \HE \pp|rule| should be treated as a macro.

\smallskip

\noindent
Command-line arguments starting with double dash are pragmats:
\begin{program}
{-}{-}XXXXX
\end{program}
\noindent
is parsed as
\begin{program}
'pragmat' XXXXX .
\end{program}
\noindent
except that no conditional pragmats are accepted (see below). There are
other command-line shorthand starting with a single dash:

\smallskip

\HH \pp|-L| \HE \pp|library=on|

\HH \pp|-l| \HE \pp|list=on|

\HH \pp|-M| \HE \pp|prototype=public|

\HH \pp|-d| \HE \pp|dictionary=on|

\HH \pp|-W| \HE \pp|warning level=3|

\HH \pp|-I XXXX| \HE \pp|path="XXXX"| (only in command-line)

\HH \pp|-o XXXX| \HE \pp|title="XXXX"|

\smallskip
\noindent
There is no {\tt path} pragmat, it can only be used as a command-line
argument. The path specifies the directories, separated by \pp|:|, which are
searched for source files (included and required) and the standard library.

Standard values for some \g{pragmat}s are

\HH\pp|tab size=8,|\HE

\HH\pp|list=off,|\HE

\HH\pp|dictionary=off,|\HE

\HH\pp|library=off,|\HE

\HH\pp|compile=on,|\HE

\HH\pp|prototype=none.|\HE

\smallskip

The \g{pragmat} \pp|include=("file1","file2")| adds these files to the end
of the source list to be processed. Similarly,
\pp|require=("file1","file2")| also adds these files. The difference is the
following. When the compiler opens a source file, pragmat values are reset
to their default values as indicated above. For \pp|include| files the
\pp|compile| and \pp|prototype| pragmats are set to values which were
in effect when the source file was added to the list. For \pp|require|
files 
\begin{program}
  'pragmat'compile=off,prototype=import.
\end{program}
\noindent
is added. It is an error to add the same file both as \pp|include| and as
\pp|require| at the same time.

When \pp|compile=off| is in effect, the \pp|title| and \pp|module| pragmats are
ignored; the \pp|compile| pragmat has no other effects for the working of
the compiler.

The \pp|prototype| pragmat has three possible values: \pp|import|, \pp|public|,
and \pp|none|. In the first case a \g{prototype} indicates that the tag has a
declaration outside this module (and then it cannot be defined, but can
have other prototypes). In the second case every tag appearing in a
\g{prototype} gets automatically
the \emph{public} flag, and must be defined in this module (consequently
cannot be external, or imported). When \pp|prototype=none|, prototypes are
only for checking purposes and do not imply any specific behavior.

The \pp|module| pragmat, if not skipped (i.e., if \pp|compile=on| is in
effect), then defines the module name, and also sets \pp|prototype=public|.

\subsection{Conditional pragmats}\label{conditional}

Conditional pragmats can be used to instruct the compiler to ignore certain parts
of the source file. They have the syntax

\medskip

\pp|'pragmat'if=TAG.     'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pp|'pragmat'ifnot=TAG.  'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pp|'pragmat'ifdef=TAG.  'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pp|'pragmat'ifndef=TAG. 'pragmat'else=TAG.   'pragmat'endif=TAG.|

\medskip
\noindent
where \pp|TAG| is one of \pp|compile|, \pp|list|, \pp|dictionary|,
\pp|module|, \pp|library|, etc. The program text between the \pp|if| and
\pp|else| pragmats is processed if \pp|TAG| is in effect (it is not in
effect), otherwise it is skipped; and just the opposite for the text between
\pp|else| and \pp|endif|. The \pp|else| part may be missing.
The \pp|TAG| in \pp|ifdef| (\pp|ifndef|)
pragmats can be any identifier (tag), and it is checked if this identifier 
has (has not) been defined until this points.
As an example, the \g{pragmat}
\begin{program}
'pragmat'if=module,include="private",else=module,
                   include="public",endif=module.
\end{program}
\noindent
adds the source file \pp|private| among those to be processed if the
\pp|module| pragmat has been executed previously; otherwise it adds the
\pp|public| source file.

The \pp|if| \dots \pp|endif| pragmats must be nested properly, and the
ignored text must be syntactically correct (as it is scanned to find the
closing pragmat). The \pp|'end'| symbol marking
the end of the source file is never ignored: conditional pragmats do not
extend over the end of the current file.

\subsection{\A{} modules}\label{subsec:module}

An \A{} module starts with a \pp|module| pragmat which defines the module's
name (title). After this the module header follows which contains the prototype 
of all exported (public) tags. The module's
body, which defines the exported tags together
with private items, is enclosed between \pp|ifdef=compile| and
\pp|endif=compile| pragmats. A small module exporting the rule \pp|do
something| and the stack \pp|LEXT| can be defined as follows.
\begin{program}
'pragmat'module="sample".  $ module name $
'action'do something+>in+out>.
'stack'(adm,left,right)LEXT.
'pragmat'if=compile.       $ module body $
 'stack'[12](adm,left,right)LEXT=((3,4,5):first item).
 'action'do something+>x+y>: add+first item+x+y.
 'root'+.
'pragmat'endif=compile.    $ until this  $
'end'
\end{program}
\noindent
When the module is compiled, the source is read with the pragmat
\pp|compile=on|. Thus the \pp|module| pragmat is executed, which sets the
\pp|prototype| pragmat to \pp|public|. The module head is parsed, and
the compiler marks all prototyped tags to be exported, thus they must
have a definition later on. The condition in the \pp|if=compile| pragmat 
holds, and the material in the module body is read and compiled.

When the module is required by giving \pp|'pragmat'require="sample"|, then
the module text is parsed with \pp|compile=off| and \pp|prototype=import|.
The \pp|module| pragmat at the top is ignored (as now \pp|compile=off|), then
the prototypes are scanned. The compiler marks all prototyped tags as ``to
be defined in another module'' and complains if the same tag is defined or
not used properly. Reaching the conditional pragmat \pp|if=compile| it
fails, consequently the remaining text of the module is skipped.

Modules can require public items from other modules; it may happen that
module \pp|a| requires some public item from module \pp|b|, and module
\pp|b| requires some public item from module \pp|a|.

As in the sample module above, all modules must have a
\pp|'root'|. All module \g{root}s are executed before the main \g{root} is
called (which must be in the only non-module source file). The module 
root can make the necessary initialization. If no such initialization 
is necessary, the module can use an empty \g{root} as it happened in the 
example. To control the order of the initialization, a module
can call the rule
\begin{program}
wait for+"another module"
\end{program}
\noindent
This rule checks if there is a module with the supplied title.  If not, it
fails and returns immediately.  Otherwise, before returning success, it
makes sure that the referred module has finished initialization.  The
\pp|wait for| rule aborts the program run with an error message if two
modules would wait for each other, thus use this rule with care.

\subsection{Library mode}\label{subsec:library}

The \pp|library| pragmat determines whether library extensions are
allowed or not. \pp|'pragmat'library=on| turns the library mode on, while
\pp|'pragmat'library\allowbreak=\allowbreak off| turns it off. The standard
library, if not disabled by \pp|'pragmat'stdlib=off|, will be read as the 
last source.

%\noindent~~$\cdot$~~~%
In library mode the \pp|@| character is considered to be a letter. This 
way private tags
can be created which are not available outside the library. Dictionary
listing ignores tags starting with \pp|@|.

%\noindent~~$\cdot$~~~%
External declarations are allowed in library mode only.

%\noindent~~$\cdot$~~~%
The \g{inquire symbol} \pp|?|, followed by a \g{tag}, can be used to check if
the \g{tag} has been used but not defined. If this is the case, the \g{inquire
symbol} and the \g{tag} is discarded, and the source is processed. If it is not
the case, (that
is, either the \g{tag} was not used, or it has had a previous definition), then the
program text is skipped until the next \g{point symbol}. The library snippet
\begin{program}
?nlcr    'action'nlcr:put char+STDOUT+newline.
?newline 'constant'newline=10.
\end{program}
\noindent
checks first if  \pp|nlcr| has been used so far without definition. If yes,
the rule definition following \pp|?nlcr| is read, otherwise it is skipped.
The next line defines the \pp|newline| constant to correspond to the newline
character with code 10. The order of the \g{inquire statement}s are
important. For example a second inquiry starting with \pp|?nlcr| would
always be skipped.

\subsection{Predefined constants}

There are five built-in constants. They start and end with an underscore,
and can be used anywhere where an integer denotation or a string is
accepted.
\smallskip

\def\HH{\noindent\hbox to 0.2\linewidth\bgroup~~~~~}
\HH \pp|\_line\_|\HE integer, the source line number this constant appears

\HH\pp|\_file\_|\HE string, name of the the source file

\HH\pp|\_source\_|\HE same as \pp|\_file\_|

\HH\pp|\_title\_|\HE string, the title as set by \pp|title=".."| or
\pp|module=".."|

\HH\pp|\_rule\_|\HE string, the rule name if used inside a rule definition.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variable number of affixes}

Allowing -- and handling -- variable number of affixes in rules is the main
novelty of this \A{} compiler. Variable number of affixes raise several
problems, and pose a main obstacle keeping the tractability of the rule
properties. The approach used here meets two main requirements: on one hand it
provides a flexible and usable variable argument mechanism, and on the other
it keeps all tractability properties of \A{} programs. This is achieved by
restricting how the ``invisible'' affixes in the variable block can be accessed.

A \g{formal affix sequence}, which defines the arguments of a \g{rule}, can
contain a \g{repeat affix symbol} \pp|*| indicating that the affixes from that
point to the right can be repeated indefinitely. The rule \pp|sum| in the
declaration
\begin{program}
'function'sum+a>+*+>b+>c:
  0->a,(nxt:add+a+b+a,add+a+c+a,
            shift affix block+*,:nxt;+).
\end{program}
\noindent
has the single out affix \pp|a|, and two input affixes \pp|b| and \pp|c|,
the latter two forms the repeat affix block. Invoking this rule requires
three, five, seven, and so on actual affixes. The first three of the actual
affixes are matched against the formal affixes \pp|a|, \pp|b|, and \pp|c|.
The rule execution starts by setting \pp|a| to zero, then adding \pp|b| and
\pp|c| to \pp|a|. The library routine \pp|shift affix block| shifts out the
affix block and moves the next block into its place, assuming there is still
a pending, not seen block. If there is none, \pp|shift affix block| fails;
and then the rule \pp|sum| ends. Otherwise the execution continues, and a
jump is made to the label \pp|nxt|, where the next two input affixes are 
added to \pp|a|. Finally, \pp|sum| adds up all of its input arguments 
and return their sum in \pp|a|.

The main point which guarantees tractability data flow is that the shifted
out blocks are lost to this rule, there is no way to reach or modify their
elements.

The \g{repeat affix symbol} \pp|*| can appear as the last actual affix in a 
call of \pp|sum| with the meaning that the present and all subsequent affix 
blocks of this rule are passed as arguments. The rule \pp|negate| declared as
\begin{program}
'function'negate+a>+*+>b+>c-z:
   add+b+c+a,(shift affix block+*,sum+z+*,subtr+a+z+a;+).
\end{program}
\noindent
adds up its first two in affixes \pp|b| and \pp|c|; if there are no more 
affixes then this sum is
the result. Otherwise it calls \pp|sum| to add up the rest, and then subtract
it from the sum of the first two. Thus the calls
\begin{program}
 negate+x+3+4, negate+y+3+4+0+1, negate+z+3+4+0+1+x+y
\end{program}
\noindent
put 7 to \pp|x|, 6 to \pp|y|, and $-7$ to \pp|z|.

The library routine \pp|get affix blockno+n>+*| returns the number of
pending affix blocks. This number is always positive, and it is exactly
\pp|1| if and only if \pp|shift affix block+*| would fail.

The main application of variable number of arguments is formatted printing,
which, in the \A{} compiler, has mainly been used to report error messages,
but it also turned out to be useful in code generation. A rudimentary
formatted printing can start with the format string -- so
it is two affixes: the table and the string pointer. Each format character
starting with \pp|\%| should have 
a corresponding affix. When encountering a format char, the affix list
is shifted and the next argument, together with the format char, is passed
to the rule \pp|handle format char|.
\begin{program}
'action'format print+T[]+*+>arg-fmt-n-ch:
  arg->fmt,0->n, $ fmt is the string pointer $
  (nxt:string elem+T+fmt+n+ch,incr+n,
         ((ch=/\%/,string elem+T+fmt+n+ch,incr+n,
                                     shift affix block+*),
            handle format char+ch+arg,:nxt;
          put char+STDOUT+ch,:nxt);
       put char+STDOUT+newline).
\end{program}
\noindent
Another application can be pushing and popping unspecified number of elements
to a stack:
\begin{program}
'action'push+*>x:
   (* x->BUFFER *) BUFFER,(shift affix block+*,:push;+).
'action'pop+*+x>:
   BUFFER->x,unstack+BUFFER,(shift affix block+*,:pop;+).
\end{program}
\noindent
Passing all remaining affixes in the variable block was used to suppress
low level warning messages with a code similar to the one below:
\begin{program}
'action'warning+>level+T[]+*+>msg:
   level<min level;
   format print+T+*.
\end{program}

\section{Macro substitution}

Calls of a macro rule are implemented by textual substitution. Such a
replacement can result in a syntactically wrong text, or in a completely
different semantics. The following examples illustrate these cases and
explain the additional restrictions a macro rule must satisfy.

\begin{enumerate}\def\HH{\noindent\hbox to 0.33\linewidth\bgroup~}%
\setlength\parskip{1pt plus 1pt minus 1pt}%
\item In a macro \g{formal in affix}es cannot be assigned to.
Suppose the rule \pp|macro| is defined as
\begin{program}
'function'macro+>x+y>: 1->y->x,x->y.
\end{program}
\noindent
then after substitution the replacement is syntactically wrong:

\HH \pp|macro+1+z|\HE becomes \pp|(1->z->1,1->z)|

\item There is a problem with the \g{dummy affix}.
Using the same \pp|macro| rule as above, the result has wrong syntax:

\HH \pp|macro+u+\#| \HE becomes \pp|(u->\#->u, u->\#)|

\item While a macro can have variable number of affixes, neither \pp|shift
affix block|, nor \pp|get affix blockno| is allowed.
If \pp|macro| is defined as
\begin{program}
'function'macro+>a+*+>q: q->b, call+a+b+*.
\end{program}
\noindent
where \pp|b| is some global variable, then after substitution the repeat
block may completely vanish:

\HH\pp|macro+1+2+T+rep2| \HE becomes 
   \pp|(2->b,call+1+b+2+T+rep2)|

\smallskip

If a rule head is \pp|XXXX+*+>u| and the same \pp|macro| is called inside this
rule, then the \g{formal affix} \pp|u| might appear in the substitution text
while it has not been passed to the macro explicitly:

\HH\pp|macro+1+*|\HE becomes \pp|(u->b,call+1+b+*)|

\item Standard selectors are not carried over.
\begin{program}
'function'macro+t[]+x>: t[ptr]->x.
\end{program}

where \pp|ptr| is some global variable. After substitution

\HH \pp|macro+S+z|\HE becomes \pp|(S[ptr]->z)|

\smallskip

while \pp|S| might not have a standard selector.

\item Out affixes get their values only after returning from the call.
The rule call \pp|swap+x+y+x| swaps the value of \pp|x| and \pp|y| if it is
defined as
\begin{program}
'function'swap+>a+b>+c>: b->c,a->b.
\end{program}
\noindent
but as a macro it does \pp|y->x,x->y|.
\end{enumerate}
Items 1) and 3) are checked during compilation, and error messages are issued
if the conditions are violated. For 2), if the actual is a \g{dummy affix}, the
formal out affix in the macro is turned into a local variable (which, later
on, could be optimized out). For 4) the macro substitution mechanism remembers the
last substituted formal affix, which gives the correct standard selector.
For 5) and other side effect, no warning is, or can be, given, but it
changes the semantics. So use macros at your own risk.

\section{Redefining assignments and relations}

Assignments (\g{transport}s) and relations (of which \g{identity} is an
example, see Section \ref{subsec:relations}) are handled as a syntactically
different way to write a rule call. The assignment
\begin{program}
a->b[c]->c
\end{program}
\noindent
is transformed internally to the rule call
\begin{program}
@make+a+b[c]+c
\end{program}
\noindent
(recall that the character \pp|@| is a letter in library mode, see Section 
\ref{subsec:library}), and \pp|@make| is declared in the standard library as a
\begin{program}
'external''function'@make+>from+*+to>.
\end{program}
\noindent
Similarly, relations are transformed to calls of rules \pp|@equal|,
\pp|@noteq|, \pp|@more|, \pp|@less|, \pp|@mreq|, and \pp|@lseq|,
respectively; all of them is
a \emph{question} with two input affixes, also defined in the standard
library. Any of these rules can be redefined (in library mode) to do
something different. As an example, 
suppose the list \pp|STR| contains strings, and two pointers to
\pp|STR| should be equal if the strings they point to are the same, not only
if they, as pointers, are equal. So 
\begin{program}
 (ptr1=ptr2,print+"strings are equal";
            print+"strings are not equal")
\end{program}
\noindent
would print \pp|strings are equal| if the two string pointed by \pp|ptr1| and
\pp|ptr2|, as strings, are equal. This can be achieved by defining \pp|@equal| to
handle this case:
\begin{program}
'pragmat'library=on.
'external''question'real eq+>x+>y="\_\_equal". $ from stdlib $
'question'@equal+>x+>y-eq:
  (was+STR+x,was+STR+y),compare string+STR+x+STR+y+eq,eq=0;
  real eq+x+y.
'pragmat'library=off.
\end{program}
\noindent
Actually, the test \pp|eq=0| should be \pp|real eq+eq+0|, as this way the
rule \pp|@equal| calls itself. In the module where this definition appears
all equality tests use this rule. You might consider to declare \pp|@equal|
to be a \pp|macro|; it also should be done in library mode.

\section{Implementation details}

The target code of this \A{} compiler is {\sf C}. It is assumed that the
basic \A{} data type, which translates to \pp|int| in {\sf C}, is 32 bit long,
and that the compiler and the target code runs on the same
architecture\footnote{The compiler must know how strings are packed in the
target machine to generate list fillings. Also, in a datafile declarations the
hash of the list identifiers are computed at compile
time, and are used when the \A{} program runs.}. There is no assumption on
the pointer's size.

\subsection{Tables, stacks}\label{subsec:tables-stacks}

The \A{} value of a \g{table}, \g{stack}, \g{datafile} and \g{charfile} is
an index to the global integer array \pp|a\_DATABLOCK|, where specific 
structures are stored. Given the value \pp|idx|, the {\sf C} macros
\pp|to\_LIST(idx)|, \pp|to\_CHFILE(idx)| and \pp|to\_DFILE(idx)| create a
pointer to the corresponding list, character, or datafile structure.

Table and stack structures have the following fields.
\def\HH{\noindent\hbox to 0.25\linewidth\bgroup~~}

\medskip

\HH\pp|int *offset;|\HE the zero virtual element of the list

\HH\pp|int *p;|\HE  pointer to the beginning of the allocated memory block

\HH\pp|int length;|\HE length of the allocated block

\HH\pp|int alwb,aupb;|\HE actual lower and upper bounds

\HH\pp|int vlwb,vupb;|\HE virtual lower and upper bounds

\HH\pp|int calibre;|\HE  calibre of the list

\smallskip
\noindent
The \A{} list element affix \pp|L[i]| is translated to \pp|to\_LIST(L)->offset[i]|
in {\sf C}. List limits (actual and virtual limits and calibre) are
retrieved from this structure. There are no direct pointers to list elements
in the program, thus the whole list can be freely moved in the memory, only the
pointers \pp|offset| and \pp|p| should be adjusted.

When a stack is to be extended and no more allocated space is available,
additional memory is requested (which may move the whole list to somewhere
else in the memory). The elements of the new list block are initialized
and the list's actual upper bound is increased. The \pp|unstack| and
\pp|unstack to| externals adjust the actual upper bound only. The
\pp|release| external actually releases the allocated memory, while
\pp|scratch| only sets the actual upper bound to its lowest possible value
but keeps the allocated memory.


\subsection{Datafile implementation}\label{subsec:datafile-implement}

As discussed in Section \ref{subsec:datafile}, \A{} datafiles store integers
(computer words), and pointers to lists. An external datafile is a sequence
of \pp|1024*sizeof(int)| blocks (read and written as a single block), and each block
is arranged as follows.

\smallskip

\def\HH{\noindent\hbox to 0.25\linewidth\bgroup~~~~}
\def\HE{\hss\egroup}

\HH \pp|B[0]|\HE magic number, identifying the \A{} datafile

\HH\pp|B[1..31]|\HE bitmap for the rest of this block

\HH\pp|B[32..1023]|\HE the actual data

\smallskip

\noindent
In the bitmap part the indicator bit for the word at position $32\le \mbox{\tt i} <
1024$ is at word location \pp|B[int(i/32)]|, and at bit position
\pp|(i\&31)| where zero is the most significant bit, and 31 is the least
significant bit. The \pp|nil| pointer is a pointer with value zero; the
\pp|eof| (end of file) indicator is a pointer with value $-1$; all other
pointer values must be positive and belong to one of the datafile zones.

The first few values in the datafile contain the zone list. Each zone
occupies three words: the virtual lower and upper bounds and the hash value
of the list name. The maximal number of zones is \pp|MAXIMAL\_AREA=32|, and
this list must fit into the first data block. Data for the first zone is in
\pp|B[32]|, \pp|B[33]|, \pp|B[34]|, followed by data for the other zones.
The lower and upper bounds (inclusive) must be strictly positive and
disjoint, and all pointer values, with the exception of \pp|nil| and \pp|eof|
must lie within one of the zones. The hash value is a hash of the list name
which is used to match the list name when reading the datafile. The hash is
generated from the list name by the library function
\begin{program}
'function'simple hash+T[]+>p+hash>.
\end{program}

\noindent
Input \A{} datafiles can be positioned. The last 10 bits in the file
position identify the index, which must be between 32 and 1023. Other bits
identify the block in which the value is. The actual position is stored
internally, thus there is no overhead in determining it. File position
can be retrieved for both input and output datafiles, but can only set the
position for an opened input datafile. No check is made to make sure that
the position is valid (can be set after the \pp|eof| indicator).

When opening a datafile for output, the first block with the number of zones
and the corresponding values are created; the file pointer is set just
before the very first empty space.

Appending to and existing \A{} datafile is not done as it raises problems. 
Read the first block, check if it has the same metainformation as we have
right now, read the last block, find the \pp|eof| mark, then set the file
position just at the \pp|eof| mark.

Opening a datafile for input requires the following operations: read the 
first block, compare the zones
in the input file to the ones supplied by the file declaration. Comparison is
made by the hash values: two lists are the same if they have the same hash
value. Lists not found in the declaration are skipped; others are copied into a
local structure with the difference between the stored and requested pointer
values. When the next input is requested, it is checked whether it is a
pointer or not. If numerical, pass it. If it's a pointer, check which list
it is in, add the difference and pass it as a pointer. Handle \pp|nil|
and \pp|eof| separately. If the zone is not found (the corresponding list
was not supplied when opening the datafile), then fail and skip this input. 

The datafile structure stored in \pp|a\_DATABLOCK| has the following fields:

\medskip

\def\HH{\noindent\hbox to 0.4\linewidth\bgroup~~}%

\HH\pp|unsigned fflag;| \HE different flag bits

\HH\pp|int      fileError; | \HE last file error

\HH\pp|int      st1,st2;|    \HE string pointers

\HH\pp|int      fhandle;|    \HE handle, zero if not opened

\HH\pp|int      fpos;|       \HE file position

\HH\pp|unsigned iflag;| \HE pointer/numerical flag

\HH\pp|int inarea,outarea;|\HE number of areas

\HH\pp|a\_AREA  in[MAXIMAL\_AREA];| \HE input list areas

\HH\pp|a\_AREA out[MAXIMAL\_AREA];| \HE output list areas

\HH\pp|int      buffer[1024];| \HE the buffer


\subsection{Character files}\label{subsec:charfile}

While datafiles use direct file input and output, character files use
streams, namely the \pp|fgetc()| and \pp|fputc()| library procedures without the
backchar facility. Input is assumed to be proper utf-8 encoded, incorrect codes are
silently ignored. A single \pp|get char| \A{} rule may consume
up to four bytes from the input stream. There is no \pp|newpage| character,
and writing \pp|newline| sends the newline character (code 10) to the
stream.

Input character files can be positioned, they use the \pp|ftell| to retrieve
the current file position, and \pp|fseek| to set the file position.

The charfile structure in \pp|a\_DATABLOCK| has the following fields:
\medskip

\HH\pp|unsigned fflag;| \HE different flag bits

\HH\pp|int      fileError;|\HE last file error

\HH\pp|int      st1,st2;| \HE string pointers

\HH\pp|FILE     *f;|      \HE stream handle, \pp|NULL| if not opened

\HH\pp|int      aheadchar;|\HE look ahead character


\subsection{Strings}

\A{} uses Unicode characters, and they are stored as utf-8 encoded {\sf C}
strings whose last byte is \pp|{\char92}0|.
If the string is in list \pp|L| is pointed by the index \pp|si|, then the
content of the list block is

\def\HH{\noindent\hbox to 0.25\linewidth\bgroup~~~~}%
\smallskip

\HH\pp|L[si]|\HE \pp|width| (calibre) of this block

\HH\pp|L[si-1]|\HE number of utf-8 encoded characters in the string

\HH\pp|L[s+1-width]|\HE start of the {\sf C} string

\smallskip
\noindent
Each (integer) location contains four bytes. Thus a string with 6 Unicode characters,
encoded length 8 is stored in 4 words as follows: (from larger indices to lower
ones):
\smallskip

\HH\pp|5|\HE  \pp|width| of this block

\HH\pp|6|\HE   actual string length

\HH\pp|{\char92}0  -  -  -| \HE third word with the closing zero byte

\HH\pp|c5 c6 c7 c8|\HE   second word, characters \pp|c5|--\pp|c8|

\HH\pp|c1 c2 c3 c4|\HE   first word, characters \pp|c1|--\pp|c4|

\smallskip
\noindent
The empty string is stored as a block of three zeros.


\subsection{Rules in {\sf C}}

Each rule declaration is translated to a {\sf C} procedure declaration. If
the rule is of type \emph{function}, \emph{action}, or \emph{exit}, then the
procedure is \pp|void|, if it is \emph{question} or \emph{predicate}, then
it is \pp|int|. The compiled {\sf C} routines return \pp|0| for failure and
\pp|1| for success, but when checking the returned value, any non-zero
return value is taken for success.

In \A{} it is the caller's responsibility to store the output value to its
destination, and do it only if the called routine reports success. According
to this requirement, \g{formal affix}es are transformed to {\sf c}
parameters as follows. First assume that the called rule has no variable
affix block. Affixes, which are neither \g{out}, not \g{inout} ones
(that is, \g{file}, \g{stack}, \g{table}, or \g{in} affix), are
passed as integers in their original order. A local integer array is
declared for the \g{out} and \g{inout} affixes, and this array. containing
these affixes in their original order, is passed as the last parameter.
Before returning, the called routine should supply the output values in this
array, which values will then be stored by the caller.

Rules with a variable affix block have two additional parameters: an
integer containing the number of blocks (with value
at least one), and an integer array containing all affixes in the variable
block regardless of their type. The \pp|shift affix block| rule is
implemented by decreasing the block counter by one, and adding the block
length to this parameter. The following list shows some \g{formal affix
sequence} and the corresponding {\sf C} parameter declaration:

\smallskip

\begin{tabular}{ll}
\pp|+t[]+>i|   & \pp|(int t,int i)|              \\
\pp|+""f+o>|   & \pp|(int f,int A[1])|\\
\pp|+>i>+o>|   & \pp|(int A[2])|\\
\pp|+>io>+*+>i| & \pp|(int A[1],int Cnt,int *V)|\\
\end{tabular}

\smallskip
\noindent
The called routine must set all out affixes in the output parameter
\pp|A[]|, and otherwise it is free to change (and use) these values
if the routine fails. Values corresponding to not out or inout affixes
in the variable block \pp|V[]| should never change, and the value 
of an inout affix should be changed only if the routine returns with success.

\subsection{Externals}\label{subsec:externals}

External declarations are allowed in library mode only (Section
\ref{subsec:library}). How the \g{string denotation} in the external declaration
is interpreted depends on the type of the defined tag.

\subsubsection{External constant and variable}

Both external constants and variables can be used. External constants cannot
be used in expressions or any other place where a constant tag is required.
In the {\sf C} code every occurrence of these tags is replaced by the
string.

\subsection{External table and stack}

A list structure is reserved in the global integer array \pp|a\_DATABLOCK|
as explained in Section \ref{subsec:tables-stacks}. The string in the
external declaration is used as a {\sf C} procedure which is responsible to
initialize this structure. It will be called with two arguments: the index
of the associated structure and the calibre of the list. The routine must
fill the actual and virtual limits. There is a (small) virtual address 
space put apart
for external lists. The first free address is in 
\pp|a\_extlist\_virtual|, and can use addresses up to \pp|max int|.
The routine should update this value to reflect its reservation. The routine
is also responsible to allocate memory and initialize the content of
external tables.

\subsection{External files}

The corresponding charfile or datafile structure is reserved in the global
array \pp|a\_DATABLOCK|. For the description see Sections
\ref{subsec:datafile-implement} and \ref{subsec:charfile}. The string in the
external declaration is used as a {\sf C} procedure which is responsible to
initialize the structure. The procedure is called with a single argument:
the index of the structure.

\subsection{External rules}

How an external rule is handled depends on the \g{string denotation}. If the
it starts with a letter (either lower or upper case), then the external rule
is assumed to be a {\sf C} procedure with exactly the same  parameter
passing mechanism as the compiled rules. The compiler generates a
prototype with the correct parameter setting; the {\sf C} routine
implementing the external rule can be compiled and linked independently.
Several standard library rules are implemented this way.

If the first character in the external rule's \g{string denotation} is not a
letter, then a simpler calling mechanism is used: all affixes, independently
of their types, are given as parameters. These external rules are typically
{\sf C} macros; an example is the \pp|incr+>x>| external rule whose
\g{string denotation} is \pp|\_\_incr|, thus the \A{} rule call \pp|incr+ptr|
translates to \pp|\_\_incr(ptr)|. The standard header file contains the
{\sf C} macro definition
\begin{program}
 \#define \_\_incr(x)   x++
\end{program}
\noindent
which makes the final translation.

The \g{dummy affix} translates to nothing, thus leaves an empty parameter
location. Using some {\sf C} preprocessor tricks these empty arguments can
be transformed to different {\sf C} procedure calls. To ease this work, 
the \A{} compiler makes some additional work.

If the external rule is a \emph{function} and all of its out arguments are
discarded, then this external rule is not called at all.

If the \g{string denotation} of the external rule starts with \pp|@|, then
this character is replaced by an underscore. For each out
argument either a \pp|0| or a \pp|1| character is appended to the rule
string depending on whether the out argument is the {\g dummy symbol} or
not. Finally, from the argument list all \g{dummy symbol}s are discarded.
In the standard library 
the \pp|divrem| external rule has two out affixes, and \pp|@divrem| as its
\g{string denotation}. Accordingly, four {\sf C} calls are generated:
\pp|\_divrem11| with four parameters when both the quotient and remainder is
used, the three parameter \pp|\_divrem01| and \pp|\_divrem10| when the
quotient (remainder) is discarded; and the two parameter \pp|\_divrem00|
when no result are requested at all.

\end{document}
