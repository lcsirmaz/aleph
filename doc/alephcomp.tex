\documentclass[titlepage]{article}
\usepackage{tikz}
\usepackage{url}
\usepackage[hidelinks,bookmarks=fales]{hyperref}
\hypersetup{
   pdfauthor={L.Csirmaz},
   pdftitle={Aleph compiler, v2.1}
   bookmarksopen=false,
   pdfkeywords={compiler, programming language, parser, Aleph, }
}

\newcommand\A{\textsf{ALEPH}}
\newcommand\I{\textsf{ALICE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% grammar is typeset in \sf font.
\newcommand\g[1]{\textsf{#1}}
\newcommand\no[1]{}
\def\cc{\kern-0.6pt:\kern-1pt:\kern-0.5pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewenvironment{itemize}{\begin{list}{}{%
\advance\leftmargin by -8pt%
\setlength\itemsep{0ex plus 0.2ex}%
\setlength\partopsep{3pt}%
\setlength\topsep{2pt plus 2pt}%
\setlength\parsep{0pt plus 2pt}%
}}{\end{list}}

\renewenvironment{enumerate}{\begin{list}{\labelenumi}{%
\usecounter{enumi}\def\makelabel##1{\hss\llap{##1}}
\advance\leftmargin by -10pt%
\setlength\itemindent{0pt}%
\setlength\itemsep{0.4ex plus 0.2ex}%
\setlength\partopsep{3pt}%
\setlength\topsep{2pt plus 2pt}%
\setlength\parsep{0pt plus 2pt}%
}}{\end{list}}

%\makeatletter
\renewcommand\labelenumi{\theenumi)}
%\makeatother
\newenvironment{deflist}[1][30pt]{\begin{list}{}{%
\advance\leftmargin by -8pt%
\setlength\itemsep{0ex plus 0.2ex}%
\setlength\partopsep{3pt}%
\setlength\topsep{2pt plus 2pt}%
\setlength\parsep{0pt plus 2pt}%
\setlength\itemindent{#1}%
\advance\labelwidth\itemindent%
}}{\end{list}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% program listing is done using lmtt fixed font
%%   words within '' are typeset in bold
%%   disabling '' and ,, and << >> ligatures.
\DeclareFixedFont{\tt}{T1}{lmtt}{m}{n}{10pt}
\DeclareFixedFont{\tft}{T1}{lmtt}{m}{n}{8pt}
\DeclareFixedFont{\bt}{T1}{lmtt}{b}{n}{10pt}
%% \mkbold sets space, comma, apostrophy active
%%   and words between '' to be typeset in bold
%% \pp|text| is an inline program
%% \begin{program} ... \end{program} is a displayed program
\newdimen\programindent\programindent=8pt
{\catcode`\'=\active\catcode`\ =\active\catcode`\,=\active%
\catcode`\$=12\catcode`\<\active\catcode`\>\active%
\gdef\mkbold{\catcode`\'\active\def'##1'{\char39\relax{\bt##1}\char39\relax}%
\catcode`\,\active\def,{\char44\relax}%
\catcode`\<\active\def<{\char60\relax}%
\catcode`\>\active\def>{\char62\relax}%
\catcode`\$=12\catcode`\#=12\catcode`\^=12%
\catcode`\ \active\def {\nobreakspace}}}
\newenvironment{program}{%
\ignorespaces
\par\vskip 3pt plus 2pt minus 2pt\par
\parindent=0pt\tt
\catcode`\$=12\catcode`\^=12
\mkbold
\obeylines
\leftskip \programindent
\baselineskip=0.9\baselineskip
\everypar\expandafter{\the\everypar\unpenalty}%
}{\vskip 2pt plus 2pt minus 2pt\par\ignorespaces}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\catcode`\'=\active\catcode`\ =\active\catcode`\,=\active\catcode`\_=\active%
\catcode`\$=12\catcode`\^=12\catcode`\|=\active\catcode`\<\active\catcode`\>\active%
\gdef\pp#1{\relax\begingroup
\catcode`\$=12\catcode`\~=12\catcode`\^=12%
\catcode`\|\active\let|\endgroup
\catcode`\ \active\def {\space}%\nobreakspace
\catcode`\'\active\def'##1'{\char39\relax{\bt##1}\char39\relax}%
\catcode`\_\active\def_{\kern 0.03em\rule{0.3em}{1pt}\kern 0.03em}%
\catcode`\<\active\def<{\char60\relax}%
\catcode`\>\active\def>{\char62\relax}%
\catcode`\#=12\catcode`\^=12%
\tt
}%
}
{\catcode`\[=\active\catcode`\]=\active\catcode`\*=\active%
\gdef\mkoptions{\catcode`\[\active\def[{\kern0.05em\char91\kern0.12em\relax}%
\catcode`\]\active\def]{\kern0.1em\char93\kern0.05em\relax}%
\catcode`\*\active\def*{\kern 0.05em\raisebox{-0.5ex}{\char42}\relax}
}}%
\newenvironment{grammar}{%
\begin{list}{}{%
\setlength\leftmargin{18pt}%
\setlength\rightmargin{-5pt}%
\setlength\listparindent{20pt}%
\setlength\itemsep{1pt plus0.2ex}%
\setlength\parsep{0pt plus 2pt}%
\setlength\labelsep{-5pt}%
}\sf\mkoptions%
}{\end{list}}
\def\remark#1{{\normalfont #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subsection title font
\makeatletter
\renewcommand\subsection{%
\@startsection{subsection}{2}{\z@}%
   {-3.25ex\@plus -1ex \@minus -.2ex}% {3.25ex \@plus1ex \@minus.2ex}
   {1ex \@plus .5ex}%             {-1em}
   {\normalfont\normalsize\bfseries}}
\renewcommand\section{%
\newpage
\@startsection{section}{1}{\z@}%
   {-1pt}%
   {4ex plus 1ex minus 1ex}%
   {\normalfont\Large\bfseries}}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hyphenation{name-space}
\long\def\ignore#1\endignore{}

\let\osection\section

\def\section {\newpage\osection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\bf Aleph Compiler v2.1}
\author{L. Csirmaz}
\date{\normalsize Document version 2.1, November 2024}

\begin{document}
\thispagestyle{empty}
\maketitle
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preface}

The early 1980's saw a proliferation of computer programming languages. Only a
few of them survived and even fewer are in use today. The programming
language \A, an acronym for {\sf A} {\sf L}anguage {\sf E}ncouraging {\sf
P}rogram {\sf H}ierarchy, almost completely disappeared, and this work is an
attempt to resurrect it.

As a programming language \A{} has many interesting features even by today's
standards. Designed by D.\,Grune, R.\,Bosch and L.\,G.\,L.\,T.\,Meertens in
the Mathematisch Centrum, Amsterdam \cite{A-manual}, its purpose was to
offer a language which is ``suitable for any problem that suggests top-down
analysis (parsers, search algorithms, combinatorial problems, artificial
intelligence problems, etc).'' \A{} compilers have been constructed for a
wide range of computer architectures (which had a much larger variety at
that time), and these compilers generated efficient and succinct code, which
was an important requirement those days \cite{grune}.

\A{} is a direct descendant of another extinct language, \g{CDL}, standing
for {\sf C}ompiler {\sf D}escription {\sf L}anguage. \g{CDL} was designed by
C.\,H.\,A.\,Koster \cite{koster1,koster3} as a tool for writing compilers
for a wide variety of programming languages and target machines. There had
been some more recent work on descendants of \g{CDL} \cite{cdl3}. Both \A{}
and \g{CDL} belong to the family of the few languages based on affix, or
two-level, or van Wijngaarden, grammars \cite{koster2,wijn}. Affix grammars
were developed to provide a formal definition of what an \g{ALGOL68} program
is \cite{a68}. The appealing intuitive meaning of an affix grammar
definition combined with the theoretical simplicity and completeness led
soon to practical applications. A common feature of those programming
languages is that grammatical symbols are interpreted as procedures
returning either true or false depending on whether a token sequence
derivable from the grammatical symbol has been recognized or not.
\emph{Affixes} of the grammatical symbols carry additional contextual
information, and behave as (both input and output) parameters of the
procedure. Affix values typically come from another, very restricted
language.

\g{CDL}, and its successor, \g{CDL2} was a popular and widely used compiler
writing tool. It is worth noting that the first generation \g{PROLOG}
compilers were written exclusively in these languages. \g{CDL} provides a
global logical framework and organizes the data flow among the rules without
specifying neither the primitives nor the affix values. While keeping the
main design ideas and syntax closely resembling that of the original
\g{CDL}, \A{} closed this open endedness by specifying the available
data types and fixing the data manipulating primitives.

The unusual \emph{call-then-store} procedure execution mechanism of \A{} is
inherited from \g{CDL}. Output parameters (affixes) are local for the called
procedure during execution, and are copied back to their destination only
after a successful return. Other features unique to \A{} are modeling the
virtual memory as a huge sequence of computer words where stacks and tables
occupy consecutive positions whose exact location is outside the control of
the programmer; handling character strings as black boxes without direct
access to its constituents; and datafiles which allow automatic transfer of
stack and table pointers from one program to another. By design, no
uninitialized memory location exists in \A, which automatically avoids many
hard to discover bugs.

The original version of \A, as defined in the Aleph Manual \cite{A-manual},
treats the compiled program as a single stand-alone text---complying to the
practice of the time when the language was designed. The present version
adds modules by exploiting and expanding the \g{pragmat} construct
resembling the \g{CDL2} approach. There are several other extensions,
changes and restrictions compared to the original specification, hopefully
all of them in the spirit of the original design of the language.

\smallskip

In this implementation both the compiler and the linker are written in \A,
and the target language is standard {\sf C}. Both the \A{} source and the
translated {\sf C} programs are available at
\begin{center}
\url{https://github.com/lcsirmaz/aleph}
\end{center}

\vskip 20pt

\noindent
Budapest, Hungary \hfill Laszlo Csirmaz

\noindent
Prague, Czech Republic

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{A bird's eye overview of Aleph}\label{section:overview}

The \A{} manual \cite{A-manual} is an excellent introduction to the language
and its usage. It is written for novice programmers who have no or little
experience. This section contains a concise description focusing on the main
differences between \A{} and modern programming languages.

By design, an \A{} program can be considered to be a top-down \g{LL(1)}
parser\cite{aho-ullman}. \A{} procedures are called \emph{rules}, and return
either \emph{success} or \emph{failure}, implying whether a derived instance
of the rule has been recognized (and processed) or not. To enhance the
expressive power of context-free parsers, \A{} rules can be equipped with
\emph{affixes}. Affixes carry auxiliary, context sensitive information. The
syntax of \A{} follows the tradition of affix grammars \cite{wijn} by using
the \pp|+| sign to separate the procedure (rule) name and parameters
(affixes).


\subsection{Data types}

The basic data type of \A{} is the \emph{word}, which is the storage unit in
the target machine. A word can be considered either as a bit sequence
interpreted as a signed integer value, or as a pointer which determines a
location in the virtual memory. The virtual memory is a sequence of words
indexed by words, and is populated partially only by \g{table}s and
\g{stack}s, jointly named \emph{list}s. Tables and stacks occupy disjoint
(and far away) segments of the virtual memory. A stack can grow and shrink
at its upper end, and shrink at its lower end, while the position and size
of tables are fixed and never change. Pointers can only point to a table or
stack element (and not to a variable), and a pointer value determines
uniquely the list it points into. Elements of a \g{stack} can be modified
(but not their virtual addresses), while elements of a \g{table} are ``read
only'' and do not change.

Consecutive locations in a \g{table} or in a \g{stack} can be grouped
together either to a fixed size \emph{block} or to a \emph{string}. Such a
group is pointed to by its last (topmost or rightmost, having the largest
address) element. Elements in a block are identified relative to its address
by \emph{selectors}. A \g{stack} is extended by specifying the elements of a
new block using its selectors, and the block is added to the top of the
stack, extending its actual range.

Strings are also stored at consecutive locations of a list, and behave like
black boxes and can be manipulated by predefined routines only, see Section
\ref{subsec:bird-ext}. This way \A{} does not determine how characters in a
string are stored, allowing compressed storage of a large character set.
Strings can be unpacked to a list of characters, and a list of characters
can be packed into a string which is pushed to the top of a stack.

There are no uninitialized global or local values in an \A{} program.
Variables and lists are initialized when they are declared; and a stack can
be extended only by supplying all values for the extension.

Finally, for communicating with the outside world, \A{} distinguishes
character and data files. Files can be opened and closed, character files
can send and receive characters. In a data file each entry is marked as
either a word or as a pointer to one of the lists associated with the file.
While reading, pointer values are automatically adjusted, which allows an
automatic transfer of pointers from one \A{} program to another.

\subsection{Rules and calling a rule}

In \A{} parlance procedures are \g{rule}s, and its parameters are
\g{affix}es. When writing a call affixes are added to the called rule
identifier using \pp|+| signs as in
\begin{program}
    rule + affix1 + stack + file + -42.
\end{program}
\noindent
Each actual affix is either a word (a constant, a variable, or an indexed
list element), a list (stack or table), or a file. No compound affixes
(e.g., expressions) are allowed. A rule either returns a logical value or
returns nothing, while it can have several ``out'' affixes for returning
computed values. The required affix types are specified in the head of the
rule declaration as
\begin{program}
   rule + >affix1> + []stack[]+ ""file + >affix2
\end{program}
\noindent
The first affix \pp|affix1| both receives and returns a word value; the
second affix is a stack, the third one is a file, finally \pp|affix2|
receives a word value but does not return anything (and the rule body can
use \pp|affix2| as a local variable).

The control flow in the rule body is quite restricted: it is a sequence of
alternatives probed in the order of their presence. An alternative is a
sequence of members guarded by its first member. If this first member
succeeds, the alternative is chosen and the remaining members are executed;
otherwise the next alternative is probed. Jumps are allowed only as an
abbreviation for tail recursion. There are no repetitive statements at all,
iteration must be handled by recursion. Next to rule calls a member can be a
\g{compound member} or an \g{extension}. The compound member is an
(implicit) rule definition enclosed in parentheses, while an extension adds
a block of specified number of values to the top of a \g{stack}.

Due to its simplicity, the control flow inside a rule is tractable.
Liveliness and reachability properties can be checked statically during
compilation. In particular, the \A{} compiler checks statically that in a
rule
\begin{itemize}
\item[\textbullet] all members are reachable;
\item[\textbullet] the flow can always reach a return point;
\item[\textbullet] when a local variable or parameter is used it has an
  assigned value (it is not ``uninitialized'');
\item[\textbullet] an out parameter has been assigned a value along all paths
 ending in a return point;
\item[\textbullet] if a local variable (or parameter) has been assigned a
value, it is actually used.
\end{itemize}

\subsection{Externals}\label{subsec:bird-ext}

Basic data manipulation, such as addition, comparison of words (as
integers), and similar operations are done by standard external rules. As
an example, \pp|incr+x| increases the value of its argument by one;
\pp|equal+x+y| tests for equality, returning \emph{success} if \pp|x| and
\pp|y| are equal, and \emph{failure} otherwise. Some externals have
equivalent syntactic variants, such as the assignment (called \g{transport}
in \A) \pp|make+src+dest|, which can also be written as \pp|src->dest|, or
\pp|equal+x+y|, which can also be written as \pp|x=y|.

All file operations are also done by externals. Standard external are used
for some stack operations (such as shrinking), and for manipulating strings.
Externals can be redefined; this feature allows to mimic overloading the
basic operators, for an example see Section \ref{subsec:redef-library}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Prototypes, modules and libraries}

The \A{} Manual \cite{A-manual}, the official definition of the language,
has several revisions. All of them were published by the Mathematisch
Centrum, Amsterdam, between 1974 and 1982. Implementations of a computer
language frequently add new features, while restrict or leave out others.
This happened with \A{} as well; changes in the \A{} manual reflect the
evolution as new applications and new compilers appreared. The present
implementation, and usage, of the \A{} language is no exception. Making
modular programming possible---as opposed to monolith programs
prevalent at the time of the inception of \A---required new features. Other
extensions and restrictions came naturally; some of them date back to the
time of the first \A{} compilers. All changes made in this implementation
hopefully respect the original design ideas and philosophy as described in
\cite{grune}. For a more detailed description of the changes and new features see
Section \ref{sec:changes}.

\subsection{Prototypes}

The original \A{} specification has no prototypes, but prototypes are
indispensable when the program is split into smaller modules which are
compiled independently. Each module should have complete information on all
program constructs (rules, variables, lists, etc.) it imports, and should
provide that information on constructs it exports. Prototypes, the stripped
down declaration heads, are just the right constructs for this purpose.

\subsection{Modules}\label{subsec:general-modules}

An \A{} module provides certain resources to the main program and to other
modules, and is compiled independently. A module (or the main program)
can \emph{require} resources provided by other modules, and a module can
\emph{provide} resources defined within it. Accordingly, an \A{} module is
split into a \emph{public} and a \emph{private} part. The public part
specifies the provided items using prototypes, while the private part
contains the realization of those resources. When the module is required,
only the public part is scanned. When the module is compiled, both the
public and private parts are processed, thus the compiler can check that all
items this module promises to export are indeed provided by its private
part.

The public part of a module may contain genuine declarations next to the
list of export prototypes, and may require additional modules. These public
declarations are compiled into the invoking program locally.

If an \A{} module, say \pp|modA|, requests another module, say \pp|modB|,
then the terminology ``\pp|modB| is directly visible from \pp|modA|'', or
``\pp|modB| is immediately above \pp|modA|'' is used. The module \pp|modB|
is \emph{above} \pp|modA| if there is such a visibility chain from \pp|modA|
to \pp|modB|. Resources provided by a module are available to every other
module which are below it, except for those resources which are redefined by
some intermediate module. The original resource can still be reached using
\emph{qualifiers}. In general, the same resource can be provided by several
visible modules, in which case the module with the smallest rank (that is,
the smallest number of hops in immediate visibility) is chosen as the
provider.

Requested modules are processed only once, thus no special measures should be
taken when the visibility is circular. This is the case, for example, when
module \pp|modA| requires \pp|modB|, and module \pp|modB| requires
\pp|modA|. For a more detailed description on \A{} modules see Section
\ref{section:module}.
 
\subsection{User libraries}\label{subsec:user-library}

An \A{} module can be designated as a \emph{user library}. Resources
provided by such a library module are available to all non-library modules,
but only as a last resort if no other definition was found.

In general, resources provided by a plain module \pp|modA| are not
automatically avaiable for all other modules: \pp|modA| must be required
explicitly (possibly through a request chain). In contrast, designating
\pp|modA| as a user library, any module can use resources provided by
\pp|modA| without requesting it. A user library can request other modules;
these requests determine another visibility structure which is independent
of, and above, the visibility structure of the plain modules. Resources
provided by the collection of user libraries are those provided by the
lowest rank modules in the library visibility structure.

There is another library layer above the user libraries starting with a
single \emph{standard} \A{} \emph{library} module. This extra layer provides
the implementation of basic \A{} primitives as required by the Manual
\cite{A-manual}. Consequently, a user library module can use (and redefine
transparently if it chooses so) these primitives without any further
arrangements.
 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Enhancements and changes}\label{sec:changes}
\def\HH{\noindent\hbox to 0.25\linewidth\bgroup\hskip\programindent}
\def\HE{\hss\egroup}


This extensive section describes the main changes between the implemented
language and the language specified in the \A{} manual \cite{A-manual}. The
description assumes a basic level familiarity with the \A{} language.

% ----------------------------------------------------------------------

\subsection{Program text representation}

\A{} is an Algol-like language \cite{a68} in which keywords are distinguished by a
different typeface. Practical coding, however, uses a single (monospace)
typeface. There are several approaches to distinguish keywords from the
surrounding text but none of them is perfect. This implementation requires
keywords to be enclosed between apostrophe characters such as in this
example:
\begin{program}
'variable'x=0.
'root'print int+STDOUT+x.
'end'
\end{program}
\noindent
Other possibilities are: using capital letters for keywords (as in several
{\sf PASCAL} implementations); restricting keywords (as in {\sf C} and
related languages); using an initial escape character and whitespace at
the end (e.g., leaving out the closing apostrophe); and so on. This choice
reflects the influence of {\sf ALGOL \!68} \cite{a68} on \A{} and on its relatives.

Characters in \A{} are not necessarily restricted to single byte ones as
strings cannot be manipulated directly. This implementation allows any
unicode character as a string character. According to the \A{} Manual
\pp|newline| and \pp|newpage| are not characters. This implementation
relaxes this restriction. A newline character (with code \pp|10|) can be
part of a string, but not of a \g{string denotation} (a string appearing in
the program text). In the program text all strings should be closed in the
same line they start. Two separate consecutive strings (even if they are on
different lines) are concatenated, thus strings can be continued on the next
line, but cannot contain newline characters. There are no escape characters
either, and presenting a quotation mark in the string it should be doubled
forming a \g{quote image}. Thus

\smallskip

\HH\pp|"a" "b"| \HE is a concatenation and has two characters: \pp|/a/| and
\pp|/b/|;

\HH\pp|"a""b"|  \HE has three characters: \pp|/a/|, \pp|/"/| and \pp|/b/|.

\smallskip
\noindent
A character written between slash characters represents its unicode value,
in particular the code for the slash character is written as \pp|///|.
 

\subsection{Hexadecimal constants}

Wherever an \g{integer denotation} is accepted, hexadecimal constants are
recognized and accepted as well. An example is \pp|0x1234abcd|. The
minus sign can also appear before a hexadecimal constant: \pp|-0xffff|.

% ----------------------------------------------------------------------

\subsection{Relations}\label{subsec:relations}

The external rule \pp|equal+x+y| tests for equality of \pp|x| and \pp|y|.
The same test can be written equivalently as the \g{relation} \pp|x=y|.
Similar shorthands are added for other comparison operators:

\smallskip

\HH\pp|x!=y| and \pp|x-=y|\HE  for \pp|x| and \pp|y| differ;

\HH\pp|x<=y|\HE               for \pp|x| is less than or equal to \pp|y|;

\HH\pp|x<y|\HE  for \pp|x| is smaller than \pp|y|;

\HH\pp|x>y|\HE  for \pp|x| is greater than \pp|y|;

\HH\pp|x>=y|\HE for \pp|x| is greater than or equal to \pp|y|.

% ----------------------------------------------------------------------

\subsection{Lists in scalar context}\label{subsec:list-in-scalar}

In an actual affix position where a single word is required, a list \pp|L|
(a \g{table} or \g{stack}) can also appear with the meaning that the value
it represents is that of its topmost (rightmost) element, namely,
\pp|L[>>L]|. The same abbreviation can be used with selectors. Thus the
rule call
\begin{program}
add + a*L + b*L + c*L
\end{program}
\noindent
is equivalent to
\begin{program}
add + a*L[>>L] + b*L[>>L] + c*L[>>L].
\end{program}
\noindent
Using this extension a stack looks---and behaves---like a variable, which
makes writing and comprehending stack operations easier.
%
This extension comes handy when the content of a newly added block on
the top of a stack is to be manipulated. The drawback is that it
prevents the compiler reporting a parameter type mismatch when the list is
used by mistake. This extension causes, quite unexpectedly, extra
complications during macro substitution, see Section \ref{sec:macro} for
details.

%------------------------------------------------------------------------

\subsection{Dummy affix}\label{subsec:dummy}

When the value of an out formal affix is not needed (the value is thrown
away), rather than forcing the programmer to invent some dummy variable, the
\g{dummy symbol} can be used with the meaning that the returned value will
not be used. This implementation encourages the character \pp|\#| for this
purpose, while the official representation \pp|?| is also accepted.

% ----------------------------------------------------------------------

\subsection{String as actual affix}

A \g{string denotation} can be used as an actual affix. This extension
simplifies writing program texts as the actual string can appear where it is
used. Without this feature strings are to be put into a table with a pointer
constant pointing to them, and then the string is identified by the table
name and the string pointer together:
\begin{program}
'table'MESSAGE=("unknown identifier":unknown tag).
'action'tag error:error+MESSAGE+unknown tag.
\end{program}
\noindent
With this extension the string can appear directly as an actual affix:
\begin{program}
'action'tag error:error+"unknown identifier".
\end{program}
\noindent
The string denotation translates into two affixes: first,
a special internal table, and second, a pointer which points to the string in
that table.

% ----------------------------------------------------------------------

\subsection{Manifest constants}

Manifest constants start and end with an underscore, and are replaced either
by an integer or by a string while scanning the source text. In particular,
they are replaced before macro substitution, thus \pp|_line_| and
\pp|_rule_| in a macro text reflects the source line of the macro definition
and the macro name, and not those of the invoking rule. Similarly,
\pp|_title_| and \pp|_module_| expands to the empty string if they appear
before the corresponding \pp|title| or \pp|module| pragmat.

\smallskip

\def\HH{\noindent\hbox to 0.2\linewidth\bgroup\hskip\programindent}
\HH \pp|\_line\_|\HE integer, the source line number this constant appears
in

\HH\pp|\_file\_|\HE string, name of the source file

\HH\pp|\_module\_|\HE string, module name as set by the \pp|module=...| pragmat

\HH\pp|\_title\_|\HE string, the title as set by the \pp|title="..."| pragmat

\HH\pp|\_rule\_|\HE string, the rule name if used inside a rule definition.

% ----------------------------------------------------------------------

\subsection{Extension syntax}

An \g{extension} adds a new block to the top of a (formal or global) stack.
An extension is specified as a sequence of assignments where the
destinations are selectors of the block to be added; this list is enclosed
between \pp|*| symbols and followed by the list tag. If the \g{stack}
\pp|st| has three selectors \pp|sel|, \pp|ect|, and \pp|ors|, then the
\g{extension}
\begin{program}
  * pnt->sel, 0->ect->ors * st
\end{program}
\noindent
extends \pp|st| with a block of three elements. To make the extensions
visually more appealing, parentheses can be inserted as follows:
\begin{program}
  (* pnt->sel, 0->ect->ors *) st
\end{program}
\noindent
Accepting both extension forms destroys the \g{LL(1)} property of the \A{}
syntax. It is so as a \pp|(*| sequence can be either the start of an
\g{extension}, or that of a \g{compound block} which has an \g{extension} as
its first \g{member}. This compiler solves this problem by doing a
reasonable amount of look-ahead.

% ----------------------------------------------------------------------

\subsection{Variable number of affixes}

Allowing and handling a variable number of rule affixes is one of the
main achievements of this implementation. Variable number of affixes raises
several problems, and poses a potential obstacle for control flow
tractability. The used approach meets the following two main requirements:
it provides a flexible and usable variable argument mechanism, while keeping
all tractability properties of an \A{} program. This is achieved by
restricting how the ``invisible'' affixes in a variable affix block can be
accessed.

A \g{formal affix sequence}, which defines the arguments of a \g{rule}, may
contain the \g{anchor symbol} \pp|@| indicating the position from which
point affixes to the right end of the list can be repeated indefinitely in a
call to this rule. The declaration of \pp|sum| in the snippet

\begin{program}
'function'sum+a>+@+>b+>c:
  0->a,(nxt:add+a+b+a,add+a+c+a,
            (shift affix block+@,:nxt;+)).
\end{program}

\noindent
has the single out affix \pp|a|, and two input affixes \pp|b| and \pp|c|,
the latter two forming the \g{repeat block}. Invoking this rule requires
three, five, seven, and so on actual affixes. The first three of the actual
affixes are matched against the formal affixes \pp|a|, \pp|b|, and \pp|c| in
this order. The rule body starts by setting \pp|a| to zero. The \pp|add|
rules after the label \pp|nxt| add \pp|b|
and \pp|c| to \pp|a|. The built-in routine \pp|shift affix block| shifts out
the visible affix block at \pp|b| and \pp|c| and moves the next block into
this place, assuming that there is still a pending, unseen block. If there is
none, the rule \pp|shift affix block| fails, and \pp|sum| ends. Otherwise a
jump is made to the label \pp|nxt|, where the next group of two input
affixes are added to \pp|a|. In summary, \pp|sum| adds up all of its input
arguments and returns their sum in \pp|a|.

The main point which guarantees the tractability of the data flow is that
shifted out blocks are lost to this rule, and there is no way to reach
the affixes there.

In a rule call the anchor symbol \pp|@| can appear only as the last actual
affix with the meaning that the present (visible) and all subsequent
(pending) affix blocks of the calling rule are passed as arguments. The rule
\pp|negate| defined as
\begin{program}
'function'negate+a>+@+>b+>c-z:
   add+b+c+a,(shift affix block+@,sum+z+@,subtr+a+z+a;+).
\end{program}
\noindent
adds up the first two of its input affixes \pp|b| and \pp|c|; if there are
no more affixes, then this sum is the result. Otherwise, it calls \pp|sum|
to add up the value of the rest affixes, and then subtract it from the sum
of the first two. Thus the calls
\begin{program}
 negate+x+3+4, negate+y+3+4+0+1, negate+z+3+4+0+1+x+y
\end{program}
\noindent
put 7 to \pp|x|, 6 to \pp|y|, and $-7$ to \pp|z|.

The built-in routine \pp|get affix blockno+n>+@| returns the number of
pending affix blocks. This number is always positive and it is
\pp|1| if and only if \pp|shift affix block+@| would fail.

The main application of variable number of arguments is formatted printing.
In \A{} the compiler this feature has been used mainly to format error messages,
but it also turned out to be useful in code generation. Rudimentary
formatted printing can start with the format string passed by two affixes:
the table and the string pointer. Format characters starting with \pp|\%|
require a corresponding affix. When encountering a format char, the affix
list is shifted and the next argument, together with the format char, is
passed to the rule \pp|handle format char|, as is done in the program snippet
\begin{program}
'action'format print+T[]+@+>arg-fmt-n-ch:
  arg->fmt,0->n, $ fmt is the string pointer $
  (nxt:string elem+T+fmt+n+ch,incr+n,
         ((ch=/\%/,string elem+T+fmt+n+ch,incr+n,
                                     shift affix block+@),
            handle format char+ch+arg,:nxt;
          put char+STDOUT+ch,:nxt);
       put char+STDOUT+newline).
\end{program}
\noindent
Another application could be pushing and popping an unspecified number of
elements to and from a stack. We remark that the rule \pp|pop| below works
correctly only when the stack has calibre (block size) one, as
\pp|unstack+st| discards a complete block and not a single element from the
stack, see Section \ref{subsec:list-block}. The
assignment \pp|st->x| stores the topmost element of the stack \pp|st| in
\pp|x| as discussed in Section \ref{subsec:list-in-scalar}.
\begin{program}
'action'push+[]st[]+@+>x:
   (* x->st *) st,(shift affix block+@,:push;+).
'action'pop+[]st[]+@+x>:
   st->x,unstack+st,(shift affix block+@,:pop;+).
\end{program}

Passing all affixes in the variable block can be used, e.g., to 
suppress low-level warning messages with a code similar to the one below:
\begin{program}
'action'warning+>level+T[]+>ptr+@+>msg:
   level<min level;
   format print+T+ptr+@.
\end{program}

% ----------------------------------------------------------------------

\subsection{Classification}\label{subsec:area}

A classification chooses exactly one of the possible alternatives based on
the value of a \g{source} included in the \g{classifier box}. An example is
\begin{program}
(= last*L[n] =
 [0;1],   action 1;  $ either zero or one\no$
 [-10:10],action 2;  $ range from -10 to 10\no$
 [L;1000],action 3;  $ either in L or equal to 1000\no$
 [:],     action 4)  $ everything else\no$
\end{program}
\noindent
The \g{area} in the square brackets determines whether the alternative
following it is chosen or not. An \g{area} may contain integer denotations
(decimal or hexadecimal), constant tags (including constant pointers) and
global (not formal) lists; no expressions are allowed. A global list stands
for its complete virtual address range. All values within the area are determined
during compilation. It is an error if some of the alternatives cannot be
reached (this would happen if the first two \g{area}s in the above example
are swapped); and the compiler gives a warning if it could happen that none
of the alternatives are chosen. When running the program and none of the
alternatives succeeds the program aborts with an error message. An
``otherwise'' case must be specified explicitly as in the example above.

% ----------------------------------------------------------------------

\subsection{Expressions}\label{subsec:expression}

In \A{} all \g{expression}s are evaluated during compilation. Originally
\g{expression}s could be used at several places; this implementation
restricts them to \g{constant} and \g{variable declaration}s only. It is not
an essential restriction as new constant tags can be declared with the
desired value whenever necessary.

An \g{expression} evaluates to a constant value. It may contain
constant tags declared later (or even in another module), but cannot depend
on itself. Thus
\begin{program}
'constant'a=b+2.
'constant'b=/a/.
\end{program}
\noindent
is accepted where \pp|/a/| is the value of character `\pp|a|' in the used coding, 
while
\begin{program}
'constant'p=q+1,q=1-p.
\end{program}
\noindent
gives an error message as the value of \pp|p| depends on itself.
%
In addition to the usual arithmetic operators \pp|+|, \pp|-|, \pp|*|, and  \pp|/|
the following Boolean operators can also be used:
\begin{itemize}
\item[\textbullet] \pp|~x| for the (binary) complement of \pp|x|,
\item[\textbullet] \pp|x\&y| and {\tt x|y} for the bitwise \g{and} and bitwise
\g{or},
\item[\textbullet] \pp|x^y| for the bitwise xor (modulo 2 addition) operator.
\end{itemize}
The Boolean operators have lower priorities than the arithmetic ones.

In an expression integer denotations (both decimal and hexadecimal),
character denotations (a character between \pp|/| symbols), constant tags,
pointer constants (defined in fillings), virtual bounds and block size
(calibre) can be used. List size estimates and repeat numbers (see Section
\ref{subsec:filling}) are evaluated before the virtual bounds are
determined, thus these values cannot depend on virtual bounds.

% ----------------------------------------------------------------------

\subsection{Root rule}\label{subsec:root-rule}

The only executable command of an \A{} program is its \g{root}.
It can have local affixes and a \g{rule body}. As the \g{root} is
executed only once there is no need to designate a separate rule for this
purpose. Example:
\begin{program}
'root'(rep:put line+STDOUT+V+newline,
         (next perm+<<V+V,:rep;+)).
\end{program}
\noindent
Roots of modules are executed before the root of the main program (see Section
\ref{section:module}), they can perform all necessary initialization for the
module. Modules which do not require initialization should use an empty \g{root}:
\begin{program}
'root'+.
\end{program}
\noindent
To control the order of module initializations, a module can call
 
\begin{program}
wait for+"xxx"
\end{program}
\noindent
to force the root of the indicated module \pp|xxx| to terminate before the
call returns. The \pp|wait for| rule aborts with an error message if two
modules would wait for each other producing a deadlock. The \pp|wait for|
rule requires the \emph{name} of the module (see Section
\ref{section:module}) specified as a string, and not the name of the file
containing the module text. If no module was linked with the given name,
the rule returns immediately. If there are more modules with the same
name, all those module roots are called.

% ----------------------------------------------------------------------

\subsection{Actual and virtual limits}\label{subsec:actual-virtual}

The complete \emph{virtual memory space}---the allowed range of indices---is
distributed among the tables and stacks with almost no control of the
programmer. These virtual bounds are fixed and hard-coded into the compiled
program. Pointers refer to a list element using its virtual address.
The virtual address space of different lists are disjoint, thus a
pointer uniquely identifies the list it points into.

A stack typically does not occupy its virtual space completely. Existing
locations (which correspond to locations in the machine memory) form a
presumably much smaller continuous \emph{actual memory space}. Stacks can be
extended to the right (upwards) until the end of their virtual memory parts,
or until there is enough physical memory available. They can shrink from the
right when their actual upper limits are lowered; the released virtual
memory can be reclaimed again. Stacks can also shrink from the left
(behaving like queues), but in this case the released virtual space is lost
(for the rest of the program run) and cannot be reclaimed again.

Thus the \emph{actual memory space} of a \g{stack} changes when the stack
is extended or shrunken For a list \pp|L| the constructs \pp|<<L| and
\pp|>>L| return the actual lower and actual upper bound of \pp|L|,
respectively. To obtain the fixed \emph{virtual} limits of the same list,
use \pp|<L| and \pp|>L| (with a single \g{left symbol} and \g{right
symbol}). In expressions only the fixed virtual limits can be used as only
these are available during compilation.

For \g{table}s the actual and virtual limits are always equal. In case of
\g{stack}s actual limits are always within the virtual limits. Fixed stacks
(i.e. stacks with an exact size estimate or no size estimate) have
equal actual and virtual limits.

% ----------------------------------------------------------------------

\subsection{Size estimate}\label{subsec:size-estimate}

The \g{size estimate} in a \g{stack declaration} specifies how much 
virtual address space this stack requires. The estimate is given between
square brackets, and can be \emph{fixed}, \emph{relative}, or
\emph{empty}. In the first two cases the limit must be either an integer
denotation or a constant tag; no expression is allowed.
\begin{itemize}
\item[\textbullet] Fixed size is written between \pp|=| symbols and the value
cannot be larger than 1,000,000 (and, of course, must be positive). The
compiler reserves at least that much virtual space for the stack. (The final
virtual space can be larger if the stack has fillings which total to a
larger amount.)

\item[\textbullet] A relative estimate should yield an integer between 1 and 100.
After reserving virtual addresses for \g{table}s and fixed size \g{stack}s,
the remaining virtual space is distributed proportionally to the requested
relative amount.

\item[\textbullet] If size estimate is left empty, the stack size (both
virtual and actual) is determined by the amount of its fillings (see Section
\ref{subsec:filling}). Such a stack can still shrink, but cannot expand
beyond its virtual upper limit.
\end{itemize}

% ----------------------------------------------------------------------

\subsection{Table declarers}

To distinguish \g{table declaration}s from prototypes and fillings (see
Sections \ref{subsec:prototype} and \ref{subsec:filling}, respectively), a
\g{table declaration} must contain an empty size estimate:
\begin{program}
'table'[](length,width)TBL,[]pi=(3,1,4,1,5,9,2,6).
\end{program}

% ----------------------------------------------------------------------

\subsection{List selectors}

Every \g{table} and \g{stack} has an associated \emph{block structure} which
determines the block size, called \g{calibre}, of that list, together with
the set of its \g{selectors}. When no selectors are specified, the block
size is 1 and the selector of that element is the name of the list -- the
\emph{standard selector}. In general, this standard selector is used
implicitly when the list is indexed without specifying a selector. If the
list definition has a selector list, then this list contains the block
selectors in a left to right order. The \g{formal stack} definition
\begin{program}
[](tag,left,right)tags[]
\end{program}
\noindent
specifies that the block structure of the formal affix \pp|tags| has
three elements with selectors \pp|tag|, \pp|left|, and \pp|right| in this
order. Also, the list \pp|tags| has no standard selector, namely a selector
with the name of the list. The \g{selector list}, if present, cannot be
empty, meaning it must contain at least one selector.

The same block element can be identified by different selectors. These
additional selector names are specified after the initial selector 
separated by an equal sign as in the \g{stack declaration}:
\begin{program}
'stack'[1](s1,s2=t1,s3=t2)stack.
\end{program}
\noindent
To emphasize which selectors are used together, multiple selector packs are
accepted. Each pack must have the same number of selectors, the
\g{dummy symbol} \pp|\#| can be used as a placeholder. Thus the previous
declaration can also be written as
\begin{program}
'stack'[1](s1,s2,s3)(\#,t1,t2)stack.
\end{program} 
\noindent
If a list was defined with selectors, then a matching prototype must also 
contain a selector list pack, while a filling may omit it, see Section
\ref{subsec:filling}. All selector packs must define the same block size
and the same standard selector, but could define different selector names
which accumulate: any of the specified selectors can be used.

% ----------------------------------------------------------------------

\subsection{Matching formal and actual lists}\label{subsec:list-block}

The block sizes of the formal and the actual lists are compared as follows.
\begin{itemize}
\item[\textbullet] The formal list has no selectors.

There is no restriction on the block size of the actual list. Observe, 
however, that in this case the standard selector of the formal and the 
actual list might be different. Suppose we have the rule declaration
\begin{program}
'action'set zero+[]st[]: 0->st.
\end{program}
\noindent
which sets the topmost element of the \g{stack} \pp|st| to zero. With the
declaration \pp|'stack'[1](L,b)L| the assignment \pp|0->L| clears the second to
last element of \pp|L|, while \pp|set zero+L| clears its last (topmost)
element.

\item[\textbullet]
The formal list has a selector pack.

The actual list must have the same block size and the same standard
selector, while selector names might be different. If this restriction
is violated, a warning is issued; if the called rule is a macro, then this
is an error.
\end{itemize}

% ----------------------------------------------------------------------

\subsection{Filling}\label{subsec:filling}

In addition to specifying the size estimate and the optional selectors, a
\g{table} or \g{stack declaration} may also define the initial content of
the list. This content can also be specified separately using
\emph{fillings}. Fillings can spread across the program (actually, can
spread across several modules). A list description (without size estimate),
followed by \pp|=| and a filling can appear multiple times across the
program. Fillings specified this way are accumulated. Their final order is
unspecified, but within a single filling the order of the added elements is
kept intact. The list description in the filling may contain a selector pack
only if the corresponding list is defined with selectors. If there is a
selector pack, both the block size and the standard selector must be the
same as in the definition; the selector names, however, can be different.

The \g{filling} itself is enclosed in parentheses, and is  a sequence of
integer denotations, constant tags (including constant pointers), strings,
and blocks; no expression is allowed. Each item, except for strings, can be
followed by the \g{repeat symbol} \pp|*| and either an integer or a constant
tag specifying how many times this item should be repeated. Then the
optional \g{pointer initialization} sequence follows: a colon and a
tag which is defined to have the value of the virtual address of the lastly
defined list item. The pointer initialization can be repeated. In the
example

\begin{program}
'constant'tsize=10.
'stack'T=(0*tsize:tzero:tz1,1*tsize,"string":tstring).
\end{program}

\noindent
the \g{filling} adds ten zeroes, ten ones, followed by the internal
representation of the string \pp|"string"| to \pp|T|. It also declares both
\pp|tzero| and \pp|tz1| to be the (virtual) address of the lastly added
\pp|0|, and \pp|tstring| to be the (virtual) address of the last element of
the representation of \pp|"string"| (which, if no further filling is added
to \pp|T|, is the same as \pp|>>T|).

In the \g{filling} a \g{compound block} defines the content of a list block.
The \g{compound block} must have exactly as many elements as the block size
(\g{calibre}) of the list; violating this requirement results in a warning.
A block element must be either an integer denotation or a constant tag
(possibly a pointer constant), but not a string. In the block the constant
value is followed by an \g{arrow symbol} \pp|->| and the selector where it
will be stored. The filling in the example

\begin{program}
'stack'[1](ch,p)optor=
    ( (/+/->ch,3->p),(3->p,/-/->ch),(5->p,/^/->ch) ).
\end{program}
\noindent
adds three blocks of size two each to the stack \pp|optor|. One of the
selectors can be replaced by the \g{repeat symbol} \pp|*| to mean that the
value is copied to all selectors not mentioned explicitly in this block.

The original block syntax is also accepted: the \g{compound block} of the
\g{filling} contains, in left to right order, the values (an integer
denotation or a constant tag) which should be added to the list. One of the
values can be followed by the \g{repeat symbol} \pp|*| with the meaning that
this element will be repeated as many times as necessary to fill the whole
list block. Example:

\begin{program}
'stack'(a,b,c,d,e,f,g,h)big block=( (1,0*,1)*100 ).
\end{program}

\noindent
adds 100 blocks to the stack \pp|big block|, each consisting of a \pp|1|,
six \pp|0|, and another \pp|1|. The block can also be written as
\pp|(1,0*6,1)|.

% ----------------------------------------------------------------------

\subsection{Exit rule type}\label{subsec:exit}

Executing the \g{terminator} \pp|'exit'16| causes the program to terminate
with exit value 16. The \pp|'exit'| statement is replaced internally by a
call of the external rule \pp|exit|, in this case it becomes \pp|exit+16|.
Consequently \pp|'exit'| must be followed by an \g{actual affix}, and not by
a constant \g{expression}.

In general, next to the four rule types \emph{predicate}, \emph{question},
\emph{action}, and \emph{function} specified by the \A{} Manual
\cite{A-manual}, a fifth one is added: \emph{exit}. A rule is of type
\emph{exit} if it never returns. The external rule \pp|exit| is of type
\emph{exit}, as well as the rule \pp|error| defined below which prints some
additional message before terminating the program:

\begin{program}
'exit'error+>x:
   x>=0,exit+0;
   put string+STDERR+"Exit level ",put int+STDERR+x,exit+1.
\end{program}

\noindent
An \g{exit} rule cannot have out or inout affixes as there is no way to use
the returned value. When an \g{exit} rule is defined, this condition is
checked. When such a rule is used, it is treated as a \g{terminator} which
can neither succeed nor fail. An \g{exit} rule has an implicit side effect
(aborts the program), thus it cannot be used in functions and questions.
Violating this restriction gives a warning message.

% ----------------------------------------------------------------------

\subsection{File area, file string}\label{subsec:datafiles}

\A{} distinguishes two file types: character and data. Character files
accept and write characters; in this version the used character set consists
of Unicode characters. During character transput there is an automatic
conversion from and to UTF-8 encoding. The \A{} program receives and sends
Unicode characters.

Data files communicate between different \A{} programs. Data files are
written and read one item a time; an item is either an integer (word) or a
pointer. The data file does not store pointer values directly, rather a pair
consisting of an indication of the list the pointer points to and the
relative address of the pointed item in that list. From this information the
pointer can be restored independently of the virtual address distribution. A
datafile declaration specifies all lists whose pointers can be transmitted.
By storing the virtual limits of these lists in the datafile first, each
additional item requires a single extra bit only specifying whether the item
is a pointer or not. When opening an \A{} data file for reading, stored
limits are paired with the lists in the file area so that the
appropriate pointer transformation can be made.

According to the \A{} manual, a \g{file declaration} can have an \g{area}
which restricts what values are allowed to send to or receive from that
file. This implementation does not allow \g{area}s for character files, and
the \g{area} of a datafile may contain only lists to which pointers
are sent to or received from. The order of the lists is significant:
when reading from a data file the first list in the area is matched to the 
first list when the file was written, and so on.

The \g{string denotation} and the direction (the \pp|>| symbol before and
after the string) in the file declaration is used as follows. Files can be 
opened by the external rule
\begin{program}
'a'open file+""file + >mode + t[]+>ptr.
\end{program}
\noindent
where \pp|mode| is \pp|/r/| for reading, \pp|/w/| for writing, and \pp|/a/|
for appending (for character files only); the last two arguments
specify the string containing the file name (with possible path information)
to be opened.

Without explicitly opening the file, the first file operation tries to open
it. The \g{string denotation} in the file declaration gives the file name
(with possible path information), and the \g{direction} restricts the
access: the file opens automatically for reading only if there is a \pp|>|
\emph{before} the string, and for writing if there is a \pp|>| \emph{after}
the path string. A file cannot be opened for reading and writing
simultaneously.

For a character file the following special filenames identify the standard
streams: \pp|<<stdin>>|, \pp|<<stdout>>|, and \pp|<<stderr>>|. Also, the
character files \pp|STDIN| and \pp|STDOUT| are declared in the standard \A{}
library. They can be used, without opening, to read from the standard input,
and write to the standard output, respectively.

% ----------------------------------------------------------------------

\subsection{Static stack and static variable}

\g{Variable}s and \g{stack}s can be declared to be \g{static} by adding the
\pp|'static'| keyword before their declaration. Examples:
\begin{program}
'static''variable'resources=0.
'static''stack'[=20=]values.
\end{program}
\noindent
Static variables and stacks behave identically to variables and stacks in
the module they are declared. In other modules, however, they are ``read
only'', which means that other modules cannot change the value of a
\g{static variable}, and cannot modify, extend, shrink, or manipulate
otherwise a \g{static stack}.

% ----------------------------------------------------------------------

\subsection{Prototype}\label{subsec:prototype}

A \g{prototype} informs the compiler about a type of an identifier. A
\g{table} or \g{stack prototype} has no size estimate and filling; a
\g{constant}, \g{variable}, \g{file prototype} has no data (or initial
value); a \g{rule prototype} has no \g{actual rule}. Prototypes are similar
to external declarations without the \pp|'external'| keyword and the string
denotation. Examples:
\begin{program}
'charfile'STDIN.
'action'print tag+>tag,read tag+tag>.
'constant'max tag pointer.
'stack'(\#,\#)STACK.
\end{program}
\noindent
Prototypes are also used to inform the compiler about tags which are defined
in other modules, and about tags which should be exported from this module.
See Section \ref{section:module} for more information.

% ----------------------------------------------------------------------

\subsection{Pragmats}\label{subsec:pragmats}

Pragmats control different aspects of the compilation. Their
semantics changed significantly compared to the \A{} Manual. This
implementation recognizes the following pragmats:

\def\HH{\noindent\hbox to 0.35\linewidth\bgroup\hskip\programindent}
\smallskip

\HH\pp|tab width=8| \HE sets tab size for program text printing

\HH\pp|list=on/off| \HE switch program text printing

\HH\pp|right margin=120| \HE right margin for program text printing

\HH\pp|dictionary=on/off| \HE collect tag occurrences

\HH\pp|warning level=4| \HE set warning level between 0 and 9

\HH\pp|error="message"| \HE issue an error with the given message

\HH\pp|warning="message"| \HE issue a warning at level 9

\HH\pp|bounds=on/off| \HE compile with or without index checking

\HH\pp|count=on/off| \HE profiling: count how many times a rule is called

\HH\pp|trace=on/off| \HE trace rule calls

\HH\pp|macro=rule|   \HE \pp|rule| should be treated as a macro.

\HH\pp|std library=off| \HE don't process the standard \A{} library

\HH\pp|define=tag| \HE mark \pp|tag| as defined for an \pp|ifdef| pragmat

\HH\pp|library mode=on/off| \HE switch library mode

\HH\pp|prototype=none| \HE specify how prototypes are handled (see Section
\ref{section:module})

\HH\pp|title="title"|  \HE specify program title

\HH\pp|module=tag|     \HE specify module name and namespace

\HH\pp|include="file"| \HE add \pp|file| to the sources to be read

\HH\pp|require="file"| \HE require module definitions from \pp|file|

\HH\pp|library="file"| \HE add \pp|file| as a user library module

\HH\pp|front matter="code"| \HE insert \pp|code| to the front of the
generated code

\HH\pp|back matter="code"| \HE insert \pp|code| to the end of the generated
code

\smallskip
\noindent
There are additional pragmats which cannot be manipulated in the program
text. The most notable one is \pp|compile|, which can be either \pp|on| or
\pp|off|. Some pragmat values can be interrogated by conditional pragmats, 
see Section \ref{conditional}.
%
Command-line arguments starting with a double dash, such as \pp|{-}{-}XX=YYYY|
are parsed as 
\begin{program}
\pp|'pragmat'XX=YYYY.|
\end{program}
\noindent
except that no conditional pragmats (Section \ref{conditional}) are
accepted. There are other command-line pragmat shorthands starting with a 
single dash:

\smallskip

\HH \pp|-l| \HE \pp|list=on|

\HH \pp|-d| \HE \pp|dictionary=on|

\HH \pp|-W| \HE \pp|warning level=3|

\HH \pp|-Wall| \HE \pp|warning level=0|

\HH \pp|-D TAG| \HE \pp|define=TAG|

\HH \pp|-m XXXX| \HE \pp|require="XXXX"|

\HH \pp|-y XXXX| \HE \pp|library="XXXX"|

\HH \pp|-o XXXX| \HE specify the output file

\HH \pp|-I XXXX| \HE search directories

\HH \pp|-L XXXX| \HE standard library directory

\smallskip
\noindent
The \pp|-o| option specifies the name of the generated \texttt{.ice} file.
If missing, the \pp|.ice| file name is derived from the first
source file, and generated in the current directory. The \pp|-m| option
marks the following file to be processed as if it were required; the \pp|-y|
option marks the file to be processed as a user library. The \pp|-I|
option specifies the list of search directories for included files, requested
modules and user library modules. Finally the \pp|-L| option specifies where
the compiler should look for the standard library files.

The default value of some of the pragmats is the following:

\HH\pp|tab width=8,|\HE

\HH\pp|list=off,|\HE

\HH\pp|dictionary=off,|\HE

\HH\pp|library mode=off,|\HE

\HH\pp|compile=on,|\HE

\HH\pp|prototype=none.|\HE

\smallskip
Pragmats \pp|front matter="code"|  and \pp|back matter="code"| are accepted
in library mode only; the specified string is copied verbatim to the front
(to the back, respectively) of the generated code with the exception that
the sequence \pp|\char37 n| is replaced by a newline. The pragmat \pp|std
library=off| inhibits processing of the standard library, while
\pp|library="file"| designates the module \pp|file| as a library module
(which can request other modules). The latter two pragmats are not accepted
in required or library files.

The \pp|prototype| pragmat has four possible values: \pp|import|,
\pp|public|, \pp|none|, and \pp|reverse|. In the first case a \g{prototype}
indicates that the tag has a declaration outside this source (and then it
cannot be defined, but can have other prototypes). In the second case a tag
appearing in a \g{prototype} automatically gets the \emph{public} flag, and
must be defined in this source (in particular, it cannot be imported, and
this source must be a module). When
\pp|prototype=none|, prototypes are used for type checking only, and do
not imply any specific behavior. Finally, \pp|prototype=reverse| swaps the
current prototype value between \pp|import| and \pp|public|, while keeping
\pp|none| unchanged. For a sample usage of \pp|reverse| see Section
 \ref{subsec:redef}.

% ----------------------------------------------------------------------

\subsection{Conditional pragmats}\label{conditional}

Conditional pragmats can be used to instruct the compiler to ignore certain
parts of the source file. They have the syntax

\medskip

\pp|'pragmat'if=TAG.     'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pp|'pragmat'ifnot=TAG.  'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pp|'pragmat'ifdef=TAG.  'pragmat'else=TAG.   'pragmat'endif=TAG.|

\noindent or

\pp|'pragmat'ifndef=TAG. 'pragmat'else=TAG.   'pragmat'endif=TAG.|

\medskip
\noindent
where \pp|TAG| in \pp|if| and \pp|ifnot| pragmats is one of \pp|compile|,
\pp|list|, \pp|dictionary|, \pp|module|, \pp|library mode|, etc. The program text
between the \pp|if| and \pp|else| pragmats is processed if \pp|TAG| is (or
is not) in effect, otherwise it is skipped; and the opposite is true for
the text between \pp|else| and \pp|endif|. The \pp|else| part may be
missing. The \pp|TAG| in \pp|ifdef| and \pp|ifndef| pragmats can be any
identifier (tag), and the compiler checks if this identifier has (has not)
been defined until this point by a declaration, an import prototype, 
or by a \pp|define| pragmat. As an example,
\begin{program}
'pragmat'if=module,include="private",else=module,
                   include="public",endif=module.
\end{program}
\noindent
adds the source file \pp|private| among those to be processed if a
\pp|module| pragmat has been processed previously, otherwise it adds the
\pp|public| source file.

The \pp|if| \dots{} \pp|endif| pragmats must be nested properly, and the
ignored text must be syntactically correct (as it is scanned to find the
closing pragmat). The \pp|'end'| symbol marking the end of the source file
is never ignored: conditional pragmats do not extend over the end of the
current file.

% ----------------------------------------------------------------------

\subsection{Library mode}\label{subsec:library}

Pragmats \pp|library mode=on| and \pp|library mode=off| turn the library
mode on and off, respectively. This mode determines whether library
extensions are allowed or not.

In library mode the \pp|@| character is considered to be a letter. This way
private tags can be created which are not available outside the library.
Dictionary listing ignores tags starting with \pp|@|.
External declarations are allowed in library mode only.
Pragmats \pp|front matter| and \pp|back matter| can only be issued in library
mode.


% ----------------------------------------------------------------------

\subsection{Macro substitution}\label{sec:macro}

To improve efficiency rule calls can be implemented by textual substitution.
When the rule name appears in a \pp|macro| pragmat (Section
\ref{subsec:pragmats}), calls to this rule in the current compilation unit
are replaced by the rule body (and replacing formal affixes by the actual
ones). Such a substitution, however, can result in a syntactically incorrect
program text, or in a different semantics. The following examples illustrate
these cases and explain the additional restrictions a macro rule must
satisfy.

\def\becomes{$\Rightarrow$\space}

\begin{enumerate}\def\HH{\noindent\hbox to 0.33\linewidth\bgroup\hskip\programindent}%
\programindent=4pt%
\setlength\parskip{1pt plus 1pt minus 1pt}%
\item In a macro, \g{formal in} affixes cannot be assigned to.
Indeed, suppose the rule \pp|macro| is defined as
\begin{program}
'function'macro+>x+y>: 1->y->x,x->y.
\end{program}
\noindent
After textual substitution the replacement can be syntactically wrong as in

\HH \pp|macro+1+z|\HE\becomes \pp|(1->z->1,1->z)|

\item There is a problem with the dummy affix \pp|\#|. Using the same
\pp|macro| rule as above, the following substitution has incorrect syntax:

\HH \pp|macro+u+\#| \HE\becomes \pp|(u->\#->u, u->\#)|

\item While a macro rule can have a variable number of affixes, neither
\pp|shift affix block| nor \pp|get affix blockno| can be used in a macro
text as illustrated by the following example. Rule
\pp|is zero| below checks whether one of its arguments has
value zero; rule \pp|math| computes the product of its arguments if none of
them is zero, otherwise it computes their sum:
\begin{program}
'question'is zero+@+>x: x=0; shift affix block+@,:is zero.
\smallskip
'function'math+y>+@+>x:
  is zero+@,0->y,(nxt:add+x+y+y,shift affix block+@,:nxt;+);
  1->y,(nxt:mult+x+y+y,shift affix block+@,:nxt;+).
\end{program}
If \pp|is zero| were substituted verbatim in rule \pp|math|, it would shift
out all affixes and then the computation in \pp|math| would not be carried over.
%
Similarly, suppose the rule \pp|macro| is defined as
\begin{program}
'function'macro+a>+@+>q: q->b, get affix blocno+a+@.
\end{program}
\noindent
where \pp|b| is some global variable. After verbatim substitution the 
repeat block can vanish completely causing a syntax error: 

\HH\pp|macro+b+2+T| \HE\becomes 
   \pp|(2->b,get affix blockno+b+2+T)|

\item Standard selectors are not carried over.
\begin{program}
'function'macro+t[]+x>: t[ptr]->x.
\end{program}

where \pp|ptr| is some global variable. After substitution

\HH \pp|macro+S+z|\HE\becomes \pp|(S[ptr]->z)|

\smallskip

while \pp|S| might not have a standard selector.

\item Out affixes get their values only after returning from a call.
%
The rule call \pp|swap+x+y+x| swaps the value of \pp|x| and \pp|y| if it is
defined as
\begin{program}
'function'swap+>a+b>+c>: b->c,a->b.
\end{program}
\noindent
but as a macro it does \pp|(y->x,x->y)|, with a completely different result.
\end{enumerate}

Items 1) and 3) are checked during compilation, and error messages are
issued if the conditions are violated. For 2), if the actual affix is the
dummy affix \pp|\#|, the formal out affix in the macro is replaced by a
newly created anonymous local variable (which may be removed during
optimization). For 4) the macro substitution mechanism remembers the last
substituted formal affix and uses the same value for the standard selector
as the rule call would do. For 5) and other side effects, no warning is, or
can be, given, but substitution clearly changes the semantics. So use macros
with care.

% ----------------------------------------------------------------------

\subsection{Debugging tools}\label{subsec:debug}

Debugging tools are added at the linking stage of the compilation when macro
rules have already been substituted. Consequently these tools have no effect
on macro rules.

\smallskip

\emph{Index checking}.
It is controlled by the \pp|bounds=in/off| pragmat. If the pragmat is
\pp|on| when a rule is declared, the rule is compiled with index checking.
Before touching the indexed element, the value of the index is checked to be
within the actual limits of the indexed \g{stack} or \g{table}. If this is
not the case, the name of the list and the rule in which the error occurs
are printed to \pp|stderr|, and the program is aborted.

\smallskip

\emph{Profiling}.
The \pp|count=on| pragmat adds instructions which count how many times the
rule is called. After a normal program termination the name of profiled
rules and the number of calls to them are printed to \pp|stderr|. The list
starts with the largest calling numbers, and ends with rules which were not
called at all.

\smallskip

\emph{Tracing}.
If the pragmat \pp|trace=on| is in effect when a rule is declared, the rule
is compiled with instructions that print out to \pp|stderr| the rule name,
followed by the values of its \g{in} and \g{inout} affixes. As this would
produce a huge volume output, tracing information is printed only when the
compiled binary is executed with the \pp|-T| switch as the first
command-line argument. Without this switch only the lastly executed 30
rulenames (without arguments) are printed when the program terminates
(normally or with an error).

\smallskip

\emph{Call stack}.
Tracing provides the lastly executed 30 rule calls.
Frequently the \emph{call stack}, the hierarchy of the pending rule calls
gives more information. When adding the \pp|-g| switch to the linker it
produces an \A{} binary which keeps track of the call stack, and prints it
to \pp|stderr| when the program terminates either normally or with an error.
This feature adds some overhead to all rule calls, and increases the size of
the compiled program. The library routine
\begin{program}
'action'backtrack.
\end{program}
\noindent
prints out the complete, actual call stack starting with the
rule containing this rule. In the case the program is \emph{not} linked
with the \pp|-g| switch, \pp|backtrack| behaves as a no-op and does nothing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Modular Aleph}\label{section:module}

A module is an incomplete program part, which can be compiled independently,
and which provides resources to be used by the other parts of the
program. Modules are frequently written so that it can be reused by other
programs. The first non-comment line in an \A{} module is usually a pragmat
specifying both the \emph{name} and the \emph{namespace} of the module:

\begin{program}
'pragmat'module=XXX.
\end{program}

\noindent
The module name \pp|XXX| must be a valid \A{} identifier; it must be written
without quotation marks. According to the best practice, the name of the
file containing the module and the module name should resemble each other.
It is particularly important in \A{} as \A{} modules are invoked by
specifying file names, and not module names. While not recommended,
different modules (that is, modules in different files) can share
the same module name, and, consequently, the namespace.

In the module the initial \pp|module| pragmat is followed by the public
part, or \emph{head} of the module. It contains the prototypes of the
(public) tags exported by, and defined in, this module. Next to the public
part is the private part, called \emph{body}, which defines the exported
items together with the optional auxiliary, unexported items. The body is
enclosed between \pp|ifdef=compile| and \pp|endif=compile| pragmats.

An \A{} module is invoked, or required, by a \pp|require="FFF"| pragmat
specifying the file name (possibly with path information, enclosed within
quotation marks) of the module. When required only the public part---the
module head---is processed from the module text. Prototypes in the head are
considered to be external definitions which define items to be imported from
the defining module. In contrast, when the module is compiled, both the head
and the body are processed. During module compilation the prototypes in the
head specify the items to be exported, and the compiler checks that those
items are indeed defined correctly in the module body.

The following example illustrates this mechanism for a sample module which 
exports two items: the rule \pp|do something| and the stack \pp|LEXT|. The
module name is \pp|sample| and it is stored in the file \pp|"fsample"|.

\begin{program}
'pragmat'module=sample.        $ module name\no$
'action'do something+>in+out>. $ prototype\no$
'stack'(adm,left,right)LEXT.   $ prototype\no$
'pragmat'if=compile.           $ module body starts here\no$
 'stack'[12](adm,left,right)LEXT=((3,4,5):first item).
 'action'do something+>x+y>: add+first item+x+y.
 'root'+.
'pragmat'endif=compile.        $ end of module body\no$
'end'
\end{program}

\noindent
When the module is compiled, the file is read with the initial implicit
instruction \pp|'pragmat'compile=on.| The \pp|module=sample| pragmat in the
first line defines both the name and the namespace of the module to be
\pp|sample|, and it also sets the \pp|prototype| pragmat to \pp|public|.
Next the module head is parsed where the compiler marks all prototyped tags
to be exported (as instructed so by the current setting of \pp|prototype|,
see Section \ref{subsec:prototype}),
which also means that the prototyped tags must have a definition somewhere
in the module body. The condition in the \pp|if=compile| pragmat holds, thus
the material in the module body is processed: the \g{stack} and \g{rule}
declarations are parsed and executed. The empty root rule (Section
\ref{subsec:root-rule}) indicates that the module does not require any
initialization. At the end of the module items to be exported are checked
against the prototypes and are prepared for export using the module namespace.

When the main program or another module wants to use any of the resources
provided by this module, it \emph{requires} it by issuing
\begin{program}
'pragmat'require="fsample".
\end{program}
\noindent
specifying the file name (between quotation marks) of the module text. 
Before reading the \pp|"fsample"| file, an initial implicit
\pp|compile=off| pragmat is executed. The first line in the module text sets
again the name and the namespace (for the duration of \pp|fsample|), but sets the
\pp|prototype| differently, to \pp|import|. Subsequent prototypes are scanned
and marked as ``to be imported''. The compiler will use this information to
check that these items are used properly in the rest of the invoking
program. Reaching \pp|if=compile| the condition fails, therefore the
remaining part of the module, the body, is skipped.

\smallskip

A module body can require public items from other modules. It may
happen, without any problem, that the body of module \pp|A| requires
module \pp|B|, while the body of module \pp|B| requires module \pp|A|.

Next to prototypes the public part of a module may also contain additional
\A{} constructs. A \pp|require| pragmat in the head automatically re-exports
the imported items (using their original namespace), while declarations in
the head are compiled into the invoking program using the module's
namespace.

% -----------------------------------------------------------------------

\subsection{The module hierarchy}\label{subsec:hierarchy}

An \A{} compilation unit (the main program or a module) may require several
modules. Any module may also require other modules in its head, which
modules may also require additional modules, and so on. The ``\pp|X|
required module \pp|Y|'' relation defines a hierarchy among the involved
units. In this hierarchy \pp|B| is \emph{above} \pp|A| if there is a
``required'' chain from \pp|A| to \pp|B|, see also the discussion in Section
\ref{subsec:general-modules}. Resources provided by module \pp|B| are
automatically available for every unit \pp|A| below \pp|B| in
this hierarchy, that is, those units \pp|A| for which \pp|B| is above \pp|A|.

When \pp|A| needs a resource, that resource might be provided by several
modules. In the basic case among the potential offers that module is chosen
which is equal to or above \pp|A|, and has the \emph{smallest rank}, that
is, which requires the smallest number of ``required'' hops to reach from
\pp|A|. By default, \pp|A| has rank zero above itself.

The same module can be required by different modules many times, when this
module appears in the hierarchy at several places. Nevertheless, it is still
processed only once. The modules added as \emph{user library} (Section
\ref{subsec:user-library}) using either the command-line argument \pp|-y| or
the \pp|library| pragmat, and the modules required recursively by these
library modules, form a second hierarchy. Elements of this hierarchy are
\emph{above} the elements of the first one by a very high hop number. Using
this arrangement, resources defined by a library module are available to
every plain module, but only as a last resort: if no other definition can be
found, then consult the offers in library modules. On the top of the user
library hierarchy there is still another hierarchy: the standard \A{}
library providing the realization of \A{} primitives.

% -----------------------------------------------------------------------

\subsection{Finding tag definitions}\label{subsec:qualifier}

Each \g{tag} denoting an \A{} construct can have a \emph{qualifier}
specifying the namespace this tag belongs to, such as \pp|q{\cc}x|,
where \pp|q| is the qualifier. Without providing an explicit qualifier, tags
in definitions (declarations and import prototypes) inherit the actual
namespace. This namespace is empty in the main program; otherwise it is the
same as the module name defined by the \pp|module| pragmat. The explicit
qualifier, if present, cannot be empty. A \g{tag} with a qualifier
identifies only those definitions where the same implicit or explicit
qualifier is used.

The process of finding the defining occurrence of a \g{tag} in the module
hierarchy goes as follows. Suppose the \g{tag} \pp|x| occurs in \pp|A|,
where \pp|A| is either a module or the main program, and \pp|x| has
qualifier \pp|q| which is either explicit or implicit. (In case \pp|A| is
the main program, the implicit qualifier is empty.) First check modules
which are \emph{strictly below} \pp|A|. If some of them defines \pp|q{\cc}x|
(where the qualifier in the definition can be either explicit or implicit),
then the one with the \emph{smallest absolute rank} (which has the minimal
number of ``required'' hops from the main program, see Section
\ref{subsec:hierarchy}) is chosen.

If this step does not give result, then consider \pp|A| and the modules
\emph{above} \pp|A|. If \pp|x| has no explicit qualifier, then it matches
any definition of \pp|x| in those modules; if \pp|x| has an explicit
qualifier \pp|q{\cc}x|, then it matches only those definitions where the
qualifier is (explicitly or implicitly set to) \pp|q|. Among the candidate
modules that one is chosen which has the smallest rank above \pp|A|.
Naturally, this search must yield a unique definition.

This procedure is illustrated in the picture below. Modules in files
\pp|"f1"| and \pp|"f2"| set their name to \pp|t|, \pp|"f2"| is required by
the module in \pp|"f1"|, and \pp|"f1"| is required by the main program. Tags
(with the indicated qualifier) in the ``define'' column are defined in the
module head. Tags in the ``use'' column are connected to their identified
definitions.

\begin{center}
\begin{tabular}{|cccll|}
\hline
\rule{0pt}{10pt}file & require & module & define & use \\
\hline
\rule{0pt}{12pt}\tt "f2"   &         & \tt  t    &  \tt b v  &  \tt a v x \\[3pt]
\tt "f1"   &  \tt "f2"    &  \tt t    &  \tt a v  & \tt  a x  \\[3pt]
main     &   \tt "f1"    &        &  \tt a t{\cc}x x & \tt a b t{\cc}b v x%
\begin{tikzpicture}[remember picture,overlay]
\useasboundingbox(0,0) rectangle(0,0);
\draw[opacity=0.3,very thick,green!50!black]
  (-2,0) to[out=140,in=40] (-3.94,0.05)
  (-1.6,0.65) to[out=210,in=45] (-3.1,0.05)
  (-1.25,1.2) to[out=220,in=75] (-3.1,0.05)
  (-0.05,0.05) to[out=145,in=15] (-2.7,0.05);
\draw[opacity=0.3,very thick,blue!60!black]
  (-1.6,0) to[out=135,in=320] (-3.94,1.2)
  (-0.8,0) to[out=115,in=335] (-3.94,1.2);
\draw[opacity=0.3,very thick,red!70!black]
  (-2,1.2) to[out=200,in=45] (-3.94,0.6)
  (-1.6,1.2) to[out=210,in=20] (-3.55,0.6)
  (-2,0.6) to[out=150,in=28] (-3.94,0.6)
  (-0.4,0.05) to[out=120,in=8] (-3.55,0.6);

\end{tikzpicture}%
 \\
\hline
\end{tabular}
\end{center}

\noindent
The \g{tag} \pp|a| both in the module from file \pp|"f1"| and from file
\pp|"f2"| has the implicit qualifier \pp|t|, therefore it does not match the
definition of \pp|a| in the main program. The \g{tag} \pp|x| in these
modules matches the definition of \pp|t{\cc}x| in the main program, but not
the definition of \pp|x| (without qualifier) there. Both \pp|b| and
\pp|t{\cc}b| in the main program identifies the single definition of \pp|b|
in \pp|"f2"|. Observe that the definition of \pp|v| in \pp|"f2"| is not used
at all.

% -----------------------------------------------------------------------

\subsection{Requiring and including source files}

Source files are handled one file at a time. They are read, processed and closed
before opening the next source. Source files can be specified on the command
line, required by a \pp|require| or \pp|library| pragmat (or by the
equivalent command-line options, see Section \ref{subsec:pragmats}), finally
can be included by an \pp|include| pragmat.

The pragmat \pp|require="file"| places the source \pp|file| into the module
hierarchy (Section \ref{subsec:hierarchy}), and then queues the file to the
end of files to be processed as a \emph{module}. This second step is ignored
if the same filename is already in the queue, causing each source file to be
processed once. Library modules (including the standard library) are handled
similarly, but their processing starts only after all non-library sources
have been completed. A source file added by a \pp|require| pragmat in a
library module is treated as a library.

Using the pragmat \pp|include="file"|, this \pp|file| is \emph{always}
appended to the end of the source list, together with the \pp|prototype| and
\pp|compile| pragmat values and the module status (is it a module, and if
yes, which one) of the invoking source. In contrast to modules and
libraries, included sources are processed as many times as they are
specified.

As discussed at the beginning of Section \ref{section:module}, when a source
is processed as a required module, an implicit \pp|compile=off| pragmat is
executed before reading its first character. When the source is to be
compiled (specified the file name in the command line), an implicit
\pp|compile=on| pragmat is executed before processing. The effect of a
\pp|module=XXX| pragmat depends on whether \pp|compile| is on or off. If
\pp|compile=on|, then the \pp|module| pragmat switches to module compilation
and sets \pp|prototype=public|. If \pp|compile=off|, then it reads a module
head, and sets \pp|prototype=import|.

% -----------------------------------------------------------------------

\subsection{Using the namespace}

A module can have ``call-back'' rules whose definition must be provided by
the invoking program. An example could be a module which provides a sorting
algorithm without defining the rule which compares the elements. The 
skeleton of this module can be

\begin{program}
'pragmat'module=sort.        $ module name\no$
'action'qsort+[]st[].
'pragmat'prototype=reverse.  $ reverse the meaning \no$
'question'qless+>x+>y.
'pragmat'prototype=reverse.  $ redo\no$
'pragmat'if=compile.         $ module body starts here\no$
'action'qsort+[]st[]:  ...   $ use qless+x+y for comparison\no$
'root'+.
'pragmat'endif=compile.
\end{program}

\noindent
The rule call \pp|qsort+st| will sort the elements of the stack \pp|st| so
that for comparing two stack elements it uses the rule \pp|qless+x+y|, with 
the assumption that this comparison rule returns true just in case \pp|x| is
``smaller than'' \pp|y|, whatever ``smaller'' means. In the module skeleton
the first

\begin{program}
'pragmat'prototype=reverse.
\end{program}

\noindent
pragmat ensures that the \pp|qless| prototype is handled correctly. When the
module is compiled then \pp|qless| is marked to be imported (since now the
\pp|prototype| pragmat is reversed to \pp|import|). Similarly, when the
module is required, then \pp|qless| is to be exported (instead of the default
\pp|import|). The second \pp|prototype| pragmat restores its original value;
it can be omitted if there are no additional prototypes in the module.

When requiring the \pp|qsort| module the rule \pp|qless| must be specified
by the invoking program. Since declarations there use a different namespace,
\pp|qless| must be declared with a qualifier:

\begin{program}
'pragmat'require="sort".     $ require the sorting module\no$
'stack'[]A=(3,4,7,1,0).
'question'sort::qless+>x+>y: $ use the module namespace\no$
     x>y.                    $ sort in reverse order\no$
'root'qsort+A.               $ and use it\no$
\end{program}

\noindent
When compiling the \pp|sort| module the rule \pp|qless| is left unspecified,
and it is the linker's responsibility to replace it by the rule defined in
the main program. Since there is a single compiled instance of \pp|qsort| (in
which calls to \pp|qless| become hard-coded after linking) in the whole
program, only a single instance of \pp|qsort| can exist. This means that one
cannot use such a sorting procedure with more than one definition of the
comparison rule.

To overcome this problem, the invoking module could have a \emph{local copy}
of the sorting rule, which then can call the locally defined comparison
rule. This would result in different sorting routines in different modules.
To achieve this simply move the definition of the rule \pp|qsort| from the
module body into the head, and delete both prototypes. After this the module
body becomes empty and can be omitted completely (consequently the module need
not be compiled). The result is the \pp|isort| module

\begin{program}
'pragmat'module=isort.       $ inline sorting module\no$
'action'qsort+[]st[]: ...    $ the complete sorting routine\no$
                             $ using qless+x+y for comparison\no$
'end'                        $ end of source\no$
\end{program}

\noindent
When the module \pp|isort| is required, its head is compiled into the
invoking unit locally, but keeping the module status and namespace. Thus the
comparison rule \pp|qless| still must be defined with a qualifier:

\begin{program}
'pragmat'require="isort".    $ request the module\no$
'question'isort::qless+>x+>y: x>y.
'stack'[]A=(3,4,7,1,0).
      ... qsort+A ...        $ this is a reverse sort A\no$
\end{program}

\noindent
Since everything is local to the invoking unit, different modules can
require this inline sorting module and tailor the comparison rule
\pp|qless| according to their different needs.

As a final twist, this arrangement allows the \pp|isort| module to have
a \emph{default} comparison rule, which should be redefined only when
another sorting order is required. Simply add the default rule to the module 
head:

\begin{program}
'pragmat'module=isort.       $ inline sorting module\no$
'action'qsort+[]st[]: ...    $ the complete sorting routine\no$
                             $ using qless+x+y for comparison\no$
'question'qless+>x+>y:x<y.   $ default comparison rule\no$
'end'
\end{program}

\noindent
This comparison rule will be used when the invoking unit does not
supply its own \pp|qless| rule. It is so as during the compilation of
the rule \pp|qsort|, the defining instance of \pp|qless| inside \pp|qsort| is
determined so that
\begin{itemize}
\item[\textbullet] if there is a definition of \pp|isort{\cc}qless| in the invoking unit, 
then that definition is used;
\item[\textbullet] if there is no such a definition, then the one in the module head is
used,
\end{itemize}
see the discussion and the Figure in Section \ref{subsec:qualifier}. If the
invoking unit supplies its own comparison rule, then the default one is not
used at all, and is not included in the final binary.

% -----------------------------------------------------------------------

\subsection{Redefining a module resource}\label{subsec:redef}

The mechanism identifying definitions can be used to redefine transparently 
resources  exported by a module. For an example, suppose that the module
\pp|MOD| in file \pp|"MOD"| exports
the rule \pp|proc+>x+y>|. We would like to add tracing information before and
after the call to this rule, but keep other resources supplied by \pp|MOD|
intact. This can be achieved by creating another module, say \pp|MODtr|, 
which requests \pp|MOD| and redefines \pp|proc| in its head, and provides 
the alternate rule definition in its body.
\begin{program}
'pragmat'module=MODtr.
'pragmat'require="MOD". $ read and export module MOD\no$
'action'proc+>x+y>.     $ prototype, redefine this rule\no$
'pragmat'if=compile.    $ module body\no$
'a'proc+>x+y>: before+x, MOD::proc+x+y, after+y.
'a'before+>x: ....      $ print some tracing information\no$
'a'after+>y:  ....      $ print some tracing information\no$
'root'+.
'pragmat'endif=compile.
\end{program}
\noindent
In the module body \pp|MOD{\cc}proc| calls the original rule as defined in
(exported by) the module \pp|MOD|. Omitting the qualifier here would cause this
rule to call itself making an infinite recursion.

Replacing \pp|"MOD"| by \pp|"MODtr"| in the pragmat requiring the module
does all the tricks. All other resources provided by \pp|MOD| are still
available (without qualifiers), while calls to \pp|proc| are now handled by
the new definition in \pp|MODtr|. Observe that internal calls to \pp|proc|
in the original \pp|MOD| module are not affected.

% -----------------------------------------------------------------------

\subsection{Redefining library items}\label{subsec:redef-library}

Assignments (\g{transport}s in \A{} parlance) and relations (of which \g{identity} is an
example, see Section \ref{subsec:relations}) are handled as a syntactically
different way of writing a rule call. Internally, the assignment
\pp|a->b[c]->c| is transformed into the rule call \pp|@make+a+b[c]+c|
(recall that the character \pp|@| is a letter in library mode, Section
\ref{subsec:library}). The rule \pp|@make| is exported by the standard
library and has the prototype
\begin{program}
'function'@make+>from+@+to>.
\end{program}
\noindent
Similarly, relations are transformed to calls of rules \pp|@equal|,
\pp|@noteq|, \pp|@more|, \pp|@less|, \pp|@mreq|, and \pp|@lseq|,
respectively; all of them are \emph{question}s with two input affixes. They
are also exported by the standard library. Any of these rules can be redefined
(after switching to library mode) to do something different. As an example, 
suppose the list \pp|STR| contains strings, and two pointers to \pp|STR| 
should be considered equal if the strings they point to are the same, not 
only if they, as pointers, are equal. So
\begin{program}
 (ptr1=ptr2,print+"strings are equal";
            print+"strings are not equal")
\end{program}
\noindent
would print \pp|strings are equal| if the strings pointed by \pp|ptr1| and
\pp|ptr2| are, as strings, equal. This can be achieved by redefining \pp|@equal| to
handle this case as follows:
\begin{program}
'pragmat'library mode=on.
'question'@equal+>x+>y-eq:
  (was+STR+x,was+STR+y),compare string+STR+x+STR+y+eq,eq=0;
  stdlib{\cc}@equal+x+y.
'pragmat'library mode=off.
\end{program}
\noindent
When \pp|x| and \pp|y| are not string pointers the rule calls the original
\pp|@equal| from the standard library. Actually, the test \pp|eq=0| should
rather be \pp|stdlib{\cc}@equal+eq+0|, as now this \pp|@equal| calls itself.
(Fortunately \pp|eq| is not an \pp|STR| pointer thus it won't fall into an infinite
recursion.) In the module where this definition appears all equality tests
will use this rule. To improve efficiency one might consider declaring this
\pp|@equal| to be a macro.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Standard library}

Elements of the standard \A{} library can be used without further notice,
and can be redeclared in a user library (Section \ref{subsec:user-library})
or in the main text; see and example in Section \ref{subsec:redef-library}.
The \A{} Manual \cite{A-manual} specifies many standard items, called
\emph{standard externals}, which should be available for the programmer. In
this implementation most of them, but not all, are defined in the standard
library module, called \pp|stdlib|. The main omission is double precision
arithmetic, while there are many additions. The complete list can be
found in the \A{} standard library source of the implementation with
extensive comments. A few of the standard library items are discussed below.

\subsection{Stacks}

Calling \pp|unstack+st| discards the rightmost block of the stack \pp|st| by
decreasing the actual upper bound of the stack by its \emph{calibre}.
The calibre of the declared stack is used even if \pp|st| is a formal affix.
%
The rule \pp|scratch+st| discards all elements of the stack \pp|st|, but
keeps the allocated memory. It is implemented by moving the upper bound of
\pp|st| to its minimal value. The rule \pp|release+st| additionally releases
the memory allocated to the stack \pp|st|, which will be reallocated again
when \pp|st| is expanded. This rule replaces \pp|delete+st| from the Manual
using the established terminology. Additional memory can be requested in
bulk by calling \pp|request space+st+n|. After a successful return the
actual bounds do not change, but there are
at least \pp|n| additional words of allocated memory above the top of
\pp|st|. This rule fails if the requested additional memory is not available.

\subsection{Strings}

To copy a string to the top of the stack \pp|st| use \pp|copy
string+t[]+>p+[]st[]|; it is more efficient than unpacking and packing the string. 
The rule \pp|compare string| compares two strings, returning a positive,
zero or negative value depending on the relation of the strings. The rule
\begin{program}
  'q'compare string n+t1[]+>p1+t2[]+>p2+>n+res>.
\end{program}
\noindent
compares the strings up to \pp|n| UTF-8 characters. 
It is the counterpart of the {\sf C} function \pp|strncmp|.

\subsection{File operations}

Each \A{} file has an associated error code, and ecah file operation sets
this code. If the operation succeeds, the code is zero, otherwise it
indicates the reason of the error.

\pp|'f'get file error+""f+err>|

\noindent
recovers the error code from file \pp|f|. It is zero if the last file
operation preformed by \pp|f| succeeded. Otherwise it is either the
\pp|errno| value set by the underlying {\sf C} or system file operation, or
a value above 10000 when it was set by the \A{} file interface.

\pp|'p'open file+""f+>mode+t[]+>p|

\noindent
opens a file and associates it with the \A{} file \pp|f|. The string given
as the last two affixes specify the file name with possible path
information. The \pp|mode| specifies how the file is opened; it is \pp|/r/|,
\pp|/w/| or \pp|/a/| for reading, writing, and appending. Only character
files can be opened for appending, for details see Section
\ref{subsec:datafiles}. Character files can use the strings
\pp|"<<stdin>>"|, \pp|"<<stdout>>"| and \pp|"<<stderr>>"| as filenames for
the corresponding standard streams.

\pp|'p'open temp file+""f+[]st[]+>p| 

\noindent
creates a temporary file (either character or data) and opens it for
writing. The supplied string must end with six \pp|X| characters, and must
be on a \g{stack} as the rule replaces these characters by other ones
which make the file name unique.

\pp|'a'put data+""f+>x+>type| 

\noindent
writes \pp|x| either as a word or as a pointer (depending on \pp|type|) to
the data file \pp|f|, aborting the program in case of an error (for example
when a non-zero pointer data doesn't point into one of the lists specified
in the declaration of \pp|f|). To handle errors use the predicate \pp|put
datap+f+x+type| which fails in case of an error. The error code can be
retrieved by \pp|get file error|,

\pp|'a'close file+""f|

\noindent
closes the file \pp|f|. In case of an error the program is aborted. 

\pp|'a'unlink file+t[]+>p|

\noindent
deletes the file specified by the string; this rule silently ignores errors.

\pp|'a'put string+""f+t[]+>p| 

\noindent
writes the specified string to the character
file \pp|f|, while \pp|put as string+f+t+p| writes the same string
between quotation marks and doubles the quotation marks inside the string,
producing a proper \g{string denotation}.

\smallskip

The \A{} character files \pp|STDIN| and \pp|STDOUT| are associated with the
standard input and standard output streams. These \A{} files
can be used, without opening, to read from and write to the terminal, see
Section \ref{subsec:datafiles}.

\subsection{Miscellaneous}

Command-line arguments can be retrieved from the external table
\pp|STDARG|. This table contains these arguments as strings in \emph{reverse
order} ending with the first argument at \pp|>>STDARG|. The following rule
prints all command-line arguments to the console in their original order:
\begin{program}
'a'put arguments-ptr:
  >>STDARG->ptr,(nxt:
     ptr< <<STDARG;     $ no more argument\no$
     put string+STDOUT+STDARG+ptr, put char+STDOUT+newline,
        previous string+STDARG+ptr,:nxt).
\end{program}

\smallskip

The rule \pp|exit+n| terminates the program with exit code \pp|n|, see
Section \ref{subsec:exit}. It can be written equivalently as the
\g{terminator} \pp|'exit'n|.

\smallskip

The \pp|wait for| rule can be used to synchronize module initializations.
The root of each module is executed before the root of the main program is
called. The \pp|wait for+"xxx"| call checks whether all modules with name
\pp|xxx| has finished executing their roots. If yes, it returns immediately.
If not, calls those roots and waits until they return, see Section
\ref{subsec:root-rule}.

\smallskip

The rule \pp|backtrack| prints out the complete call stack starting with the
rule containing this call and ending with the program root if the \A{}
program was linked with the \pp|-g| switch. Consult Section
\ref{subsec:debug} from more details.
\ignore
If the \A{} program is linked with the \pp|-g| switch, rules are modified to
keep track of the caller--callee relation. When running a program linked
that way the library rule \pp|backtrack| prints out to \pp|stderr| the
complete call stack starting with the root of the main program and ending
with the current rule. When the program is linked normally, the
\pp|backtrack| rule does nothing. Consult Section \ref{subsec:debug} for
more details.
\endignore

\smallskip

A lightweight, single word hash of a block of list elements is computed by the
library rules

\begin{program}
  'f'string hash+t[]+>p+hash>.
  'f'block hash+t[]+>p+hash>.
\end{program}
\noindent
The first rule returns the hash of the string specified; the second rule
computes the hash of a block of words starting at the element \pp|p| and ending at
\pp|>>t| (the last element of the list \pp|t|). This hash serves only as a tool to
speed up checking whether two strings or two blocks are the same when
many such comparisons should be made: they are definitely not equal if their
hash is different.

\smallskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Intermediate code: Alice}\label{sec:alice}

The \A{} compiler produces an intermediate code for each module while
typically reading several source files: the module source, the headers of
required modules, headers of user libraries and that of the standard
library. These intermediate codes are read, merged and linked by the linker
which generates the final {\sf C} code.

The intermediate code is called \I{} in reminiscence of the machine
independent code designed for the first \A{} compilers \cite{grune}. An \I{}
file is a plain text file. Lines starting with the dollar sign \pp|$\no$|
are comments and are skipped. The file has four sections: a header, a list
defining all items used in this file, a data section, and finally a rule
section. A tentative description of the details is given below by a grammar-like
description with many comments. Grammar elements starting with \g{D} refer
either to a single character, like \g{Dpoint}, \g{Dcolon}, \g{Dstar} with
their obvious interpretation, or to a keyword written with apostrophe
characters, like \g{Dmain} or \g{Drule} written as \pp|'main'| or
\pp|'rule'|, respectively.

\begin{grammar}
\item alice file : header, item section, data section, rule section.
\item header:

   (Dmain; Dmodule, module string), title string, target word size,

   (from line, end line, source string)*,

   Dpoint.
\end{grammar}

\noindent
The first non-comment line of the \I{} file starts with either \pp|'main'|
or \pp|'module'|, where the latter one is followed by the \g{module string}
which is the module name (as specified by the \pp|module| pragmat) in
quotation marks. It is followed by the title as given by the \pp|title|
pragmat, or \pp|"aleph"| if no title was specified. The target word size is the
number of bits in an \A{} word, which is 32 for this implementation. The
next block of three items each assigns file names to line numbers for
determining the 
location in error and warning messages. Source lines are numbered consecutively
starting from one, not resetting when opening a new source. This list
contains the first and last number associated with a file. This way the
relative line number and corresponding file name appearing in error and
warning messages can be determined from the line number only.

\subsection{Alice item section}\label{alice:item}

The \g{item section} defines all identifiers appearing in this module,
including imported, exported, and the local ones. This section has the
following structure:
\begin{grammar}
\item item section: 

  (typer, item id, flags, lineno, type specific info, qualifier, tag)*, Dpoint .
\item typer: \remark{the type of the identifier (see below)}.
\item item id: \remark{letter {\tt I} followed by a decimal number}.
\item flags: \remark{an integer containing type specific flags}.
\item lineno: \remark{the source line of the definition}.
\item type specific info: \remark{see below, can be empty}.
\item qualifier: \remark{qualifier in quotation marks, can be {\tt""} (empty
qualifier)}.
\item tag: \remark{the identifier enclosed in quotation marks}.
\end{grammar}

\noindent
The \g{typer} is one of the non-formal types defined in the \pp|types.ale|
module, written between sharp brackets such as \pp|<charfile>|. \g{Item id}
specifies how this entry is referred to in this \I{} file: it is 
the letter \pp|I| followed by an integer. The integer starts at \pp|1| and
\emph{must} increase by one for each item line in this section.
%
The \g{flags} entry is a decimal number which gives the following flags
(defined in module \pp|tags.ale|:
\begin{center}\begin{tabular}{ll}
\g{public} & set if the item is to be exported \\
\g{imported}& set if the item is to be imported from other module \\
\g{external}& set if it is an external item \\
\g{ruleflags}& eight bits specifying rule type and special handling.
\end{tabular}\end{center}

\g{Lineno} is an integer which defines the source line of the item for error
reporting. \g{Type specific info} gives additional information for lists
(\g{table}, \g{stack}, and their static versions) and rules. For lists this
part consists of two integers: calibre (block size), and the index of the
standard selector (\pp|-1| if none, otherwise this number is at least 1).
For rules the \g{type specific into} specifies the number of affixes
followed by the list of types of the formal affixes in the same syntax as
the item \g{typer}s. For formal lists the typer is followed by two integers:
the calibre (\pp|-1| if no block was specified), and the standard selector
(\pp|-1| for no standard selector).

Finally both \g{qualifier} and \g{tag} are strings enclosed in quotation
marks. Exported and imported items are matched by their qualifier--tag
pairs. For each imported item there must be exactly one exported item in the
other modules.

\subsection{Alice data section}\label{alice:data}

The \g{data section} of the \I{} file contains additional information for 
list and file declarations, fillings, and contains the initial values for 
\g{constant} and \g{variable} declarations. 
\begin{grammar}
\item data section: (data description)*.
\item data description:

            Dlist, list definition, Dpoint;

            Dfile, file definition, Dpoint;

            Dexpression, expression, Dpoint;

            Dfill, filling, Dpoint;

            Dfront, string, Dpoint;

            Dback, string, Dpoint;

            Dexternal, item, string, Dpoint.
\end{grammar}
A \g{list definition} contains the size information for a stack or for a
static stack in the following format:
\begin{grammar}
\item list definition: item, est type, est size.
\end{grammar}
The integer \g{est type} is one of \pp|0|, \pp|1|, \pp|2|, \pp|3|, \pp|4|
indicating that the size estimate for the list is \pp|[]| (empty),
\pp|[cons]|, \pp|[=cons=]|, \pp|[tag]|, or \pp|[=tag=]|, respectively. The
\g{est size} is either a constant when \g{etype} is \pp|0|, \pp|1| or
\pp|2|, or is an \g{item} otherwise.

A \g{file definition} describes the lists in the file area (if present),
the string after the \pp|=| sign in the file declaration, and the direction
of the file:
\begin{grammar}
\item file definition: item, direction, table item, pointer item, [file
area].

\item file area: Dsub, (list item)*, Dbus.
\end{grammar}
The \g{file area} part is optional, and is present only if it is a data file
declaration specifying lists. \g{Direction} is one of \pp|0|, \pp|1|,
\pp|2|, or \pp|3| describing whether the file is for input (\pp|1|), output
(\pp|2|), or both. The \g{table item} is the item identifying the standard
string table, while the \g{pointer item} is a pointer constant pointing to the
corresponding string in the standard string table. The optional \g{file
area} contains the list items in the order they were given in the file
declaration.

\smallskip

An \g{expression} describes the defining expression of a \g{constant} or a
\g{variable} declaration.
\begin{grammar}
\item expression: item, expr.
\item expr: target integer; item; expr, operator, expr; Dopen, expr, Dclose.
\end{grammar}
An \g{expression} typically consists of a single target integer, but it can be
an arbitrary expression, including parentheses, unary and binary operators
(including virtual lower and upper bound, calibre, arithmetic and boolean
operations). A \g{target integer} starts with the letter \pp|X| followed by
a signed decimal number in the range of the target word size.

\smallskip

A \g{filling} specifies the list fillings as specified in the module text. It 
follows the complicated structure of fillings, and includes definitions of
constant pointers.
\begin{grammar}
\item filling: item, source line, (fill item, [repeater], 
initializer*)*, Dpoint.
\item fill item: target integer; target string; item; compound fill.
\item compound fill: Dopen, (target integer; item)*, Dclose.
\item repeater: Dstar, (integer; item).
\item initializer: Dcolon, item. 
\end{grammar}
All \g{item}s in an \g{initializer} are pointer constants, and they get
their values after all virtual addresses have been calculated. Consequently repeater
values cannot depend on pointer constants, and there is a strict limit on
how large a repeater can be. A \g{target string} is a letter \pp|T| followed
by a string denotation between quotation marks, to be packed into an \A{} string
in the target architecture.

\smallskip

The \g{Dfront} and \g{Dback} lines repeat the strings from the
\pp|front matter| and \pp|back matter| pragmats. Finally, \g{Dexternal} lines
associate an external item with the string specified in the external declaration 
of that item.

\subsection{Alice rule section}

The \g{rule section} of the \A{} file contains the compiled form of the
rules defined in the module. This section is a sequence of \g{rule
definition}s, and each such definition consists of a head, followed by a 
sequence of \g{node}s describing which other rules are to be called, and at
which node should the computation continue.
\begin{grammar}
\item rule section: (rule definition, Dpoint)*.
\item rule definition: rule head, (node definition, Dcomma)*.
\item rule head: item, min local, max local, node count.
\item node definition: call node; extension; classification.
\end{grammar}
The \g{item} in the \g{rule head} is the rule name, it is followed by three
integers. If the rule has no local
variables, then both \g{min local} and \g{max local} are zero. Otherwise
local variables of the rule
are numbered from \g{min local} to \g{max local}, including bounds.
(Actually, if \g{min local} is not zero, then it is one more than the total
number of in, out, and inout affixes of the rule.) Finally, \g{node count} 
is the number of nodes following the rule head. 

In the rule body nodes are denoted as \pp|N1|, \pp|N2|, etc, where the
number after \pp|N| goes from \pp|1| until the node count inclusive. Local
variables are denoted as \pp|Ld| where \pp|d| goes from \g{min local} to
\g{max local}. Finally, the formal variables are denoted as \pp|Fd| where
\pp|F1| is the first formal affix, and the number goes ahead until the
number of the last formal affix. Formal affixes are in a one-to-one
correspondence of the rule type description in the \g{item section}.

\subsubsection{Call nodes}
A call node  corresponds to a rule call and has the following format.
\begin{grammar}
\item call node: Dnode, node, item, C1, C2, C3, (affix)*, false node,
true node.
\item false node: Dout, node label.
\item true node: Dout, node label.
\item node label: 0; -1; -2; node.
\end{grammar}
\noindent
The \g{node} after the \g{Dnode} symbol and in the \g{node label} is a node 
identifier starting with \pp|N|, followed by an integer. The \g{item}, 
starting with \pp|I|, identifies the rule to be called. It is followed by
three integers \g{C1}, \g{C2}, and \g{C3} giving information on the required
stack size when calling the rule; these numbers are discussed later. After the 
description of the actual affixes the continuation is specified:
\g{false node} and \g{true node} identifies the nodes where the 
execution should continue when the call returns false and true (fail and
success), respectively. 
\g{False node} can be the number zero when the call cannot fail; it can be
\pp|-1| denoting true exit, and  \pp|-2| for false exit from this rule. 
In other cases these are node identifiers starting with \pp|N| followed by 
the node number. The \g{true node} is never zero.

The \g{affix} part describes the actual affixes of the call.
\begin{grammar}
\item affix: target integer; item; formal; local; limit type, item;

   Ddummy; indexed affix; anchor; Danchor.
\item limit type: Dupb; Dvup; Dlwb; Dvlwb; Dcalibre.
\item indexed affix: Dsub, item, affix, Dbus, selector.
\item anchor: Danchor, integer.
\end{grammar}
A \g{target integer} is a (signed) decimal integer starting with an \pp|X|.
An \g{item}, a \g{formal} or a \g{local} start with the letter \pp|I|,
\pp|F|, and \pp|L|, respectively, followed by an integer as discussed above.
When the actual affix is a limit, the \g{item} following the \g{limit type}
is either a global \g{item}, or a \g{formal} affix. Upper and lower bounds
can be either dynamic or static, see Section \ref{subsec:actual-virtual}, as
indicated by the different names.
The \g{Ddummy} symbol indicates the \g{dummy} actual affix meaning that the
result in the corresponding out affix can be discarded, see Section
\ref{subsec:dummy}. An \g{indexed affix} describes an indexing. The \g{item}
after the \g{Dsub} symbol is either a global or formal list which is to be
indexed. The \g{affix} gives the actual index (which can also be an indexed
affix), and \g{selector} is an integer giving the offset within the indexed
block: for the rightmost element of the block it is 1, and it increases by
one.

A \g{formal} or \g{local} in the affix list might be preceded by a
\g{Dcolon} symbol. It signals that in that affix the called rule returns a
value which is not used later, thus the caller can safely skip retrieving
and storing that value.

\smallskip

If the called rule has a variable number of affixes, then an \g{anchor}
appears at the \pp|@| affix position. The \g{integer} after \g{Danchor}
specifies the number of the following \emph{affix blocks} (not the number of
the affixes in those blocks) as provided by this rule call. This number is
strictly positive if the last actual affix in this call is \emph{not}
\pp|@|. If the last actual affix is \pp|@|, then this number is the negative
of the provided blocks (which, in this case, can be zero); and only in this
case is the last actual affix before the \g{false node} a single
\g{Danchor}.

\smallskip

The constants \g{C1}, \g{C2}, and \g{C3} for the called rule are computed as
follows. If the last actual affix of this call is \emph{not} \pp|@|, then
\g{C3} is zero, \g{C1} is the total number of the actual affixes, and \g{C2}
is the number of those affixes which either have type out or inout (they
contain output values), or are in some repeat block (independently of their
types). If the last actual affix is \pp|@|, then \g{C1} and \g{C2} are
computed as before for affixes \emph{before} the anchor affix position (for
affixes which are not in the repeat blocks). The value of \g{C3} is the
actaul number of affixes in the repeat blocks, except for the last actual
affix \pp|@|. Thus in this case \pp|C3| is zero exactly when the the only
actual variable affix is \pp|@|.

\subsubsection{Extension nodes}

An extension node tells that a (global or formal) stack should be
extended by a block, and specifies the content of the block.
\begin{grammar}
\item extension: Dextension, node, item, width, (field data)*, Dout, node.
\item field data: affix, (Dto, offset)*.
\end{grammar}
The \g{node} after the \g{Dextension} symbol is the node identifier; it
starts with the letter \pp|N| followed by an integer. The closing \g{node}
after the \g{Dout} symbol is the next node, which can be either \pp|-1| or
another node identifier (since an extension cannot fail). The \g{item} is 
the (global or formal) stack to be
extended, \g{width} is an integer giving the number of words in the
extension block. The \g{field data} defines the content of the block: \g{offset}
is an integer between 1 and \g{width}, and each offset occurs exactly once. The
same value, described by the \g{affix} can be stored at several offsets. The
block content (the values of the \g{affix}es in the \g{field data}) should
be computed \emph{before} the upper limit of the stack is adjusted.

\subsubsection{Classification nodes}

A classification node contains the affix in the classifier box together with
all areas and their destination nodes. While in an \A{} program the classifier
cannot be a constant, due to macro substitution, the linker should be prepared
for this case as well.
\begin{grammar}
\item classification: Dbox, node, affix, (area description)*.
\item area description: Darea, source line, zones, Dout, node.
\item zones: zone, (Dsemicolon, zone)*.
\item zone: list item; interval; value.
\item interval: (value; ), Dcolon, (value; ).
\item value: constant item; target integer.
\end{grammar}
The \g{node} after the \g{Dbox} symbol identifies the classification node.
It is followed by the affix specifying the classifier's value. Each area
starts with \g{Darea} followed by the source number of that area. This is
specified for the potential messages when the area cannot be selected. The
area ends with the success destination node. The area is a semicolon
separated list of \g{zone}s; the area succeeds if any of the zones succeeds.
Each \g{zone} is either a (global) list item standing for its complete
virtual address space, a constant item, a target integer, or an \g{interval}
where both the lower and upper bound may be missing.

After determining the constant values and the virtual limits of lists, the
linker checks that each area can be reached by some value of the \g{affix};
gives an error message if this is not the case. There is no
``otherwise'' part of a classification. If none of the areas succeeds, then
the program run is aborted with an error message. The linker gives a warning
if this might happen.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Target code}

The target code is produced exclusively by the \A{} linker from the
intermediate \I{} code of the main program, modules, and standard
library. In this implementation the target code is standard {\sf C}. It has
been chosen as a {\sf C} program can be easily compiled into an executable
binary, and {\sf C} also provides the basic tools for creating the running
environment, memory management and minimal file transput routines.

Code generation assumes that the basic \A{} data type, the \emph{word} has
32 bits; it is translated to \pp|int| in {\sf C}. Some efforts have been
made to allow code generation for a different word size architecture. In
this respect two more issues should also be addressed: what character
encoding is used, and how strings are represented in the target words. The
details given here assume that the target word size is 32 bit, and strings
are packed into UTF-8 encoded bytes. The present implementation makes no
assumption on the size of {\sf C} pointers.

\subsection{Tables, stacks}\label{subsec:tables-stacks}

An \A{} \g{table}, \g{stack}, \g{datafile} and \g{charfile} is represented
as an \emph{index} to a global array called \pp|a\_DATABLOCK|. This array is
split into structures specific to the required data type. Given the index
\pp|idx| of this array, the {\sf C} macros \pp|to\_LIST(idx)|,
\pp|to\_CHFILE(idx)| and \pp|to\_DFILE(idx)| cast the pointer to
\pp|a\_DATABLOCK[idx]| to a pointer to the corresponding list, character, or
datafile structure, respectively.

The \g{table} and \g{stack} structures have the following fields.
\def\HH{\noindent\hbox to 0.25\linewidth\bgroup~~}

\medskip

\HH\pp|int *offset|\HE the zero address virtual element of the list

\HH\pp|int *p|\HE  pointer to the beginning of the allocated memory block

\HH\pp|int length|\HE number of words in the allocated block

\HH\pp|int alwb,aupb|\HE actual lower and upper bounds

\HH\pp|int vlwb,vupb|\HE virtual lower and upper bounds

\HH\pp|int calibre|\HE  calibre of the list

\medskip

\noindent
The \A{} list element \pp|L[idx]| using the virtual address \pp|idx| (which
points to the \emph{virtual} address space of \pp|L|) is translated to the {\sf C}
construct \pp|to\_LIST(L)->\allowbreak offset[idx]|. List limits (actual and
virtual limits and calibre) are retrieved from this structure. There are no
direct pointers to list elements in the program, thus a list can be moved
freely in the memory as long as the pointers \pp|offset| and \pp|p| are
adjusted properly.

The \pp|unstack| and \pp|unstack to| externals adjust the actual upper bound
only. The \pp|release| external actually frees the complete allocated
memory, while \pp|scratch| only sets the actual upper bound to its lowest
possible value but keeps the allocated memory. The \pp|request space+L+n|
external checks that there are at least \pp|n| additional allocated words
above the actual upper bound of \pp|L|, and if not, then it allocates additional
memory. This may result in moving the whole list to somewhere else in the
actual memory, when \pp|offset| is adjusted accordingly.

When a stack is to be extended by a block of \pp|n| words in an
\g{extension}, the {\sf C} routine \pp|a\_extend(L,n)| is called first. This
routine makes sure that \pp|L| has an additional \pp|n| words of free space
at the top (by calling \pp|request space|), and, additionally, returns the
address of the first free slot at the top of \pp|L|. Subsequently the free
block is filled by assigning values to \pp|B[0]| to \pp|B[n-1]| where \pp|B|
is the address returned by \pp|a\_extend|. Finally, the actual upper bound
of \pp|L| is increased by \pp|n|.


\subsection{Data file}\label{subsec:datafile-implement}

As discussed in Section \ref{subsec:datafiles}, an \A{} datafile stores
integers (words), and pointers to lists. Such a datafile is
realized as a sequence of blocks of size \pp|1024*sizeof(int)|, and each block
\pp|B[0..1023]| is arranged as follows.

\smallskip

\def\HH{\noindent\hbox to 0.25\linewidth\bgroup\hskip\programindent}
\def\HE{\hss\egroup}

\HH \pp|B[0]|\HE magic number, identifying the \A{} datafile,

\HH\pp|B[1..31]|\HE bitmap for the rest of this block,

\HH\pp|B[32..1023]|\HE actual data.

\smallskip

\noindent
In the bitmap part there is a signle indicator bit for each word of the
block at index
$32\le \mbox{\tt i} \le 1023$. This bit is at word \pp|B[int(i/32)]| and
bit position \pp|(i\&31)| where zero is the most significant bit and 31 is the
least significant bit. The \pp|nil| pointer is a pointer with relative value
zero; the \pp|eof| (end of file) indicator is a pointer with relative value
$-1$; all other pointer values must be positive and belong to one of the
datafile zones.

The first few data values in the first block of the datafile contain the
\emph{zone list}. Each zone occupies three words: virtual lower and upper
bounds, and the numerical position of the list. The size of the list is in
\pp|B[32]|, data for the first zone is in \pp|B[33]|, \pp|B[34]|,
\pp|B[35]|, followed by data for the other zones. The list must fit into the
first data block. The lower and upper bounds (inclusive) are strictly
increasing (thus these ranges are disjoint and positive), therefore all
pointer values, with the exception of \pp|nil| and \pp|eof|, must be
positive.

Items in a datafile have positional data. The last 10 bits in this
file position identify the index within the block; this value must be
between 32 and 1023. Other bits of the position identify the block in which
the actual value can be found. This file position is stored internally, thus
there is no overhead in determining it. The file position can be retrieved for
both input and output datafiles, but one can only set the position for an
opened input datafile. No check is made to make sure that the position is
valid (so it can be set after the \pp|eof| indicator). Since a word contains
4 bytes and this address must be positive, an \A{} datafile cannot be larger
than about 8 Gbytes.

When opening a datafile for output, the first block is created with the 
specified zones sorted according to their virtual address ranges; the
file pointer is set just before the very first empty space.

Appending to an existing \A{} datafile is not implemented as it raises
several problems. The first block should be read and checked if it has the
same metainformation as the current file declaration requires, position it
to the last block, find the \pp|eof| mark, then set the file position just
at the \pp|eof| mark.

Opening a datafile for input requires the following operations: read the
first block, compare the zones in the input file to the ones supplied by the
file declaration. Comparison is made by the order of the lists in the
corresponding declarations. When the next input is requested, it is checked
whether it is a pointer or not. If it is numerical, pass as it is. If it is
a pointer, check which list it is in, add the correction difference and pass
it as a pointer. Handle \pp|nil| and \pp|eof| separately. If the zone is not
found (the corresponding list was not supplied when opening the datafile),
then fail and skip this input. This error condition can be retrieved from
the \pp|file error| associated with the \A{} \g{file}.

The datafile structure stored in \pp|a\_DATABLOCK| has the following fields:

\medskip

\def\HH{\noindent\hbox to 0.4\linewidth\bgroup\hskip\programindent~}%

\HH\pp|unsigned fflag| \HE different flag bits

\HH\pp|int      fileError| \HE last file error

\HH\pp|int      st1,st2|    \HE string pointers

\HH\pp|int      fhandle|    \HE handle, zero if not opened

\HH\pp|int      fpos|       \HE file position

\HH\pp|unsigned iflag| \HE pointer/numerical flag for 32 words

\HH\pp|int inarea,outarea| \HE number of areas

\HH\pp|a\_AREA  in[MAXIMAL\_AREA]| \HE input list areas

\HH\pp|a\_AREA out[MAXIMAL\_AREA]| \HE output list areas

\HH\pp|int      buffer[1024]| \HE the buffer

\medskip

\noindent
The string pointers \pp|st1| and \pp|st2| identify the string supplied by
the file declaration. This string is used as a file name when the file is
used without explicitly opening.

\subsection{Character file}\label{subsec:charfile}

While datafiles use direct file input and output, character files use
streams, namely the \pp|fgetc()| and \pp|fputc()| \g{C} library procedures
without the \pp|ungetc()| facility. The input is assumed to be proper UTF-8
encoded file, incorrect codes are silently ignored. The \A{} rule \pp|get char|
may consume up to four bytes from the input stream. There is no \pp|newpage|
character, and writing \pp|newline| sends the newline character (code 10) to
the stream.

Input character files can be positioned as well, but they use \pp|ftell()|
to retrieve the current file position and \pp|fseek()| to set the file
position.

The charfile structure in \pp|a\_DATABLOCK| has the following fields:
\medskip

\HH\pp|unsigned fflag| \HE different flag bits

\HH\pp|int      fileError|\HE last file error

\HH\pp|int      st1,st2| \HE string pointers

\HH\pp|FILE     *f|      \HE stream handle, \pp|NULL| if not opened

\HH\pp|int      aheadchar|\HE look ahead character

\medskip

\noindent
The \pp|aheadchar| stores the next (unread) UTF-8 character when a
look-ahead was made. This happens, for example, when an integer is read from
the file by the standard rule \pp|get int|. This rule should stop at the first
non-digit character, but not consume that character.

\subsection{Strings}

\A{} strings use Unicode characters, and they are stored using UTF-8
encoding as {\sf C}
strings with \pp|{\char92}0| as the last byte. If the string is in list \pp|L|
pointed by the (virtual) index \pp|idx|, then the content of the list block
is

\def\HH{\noindent\hbox to 0.25\linewidth\bgroup\hskip\programindent}%
\smallskip

\HH\pp|L[idx]|\HE width (calibre) of this block in words

\HH\pp|L[idx-1]|\HE number of UTF-8 encoded characters in the string

\HH\pp|L[idx+1-width]|\HE start of the {\sf C} string

\smallskip
\noindent
The empty string is stored as a block of \pp|(0,0,3)|.

\subsection{Rules in {\sf C}}\label{subsec:c-rules}

Each rule declaration is translated to a {\sf C} procedure declaration. If
the rule is of type \emph{function}, \emph{action}, or \emph{exit}, then the
procedure is \pp|void|; if it is a \emph{question} or \emph{predicate}, then
it is \pp|int|. The compiled {\sf C} routine returns \pp|0| for failure and
\pp|1| for success, but when checking the returned value, any non-zero
return value is taken for success.

In \A{} it is the caller's responsibility to store the output value in its
destination, and do it only if the called routine reports success. According
to this requirement, \g{formal affix}es are transformed into {\sf C}
parameters as follows. First, assume that the called rule has no variable
affix block. Affixes which are neither \g{out} nor \g{inout} ones (that is,
\g{file}, \g{stack}, \g{table}, or \g{in}) are passed as integers in their
original order. A local integer array is declared for the \g{out} and
\g{inout} affixes, and this array, containing the value of these affixes in
their original order, is passed as the last parameter. Before returning, the
called routine supplies the output values in this array, which values are
then stored by the caller.

Rules with a variable affix block have two additional parameters: an
integer containing the number of blocks (with a value of
at least one), and an integer array containing all affixes in the variable
block regardless of their types. The \pp|shift affix block| rule is
implemented by decreasing the block counter by one, and adding the block
length to the last parameter. The following table shows some \g{formal affix
sequence}s and the corresponding {\sf C} parameter declarations:

\smallskip

\begin{tabular}{ll}
\pp|+t[]+>i|   & \pp|(int t,int i)|              \\
\pp|+""f+o>|   & \pp|(int f,int A[1])|\\
\pp|+>io>+o>|   & \pp|(int A[2])|\\
\pp|+>io>+@+>i| & \pp|(int A[1],int Cnt,int *V)|\\
\end{tabular}

\smallskip
\noindent
The called routine must set all out affixes in the output parameter
\pp|A[]|, otherwise it is free to change (and use) these values
if the routine fails. In the variable block \pp|V[]|, however,
values corresponding to not out or inout affixes
cannot be changed, and the value 
of an inout affix should change only if the routine returns with success.

\subsection{Externals}\label{subsec:externals}

External declarations are allowed in library mode only (see Section
\ref{subsec:library}). The interpretation of the \g{string denotation} in the 
external declaration depends on the type of the defined tag.

\subsubsection{External constant and variable}

External constants cannot be used in expressions or other places where a 
constant tag is required. In the {\sf C} external variables and constants 
can appear as rule parameters; they are replaced by the string specified in 
the \g{external declaration}.

\subsubsection{External table and stack}

A list structure is reserved in the global integer array \pp|a\_DATABLOCK|
as explained in Section \ref{subsec:tables-stacks}. The string in the
external declaration is used as the name of a {\sf C} procedure which is
responsible for initializing this structure. The routine is called with
three arguments: the index of the associated structure, a constant string
with the name of the list, and the calibre.
The routine must fill the actual and virtual limits and the calibre.
There is a (relatively small) virtual address space set aside for external
lists. The first free virtual address is in \pp|a\_extlist\_virtual|; the
address can go up to \pp|max int|. The routine should update this value to
reflect its reservation. The routine is also responsible for allocating memory
and initializing the content of external tables.

\subsubsection{External files}

The corresponding charfile or datafile structure is reserved in the global
array \pp|a\_DATABLOCK|. For the description see Sections
\ref{subsec:datafile-implement} and \ref{subsec:charfile}. The string in the
external declaration is used as the name of a {\sf C} procedure which is
responsible for
initializing the structure. The procedure is called with two arguments:
the index of the structure and the name as a character string.

\subsubsection{External rules}

How an external rule is handled depends on the \g{string denotation}. If it
starts with a (lower or upper case) letter, then the external rule is
assumed to be a {\sf C} procedure with exactly the same parameter passing
mechanism as the compiled rules, see Section \ref{subsec:c-rules}. There
must be a header file providing the prototypes of these external procedures,
it can be added to the generated code using a \pp|front matter| pragmat.
Several standard library rules are implemented this way.

If the first character in the \g{string denotation} of the
external rule is an underscore \pp|\_|, 
then another calling mechanism is used: all affixes, independently
of their types, are passed as parameters. Such external rules are typically
defined as
{\sf C} macros; an example is the \pp|incr+>x>| external rule whose
\g{string denotation} is \pp|\_a\_incr|. The \A{} rule call \pp|incr+ptr|
translates to \pp|a\_incr(ptr)|. The standard library header file 
contains the {\sf C} macro definition
\begin{program}
 \#define a\_incr(x)   x++
\end{program}
\noindent
which makes the final translation.

The \g{dummy affix} \pp|\#| translates to nothing, thus it leaves an empty
parameter location. Using some {\sf C} preprocessor tricks these empty
arguments can be transformed to different {\sf C} procedure calls. To ease
this work, the \A{} compiler does some additional work. If the \g{string
denotation} of the external rule starts with a \pp|@|, then this character
is discarded. For each out argument, depending on whether it is the \g{dummy
symbol} or not, a \pp|0| or a \pp|1| character is appended to the remaining
string. Finally, \g{dummy symbol}s are discarded from the argument list. In
the standard library the external rule \pp|divrem| has two out affixes, and
its \g{string denotation} is \pp|@a_divrem|. Accordingly, four {\sf C} calls
could be generated: \pp|a\_divrem11| with four parameters when both the
quotient and remainder is used, the three parameter \pp|a\_divrem01| and
\pp|a\_divrem10| when the quotient or remainder is discarded; and the two
parameter \pp|a\_divrem00| when no result is requested at all.

The external rule strings \pp|@@make| and \pp|@@waitfor| are exceptions;
these rules are handled internally by the linker when generating code for
transput (assignment) and for the \pp|wait for| rule.

If all out arguments of a function are discarded, then the rule is not
called at all. Similarly, if the returned value of a question is not used,
then the question is not called. It might cause problems when the function
or the question performs some conditional tasks before calling an \g{exit} rule
(Section \ref{subsec:exit}), as those checks will not be carried over.


% =============================================================================


\begin{thebibliography}{99}
\bibitem{aho-ullman}
A.V. Aho, J.D. Ullman,
\emph{Principles of Compiler Design}
Sseries in computer science and information processing,
Addison-Wesley, 1977

\bibitem{A-manual}
D.Grune, R. Bosch, L.G.L.T.Meertens,
\emph{ALEPH Manual}
CWI, IW17/74, Stichting Mathematisch Centrum, Amsterdam, 
Fourth printing, 1982

\bibitem{grune}
D.Grune,
\emph{On the design of ALEPH},
CWI Tract 13, Centre for Mathematics and Computer Science, Amsterdam, 1982

\bibitem{koster1}
C.H.A.Koster,
\emph{A Compiler Compiler},
CWI Report MR127/71,
Mathematical Centre, Amsterdam, 1971

\bibitem{koster2}
C.H.A.Koster,
\emph{Affix Grammars}, in:
J.E.L.Peck (Ed.), \emph{ALGOL 68 Implementation}, North Holland, Amsterdam,
1971

\bibitem{koster3}
C.H.A.Koster,
\emph{Using the CDL compiler}, in
F.L.Bauer and J.Eickel (Eds.) \emph{Compiler Constructions}
LNCS 21, Springer, 1974

\bibitem{cdl3}
C.H.A.Koster, J.G.Beney, P.A.Jones, M.Seutter,
\emph{CDL3 manual},
available as \url{https://ftp.science.ru.nl/cdl3/cdl3-manual-1.2.7.pdf}

\bibitem{wijn}
A.van Wijngaardeen,
\emph{The generative power of two-level grammars}, in
J.Loecks (Rd.), \emph{Automata, Languages and Programming},
LNCS 14, Springer, 1974

\bibitem{a68}
A.van Wijngaarden, B.J. Mailloux, J.E.L. Peck,
C.H.A.  Koster, M. Sintzoff, C.H. Lindsey, L.G.L.T. Meertens, R.G. Fisker,
\emph{Revised Report on the Algorithmic Language ALGOL 68},
Springer Science \& Business Media, 2012

\end{thebibliography}


\end{document}
