$ Standard ALEPH Library
'cons'max int,min int. $ maximal and minimal integers
$ arithmetic
'f' add+>x+>y+z>,       $  x+y -> z
    subtr+>x+>y+z>,     $  x-y -> z
    mult+>x+>y+z>,      $  x*y -> z
    addmult+>x+>y+>z+u>,$  x*y+z -> u
    div+>x+>y+z>,       $  integer part of x/y -> z
    divrem+>x+>y+z>+u>, $  x/y -> z, remainder -> u
    incr+>x>,decr+>x>,  $ increase, decrease by 1
    getabs+>x+y>,       $ |x| -> y
    max+>x+>y>,         $ max(x,y) -> y
    min+>x+>y>.         $ min(x,y) -> y
$ comparison
'q' equal+>x+>y,not equal+>x+>y,less+>x+>y,lseq+>x+>y,
    more+>x+>y,mreq+>x+>y.
'q' is+>x,is true+>x,   $ x is NOT zero
    is false+>x.        $ x is zero
'f' bool invert+>x+y>,  $ 32 bit complement
    bool and+>x+>y+z>,bool or+>x+>y+z>,
    bool xor+>x+>y+z>,  $ bitwise Boolean operations
    left clear+>x>+>n,  $ shift left, zeros enter from right
    right clear+>x>+>n. $ shift right, zeros enter from left
$ tables and stacks
'q' was+t[]+>ptr.       $ true if ptr points into t[]
'f' next+t[]+>p>,       $ increase/decrease by block size
    previous+t[]+>p>,
    list length+t[]+n>. $ total number of words in t[]
'a' unstack+[]st[],     $ discard the topmost block
    unstack to+[]st[]+>p,$ move the top to the given pointer
    scratch+[]st[],     $ empty the stack, but keep memory
    release+[]st[].     $ release the stack memory
'p' request space+[]st[]+>n.
      $ extend the allocated memory (but not the upper bound) by n
$ strings
'f' string length+t[]+>p+n>,string width+t[]+>p+n>.
      $ length: number of characters, width: table elements
'f' previous string+t[]+>p>.
      $ move back by string width
'f' compare string+t1[]+>p1+t2[]+>p2+comp>,
    compare string n+t1[]+>p1+t2[]+>p2+>n+comp>.
      $ compare two strings up to 'n' characters
'q' string elem+t[]+>p+>n+chr>.
      $ retrieve the n-th character of the string
'a' unstack string+[]st[].
      $ remove the string from the top of the stack
'a' pack string+from[]+>n+[]to[].
      $ the last 'n' elements of 'from' are characters, pack them
      $    to a string to the top of 'to'
'a' unpack string+from[]+>p+[]to[].
      $ unpack characters of the string to the top of 'to'
'a' copy string+from[]+>p+[]to[].
      $ copy the string to the top of 'to'
$ files
'p' open file+""f+>mode+t[]+>p.
      $ open a file with the given path, mode is /r/ or /w/
'p' open temp file+""f+[]st[]+>p.
      $ file name must end with XXXXXX, create a temp file
'a' close file+""f.
      $ close the file
'a' unlink file+t[]+>p.
      $ remove the file
'f' get file error+""f+err>.
      $ retrieve the last file error, zero for no error
'f' get file pos+""f+pos>.
      $ get file position, valid only when reading
'a' set file pos+""f+>pos.
      $ set file position when opened for reading
$ data input and output
'cons'numerical,pointer.$ data type
'p' get data+""f+data>+type>.
      $ read the next word, fail on error
'p' put datap+""f+>data+>type.
      $ write a word; fail and set error number,
'a' put data+""f+>data+>type.
      $ write a word, abort in case of error
$ character input / output
'cons'newline.          $ the newline character
'p' get char+""f+char>,ahead char+""f+char>.
      $ read or peek next character, fail on EOF
'p' get line+""f+[]st[]+ctrl>.
      $ read characters up to a newline to 'st'
'p' get int+""f+n>.
      $ read an integer, fail if next char is not sign or digit
'a' put char+""f+>char,put line+""f+t[]+>ch,
    put int+""f+>n,put string+""f+t[]+>ptr.
      $ write a character, a whole line, an integer, or a string
'a' fprintf+""f+t[]+@+>p.
      $ formatted output; additional affixes are printed as
      $  %c   character
      $  %d   integer
      $  %x   hexadecimal
      $  %n   newline (no affix consumed)
$ character input from STDIN and output to STDOUT
'charfile'STDIN,STDOUT. $ standard input and output
'p' getc+c>.            $ read a character from STDIN
'a' print char+>c,print int+>n.
'a' print string+t[]+>p,printf+t[]+@+>p.
      $ output to STDOUT
$ other
'e' exit+>code.         $ terminate program with exit value
'a' msleep+>ms.         $ sleep for ms milliseconds
'a' backtrack.          $ if linked with -g, print execution stack
'table'STDARG.          $ command line arguments as strings
'a' wait for+t[]+>p.    $ module root synchronization
'f' string hash+t[]+>p+hash>, block hash+t[]+>p+hash>.
                        $ simple and fast 32 bit hash values
'end'