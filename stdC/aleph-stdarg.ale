$ standard ALEPH library -- command-line arguments
'pragmat'module=stdlib,title="stdlib stdarg".

$ *************************************************************
$  This code is part of ALEPH-M (Modular ALEPH-v2.1)
$
$  (C) 2020-2024, L.Csirmaz
$
$  ALEPH-M is a free software, your can redistribute and/or
$  modify it under the terms of the GNU General Public License
$  as published by the Free Software Foundation, either version
$  3 of the License, or (at your option) any later version.
$
$  ALEPH-M is distributed in the hope that it will be useful,
$  but WITHOUT ANY WARRANTY; without even the implied warranty
$  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
$  the GNU General Public License for more details.
$
$ ************************************************************* 

$ HEADER ****************************************************** $
$ command line argument strings in reverse order
'table'STDARG.

$ BODY ******************************************************** $
'pragmat'if=compile,library mode=on.

'pragmat'front matter="static void a_setup_stdarg(int,const char*,int);".
'x''table'STDARG="a_setup_stdarg".
'pragmat'back matter=
"extern int a_argc; extern char **a_argv;%n"
"static int a_push_string_to(int F1,const char*ptr){"
" int n,w;int*goal;char*to;%n"
" #define st to_LIST(F1)%n"
" n=strlen(ptr);if(a_requestspace(F1,3+(n/4))==0){return 0;}%n"
" n=0;goal=&(st->offset[1+st->aupb]);to=(char*)goal;%n"
" while(*ptr){if((*ptr&0x80)==0){*to++=*ptr++;n++;}"
"  else if((*ptr&0xC0)!=0xC0){ptr++;}"
"  else if((*ptr&0xE0)==0xC0){*to++=*ptr++;n++;"
"   if((*ptr&0xC0)!=0x80){n--;to--;}else{*to++=*ptr++;}}"
"  else if((*ptr&0xF0)==0xE0){*to++=*ptr++;n++;"
"   if((*ptr&0xC0)!=0x80){n--;to--;}else{*to++=*ptr++;"
"    if((*ptr&0xC0)!=0x80){n--;to-=2;}else{*to++=*ptr++;}}}"
"  else if((*ptr&0xF8)==0xF0){*to++=*ptr++;n++;"
"   if((*ptr&0xC0)!=0x80){n--;to--;}else{*to++=*ptr++;"
"    if((*ptr&0xC0)!=0x80){n--;to-=2;}else{*to++=*ptr++;"
"     if((*ptr&0xC0)!=0x80){n--;to-=3;}else {*to++=*ptr++;}}}}"
"  else{ptr++;}}%n"
" *to=0;w=1+(to-((char*)goal))/4;goal[w]=n;goal[w+1]=w+2;st->aupb+=w+2;%n"
" #undef st%n"
" return 1;"
"}%n"
"static void a_setup_stdarg(int F1,const char*name,int F2){%n"
" int i;%n"
" #define st to_LIST(F1)%n"
" st->name=name;st->offset=st->p=0;st->length=0;"
" st->vlwb=a_virtual_max+16;a_virtual_max+=65436;"
" if(a_virtual_max<=0){fprintf(stderr,""Out of virtual space\n"");"
"  a_fatal(a_FATAL_memory);}%n"
" st->vupb=a_virtual_max-1;st->calibre=F2;"
" st->alwb=st->vlwb;st->aupb=st->alwb-st->calibre;%n"
"  for(i=a_argc-1;i>0;i--){"
"   if(a_push_string_to(F1,a_argv[i])==0){"
"    fprintf(stderr,""out of memory\n"");a_fatal(a_FATAL_memory);}"
" }%n"
" #undef st%n"
"}".


'root'+.

'pragmat'endif=compile.
'end'

