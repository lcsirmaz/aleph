'pragmat'title="ale1".
$ ***************** FILES ***************** $
'charfile' SOURCE = >"stdin".
'charfile' PRINTFILE = "stdout">.

'datafile'DISC[DSYMB;LADM;LLOC;TTAG] = "out,bin">.

$ ************ GLOBAL CONSTANTS AND VARIABLES *********$
'constant' max datafile area=32. $ maximal size of the structure
'constant' T=1,F=0.
'variable' root scanned=0,
   link list=0, $ declared table and stack
   link cons=0, $ declared constants and variables
   link file=0, $ charfile, datafile
   link ext=0,  $ external cons/var/table/stack
   link rule=0. $ external rule

$ pragmat values for round I $
'variable'
 dict on=0,                      $ dictionary=on/off
 dict mark=0,                    $ mark single occurences
 tab width=8, new tab width=8,   $ tab width=8
 give text=0, new give text=0,   $ list=on/off
 in library=0,                   $ library=on/off
 in module=0,                    $ module=on (cannot switch it off)
 in compile=1,                   $ compile=on is in effect
 std lib=1,                      $ stdlib=no (include standard lib)
 pm dump=0,                      $ dump=rule/global/all/on/off
 program title=0.                $ title, pointer to LEXT

$ ************ STACKS AND INFORMATION RETRIEVAL *************** $
'a'extend+[]L[]+>x:     (*x -> L*)L.
$'a'unstack+[]L[]+x>:
$        L[>>L] -> x, (-y: subtr+>>L+1+y, unstack to+L+y).

$ ------------------------------------------------------------- $

$ THE STACK "DICT" -- line numbers where the identifier occours $
'stack'[35](line,ptr=DICT)DICT.
'f'get text+>t+x>: text*TTAG[t] -> x.
'a'put text+>t+>x: x->text*TTAG[t].

$ 1 .. 2029     add that much to the previous line
$ 2047          add 2000 to the previous line
$ 2046          previous entry is a definition

'f'pack2+>d+>n+x>:
    d->x,left clear+x+11,bool or+x+n+x.
'f'unpack2+>x+d>+n>:
    bool and+x+0x7FF+n,x->d,right clear+d+11.
'a'expand DICT+>ptr+>x-z:
    subtr+>>DICT+ptr*DICT[ptr]+z,incr+z,
    pack2+z+x+z,extend+DICT+z,>>DICT->ptr*DICT[ptr].
'a'add line to DICT+>ptr+>n: $ n!=0
    n<2030,expand DICT+ptr+n;
    expand DICT+ptr+2047,subtr+n+2000+n,:add line to DICT.
'a'add DICT+>tag+>line-l1-dict-ptr:
   dict on=0;
   get text+tag+dict,
    (dict=0,>>DICT->ptr,next+DICT+ptr,
        (*line->line,ptr->ptr*)DICT,put text+tag+ptr;
     line<=0,expand DICT+dict+2046;
     subtr+line+line*DICT[dict]+l1,
       (l1=0;line->line*DICT[dict],add line to DICT+dict+l1)).
'a'get DICT reverse+>dict-ptr-ptr1-l-n-d-d1:
   line*DICT[dict]->l,ptr*DICT[dict]->ptr,0->d1,
     (nxt: ptr<=dict;
         unpack2+DICT[ptr]+d+n,subtr+ptr+d+ptr1,
         pack2+d1+n+DICT[ptr],d->d1,ptr1->ptr,
         (=n=
          [1:2029],subtr+l+n+l;
          [2047],subtr+l+2000+l;
          +),:nxt),
     l->line*DICT[dict],add+d1+ptr+ptr,ptr->ptr*DICT[dict].
'a'release DICT:
   release+DICT.
$ ------------------------------------------------------------- $
$ THE STACK "LEXT" -- all strings $
'stack'[16]LEXT=(
  ""               :empty string,
  0                :link string init, $ starting with ""
$ default strings
  "a.out"          :default title,
  "alib.ale"       :stdlib file,
  "/tmp/aleph.tmp" :disc file,
  "/tmp/aleph.s"   :target file
).

$ ------------------------------------------------------------- $
$ THE STACK "LLOC" -- formal and local affixes $
'stack'[2](flag,repr,type,tag,orepr=calibre,otype=ssel=LLOC)LLOC.

$ ------------------------------------------------------------- $
$ THE STACK "LADM" -- info for each identifier $
$         (type, repr, adm, tag)
$    (ssel,esize,fsize,flag,calibre)
$    (ssel,vlwb, vupb, flag,calibre)
$         (dnum, dpos, adm, tag)
$               (dpos, adm, tag)
$                     (adm, tag)
'stack'[30](ssel,type=esize=vlwb=dnum,repr=fsize=vupb=dpos,adm=flag,tag=calibre)LADM.

'f'get tag+>tag+x>:     tag*LADM[tag]->x.
'f'get type+>tag+x>:   =tag= [LADM],type*LADM[tag] -> x;
                             [LLOC],type*LLOC[tag] -> x;
                             error+internal error,'exit'3.
'a'put type+>tag+>x:    x -> type*LADM[tag].
'f'get repr+>tag+x>:    repr*LADM[tag] -> x.
'a'put repr+>tag+>x:    x -> repr*LADM[tag].
'f'get adm+>tag+x>:     adm*LADM[tag] -> x.
'a'put adm+>tag+>x:     x -> adm*LADM[tag].

'f'get vupb+>tag+x>:    vupb*LADM[repr*LADM[tag]] -> x.
'a'put vupb+>tag+>x:    x->vupb*LADM[repr*LADM[tag]].
'f'get vlwb+>tag+x>:    vlwb*LADM[repr*LADM[tag]] -> x.
'a'put vlwb+>tag+>x:    x-> vlwb*LADM[repr*LADM[tag]].
'f'get esize+>tag+x>:   esize*LADM[repr*LADM[tag]] -> x.
'a'put esize+>tag+>x:   x->esize*LADM[repr*LADM[tag]].
'f'get calibre+>tag+x>: =tag=[LADM],calibre*LADM[repr*LADM[tag]] -> x;
                        $[LLOC],$ calibre*LLOC[tag]->x.
'a'put calibre+>tag+>x: x->calibre*LADM[repr*LADM[tag]].
'f'get fsize+>tag+x>:   fsize*LADM[repr*LADM[tag]] -> x.
'a'put fsize+>tag+>x:   x->fsize*LADM[repr*LADM[tag]].
'f'get flag+>tag+x>:    flag*LADM[repr*LADM[tag]]->x.
'a'put flag+>tag+>x:    x->flag*LADM[repr*LADM[tag]].
'f'get ssel+>tag+x>:    =tag=[LADM],ssel*LADM[repr*LADM[tag]]->x;
                             [LLOC],ssel*LLOC[tag]->x;
                             error+internal error,'exit' 3.
'a'put ssel+>tag+>x:    x->ssel*LADM[repr*LADM[tag]].

$ ------------------------------------------------------------- $
$ AUXILIARY STACKS $
'stack'[2]BUFFER.

$ INPUT files $
'stack'[1](n,string)INPUT.

$ string "ptr" is in LEXT $
$ check if it has not been added.
'a'add include+>ptr: (* -1->n,ptr->string *)INPUT.
'a'add all args-ptr-n:
  >>STDARG->ptr,(nxt:ptr<<<STDARG;
     scratch+BUFFER,unpack string+STDARG+ptr+BUFFER,
     list length+BUFFER+n,pack string+BUFFER+n+LEXT,
     add include+>>LEXT,string width+STDARG+ptr+n,subtr+ptr+n+ptr,:nxt).
'f'find linenum+>from+n>+str>-ptr-nptr:
  <<INPUT->ptr,(nxt: 
     add+ptr+<>INPUT+nptr,
     ((>>INPUT < nptr;n*INPUT[nptr]<0;from<n*INPUT[nptr]),
         subtr+from+n*INPUT[ptr]+n,incr+n,string*INPUT[ptr]->str;
      nptr->ptr,:nxt)).
$ ***************** BASIC INPUT-OUTPUT ************************ $
$ Character input $

'constant'end char=5000, str char=end char+4.
'constant'tabchar=9.
'variable'char=/ /,
    pchar=0,   $ read character position within the line $
    ppline=0,  $ postponed newline from string denoters $
    was tab=0, $ tab read, emit that much spaces
    LEXTptr=0, $ when reading from LEXT
    LEXTcnt=0, $ character counter
    LEXTlen=0, $ total length
    exhausted=-4.

'variable'uchar=0.
'a'unget char+>ch:
    char->uchar,ch->char.

'p'read char+char>:
    is+LEXTptr,
       (LEXTcnt=LEXTlen,/./->char,incr+LEXTcnt;
        LEXTcnt<LEXTlen,string elem+LEXT+LEXTptr+LEXTcnt+char,incr+LEXTcnt);
    get char+SOURCE+char.
'a'next char:
    is+uchar,uchar->char,0->uchar;
    display char,
    (nxt-x:
     was tab > 0, decr+was tab, / /->char, incr+pchar;
     read char+char,incr+pchar,
        (=char=
         [newline], 0 -> pchar,
             new give text->give text, new tab width->tab width;
         [tabchar], / /->char, subtr+pchar+1+x,
                  divrem+x+tab width + x + was tab,
                  subtr + tab width + was tab + was tab,
                  decr+was tab;
         [:31], :nxt;
        +);
     exhausted < -2, incr+exhausted, newline -> char;
     exhausted < 0, incr+exhausted, end char -> char;
     exhausted = 0, error+internal error, 1->exhausted;
     end char -> char
    ).
$'p'letter+x>: = char =
$    [/ /], next char,:letter;
$    [/A/:/Z/;/a/:/z/], char -> x, next char;
$    [/@/], is+in library, char -> x, next char;
$    -.
'p'bold letter+x>: =char=
    [/a/:/z/],char->x,next char;
    -.
'p'digit+x>: = char =
    [/ /], next char,:digit;
    [/0/:/9/], subtr+char+/0/+x,next char;
    -.
'p'hexdigit+x>: = char =
    [/ /], next char,:hexdigit;
    [/0/:/9/], subtr+char+/0/+x,next char;
    [/a/:/f/], subtr+char+/a/+x,add+x+10+x,next char;
    [/A/:/F/], subtr+char+/A/+x,add+x+10+x,next char;
    -.
'p'letgit+x>: = char =
    [/ /], next char,:letgit;
    [/A/:/Z/;/a/:/z/;/0/:/9/], char -> x, next char;
    [/@/], is+in library, char -> x, next char;
    -.
'a'next visible char:
    char=/ /,next char,:next visible char;
    char=newline,incr+ppline,next char,:next visible char;
    +.
'a'init char+>fidx: $ reset default values $
    0->pchar,new give text->give text,new tab width->tab width,
    -4->exhausted, 0->optor,0->pr line, 0->ppline, 0->was tab,
    (is+fidx,0->LEXT ptr;+),
    newline->char,next char, next visible char.
$ start reading from LEXT
'a'init LEXT char+>lidx:
    lidx->LEXTptr,string length+LEXT+LEXTptr+LEXTlen,
    2->LEXTcnt,init char+0.

$ PRINT SECTION $
'constant'count col=2,progcol=9.
'variable'prpos=0, old prpos=1, prpos ok=1, pr line=0.

'a'print char+>ch: incr+prpos,put char+PRINTFILE+ch.
'a'display char:
    char=newline, incr+pr line, T->prpos ok, print line head;
    (is+give text, exhausted<0),
        (is+prpos ok; T->prpos ok,tab line+old prpos),
        (=char=
         [str char], print char+/*/;
         [end char], +;
         print char+char
        );
    +.
'a'save prpos:
    is+prpos ok, F->prpos ok, prpos->old prpos;
    +.
'a'tab line+>pos:
    prpos = pos;
    prpos > pos, nlcr,:tab line;
    print char+/ /,:tab line.
'a'print int+>n:
    n=min int, print char+/-/, subtr+-1+n+n,%print int1+n+/1/;
    n<0, print char+/-/,get abs+n+n,%print int1+n+/0/;
    %print int1+n+/0/.
'a'%print int1+>n+>c-q-r:
    divrem+n+10+q+r,(q=0; %print int1+q+/0/),
        add+r+c+r, print char+r.
'a'print form+>n: %print form1+n+4.
'a'%print form1+>n+>m -q-r:
    m=0;
    decr+m, divrem+n+10+q+r, %print form1+q+m, add+r+/0/+r, print char+r.
'a'nlcr:
     prpos<=1;
     0->prpos, put char+PRINTFILE+newline.
'a'print line head:
    is+give text, nlcr, tab line+count col, print form+pr line,
        tab line+prog col;
    +.
'a'print pointer+>ptr:
    ptr=0,print+"[NULL]";
    was+SPECIAL+ptr,print+SPECIAL+ptr; $ Spoint $
    was+LADM+ptr,tag*LADM[ptr]->ptr,:print pointer;
    was+TTAG+ptr,previous+TTAG+ptr,print+TTAG+ptr;
    was+LEXT+ptr,print+LEXT+ptr; $ string $
    was+INDICATOR+ptr,print+INDICATOR+ptr; $ type $
    was+LLOC+ptr,tag*LLOC[ptr]->ptr,:print pointer;
    print+"[?",print int+ptr,print+"]".
'a'format print+T[]+*+>fmt-optr-ptr:
    $ format: %c - char, %d - integer, %p - pointer %* - skip
    >>BUFFER->optr,unpack string+T+fmt+BUFFER,optr->ptr,incr+ptr,
    (nxt:>>BUFFER < ptr;
        BUFFER[ptr]!=/%/,print char+BUFFER[ptr],incr+ptr,:nxt;
        incr+ptr,( >>BUFFER<ptr,print char+/%/;
                   (=BUFFER[ptr]=
                     [/d/],(shift vararg block+*,print int+fmt;print+"[?]");
                     [/c/],(shift vararg block+*,
                              (=fmt=
                               [newline], print+"<newline>";
                               [end char], print+"<file end>";
                               print char+fmt);
                            print+"[?]");
                     [/p/],(shift vararg block+*,print pointer+fmt;print+"[?]");
                     [/*/],(shift vararg block+*;+);
                     print char+BUFFER[ptr]), incr+ptr,:nxt)),
    (shift vararg block+*,print+"[...]";+),
    unstack to+BUFFER+optr.
'a'print base+T[]+>str-obuff-ptr:
   $ print the base of a path
   >>BUFFER->obuff,unpack string+T+str+BUFFER,>>BUFFER->ptr,
   $ go back until /, \, :
   (nxt: ptr<=obuff;
         BUFFER[ptr]=///;
         BUFFER[ptr]=/\/;
         BUFFER[ptr]=/:/;
         decr+ptr,:nxt),incr+ptr,
   $ print until the first dot
   (nxt: >>BUFFER < ptr;
         BUFFER[ptr]=/./;
         print char+BUFFER[ptr],incr+ptr,:nxt),
   unstack to+BUFFER+obuff.
'a'print+T[]+>p -n:
    was+T+p,put string+PRINTFILE+T+p, $print char+/ /,$
        string length+T+p+n,add+prpos+n+prpos;
    +.
$ ============================================================ $
$ DICTIONARY $
'constant'right hand margin=80.

'a'DICT tab-r:
   prpos>right hand margin,tab line+6;
   print char+/ /,divrem+prpos+6+#+r,(r=1;:DICT tab).
'a'DICT flush+>text-ptr-l-n-d-src-src1-cnt:
   (prpos<8,tab line+8;+),
   0->src->n->cnt,text->ptr,
   line*DICT[text]->l,subtr+ptr*DICT[text]+ptr+d,
   (nxt:(n=2046,print char+/*/,incr+cnt;
         n=2047,add+l+2000+l;
         add+l+n+l,add+cnt+2+cnt,find linenum+l+n+src1,
          (src=src1;
           src1->src,DICT tab,print base+LEXT+src,print char+/:/),
          DICT tab,print form+n
        ),
        (d=0;add+ptr+d+ptr,unpack2+DICT[ptr]+d+n,:nxt)
   ),
   ((cnt=3,is+dict mark),print char+/*/;+).
'a'DICT tag+>tag-text:
    get text+tag+text,
    (is+text,nlcr,print pointer+tag,get DICT reverse+text,
     DICT flush+text,nlcr;+).
$ ============================================================ $
$ DISC SECTION $
'a'open disc+>mode-err:
    open file+DISC+mode+LEXT+disc file;
    get file error+DISC+err,
       Xerror+cannot open disc file+disc file+err,
       'exit' 2.
'a'close disc:
    close file+DISC.

'a'D+>x:
    put data+DISC+x+pointer.
'a'D cons+>n:
    put data+DISC+n+numerical.
'a'D tag+>tag:
    was+LADM+tag,(has formal type+tag,D+repr*LADM[tag];D+tag);
    error+internal error,'exit' 3. $D+tag$
'a'D string+>x-y:
    string width+LEXT+x+y,subtr+x+y+y,incr+y,
    (nxt:y<=x,D cons+LEXT[y],incr+y,:nxt;+).

$ ************* READING SYMBOLS *******************$

'table'SPECIAL =
("'action'"    :Saction,           "->"           :Sarrow,
 "*"           :Sasterisk,
 "<>"          :Scalibre,          "'charfile'"   :Scharfile,
 ")"           :Sclose,            ":"            :Scolon,
 ","           :Scomma,            "number"       :Scons,
 "'constant'"  :Sconssymb,         "'datafile'"   :Sdatafile,
 "<dummy>"     :Sdummy symb,       "'end'"        :Sendsymb,
 "="           :Sequals:Sbox,      "'exit'"       :Sexit,
 "'external'"  :Sextsymb,          "'function'"   :Sfunction,
 ">"           :Smore:Sright:Svupb,"]"            :Sbus,
 "["           :Ssub,              "[*"		  :Ssubstar,
 "*]"          :Sstarbus,          "<"            :Sless:Svlwb,
 "(*"          :Slstar,            "<<"           :Slwb,
 "-"           :Sminus,            "#"            :Snoarg,
 "-="          :Snot equal,        "/"            :Sslash,
 ">="          :Smreq,             "<="           :Slseq,
 "("           :Sopen,             "+"            :Splus,
 "."           :Spoint,            "'predicate'"  :Spredicate,
 "'pragmat'"   :Spragsymb,         "'question'"   :Squestion,
 """"""        :Squote image,      "'root'"       :Srootsymb,
 ";"           :Ssemicolon,        "'stack'"      :Sstacksymb,
 "'static'"    :Sstatic,
 "string"      :Sstring,           "'table'"      :Stablesymb,
 ">>"          :Supb,              "'variable'"   :Svarsymb,
$ boolor, booland, boolxor must come in this order for priority
 "~"           :Scomplement,       "|"            :Sboolor,
 "&"           :Sbooland,          "^"            :Sboolxor,
 "<defined>"   :Sdefined,          "<used>"       :Sused,
 "<not-seen>"  :Snot mentioned,
 "\n"          :Seol
).

$ SPECIAL SYMBOLS $

'a'read greater+>optor+x>: $ 123 > >>stack $
    is+optor,(char=/=/,next char,Smreq->x;Smore->x);
    char=/>/,next char,Supb->x;
    Svupb->x.
'a'read less+>optor+x>:
    is+optor,(char=/=/,next char,Slseq->x;Sless->x);
    char=/</,next char,Slwb->x;
    char=/>/,next char,Scalibre->x;
    Svlwb->x.
'a'read minus+x>:
    =char=
    [/>/],next char,Sarrow->x;
    [/=/],next char,Snot equal->x;
    read minus with space+x.
'a'read minus with space+x>:
    =char=
    [/ /],next char,:read minus with space;
    [/0/],next char,read zero+x,subtr+0+inpt value+inpt value;
    [/1/:/9/],read cons+x,subtr+0+inpt value+inpt value;
    Sminus->x.
'a'read open+x>:
    char=/*/,next char,
      (char=/)/,next char,Sasterisk->x;
       unget char+str char,Sopen->x);
$    =char=
$    [/*/],str char->char, Sopen->x;
$    [/./], next char, 
$      (( char=/./,next char, char=/./,next char,char=/)/,next char),
$       Ssoon->x;
$       error+illegal character+char, Sopen->x);
    Sopen->x.
$ CONSTANTS $
'a'read zero+x>: =char=
    [/ /], next char,:read zero;
    [/0/:/9/], read cons+x;
    [/x/;/X/], next char,read hex+x;
    Scons->x,0->inpt value.
'a'read cons+x>:
    Scons->x,subtr+char+/0/+inpt value,next char,
        (nxt-d:digit+d,addmult+inpt value+10+d+inpt value,:nxt;+).
'a'read hex+x>-d:
    hexdigit+d,Scons->x,d->inpt value,
         (nxt: hexdigit+d,left clear+inpt value+4,
               bool or+inpt value+d+inpt value,:nxt;+);
    error+hex digit expected,Scons->x,0->inpt value.
'a'read char denotation+x>:
    next char,Scons->x,char->inpt value,
        (char=newline,error+wrong character denotation;
         next char, (char=///,next char;
                     error+wrong character denotation)
        ).
'a'skip char denotation:
    char=newline;
    next char,(char=///,next char;+).
$ STRINGS $
'a'read string+x>-n:
    scratch+BUFFER,0->n,
    (nxt: next char,(=char=
     [/"/],next char,
        (char=/"/, extend+BUFFER+char,incr+n,:nxt;
         next visible char,
           (char=/"/,:nxt;
            n=0,Squote image->x;
            Sstring->x,pack string+BUFFER+n+LEXT,
              >>LEXT-> inpt value));
     [newline;end char],error+unterminated string, Squote image->x;
     extend+BUFFER+char,incr+n,:nxt)).
'a'skip string:
    =char=
    [/"/], next char;
    [end char; newline],+;
    next char,:skip string.
'a'forget string+>x:
    x=empty string; $ don't delete this one $
    x=>>LEXT,unstack string+LEXT;+.
'f'get string width+>x+m>:
    x=Squote image,string width+LEXT+empty string+m;
    string width+LEXT+x+m.
$ COMMENT AND LAYOUT $
'a'long comment:
    =char=
    [newline],+;
    [/$/],next char;
    next char,:long comment.
'p'short comment:
    =char=
    [/ /],next char,:short comment;
    [/A/:/Z/;/a/:/z/;/0/:/9/], next char,
      (nxt:=char=
       [/A/:/Z/;/a/:/z/;/0/:/9/;/ /],next char,:nxt;
       +);
    -.
$ BOLD SYMBOLS $
'table'(left,right,adm)BOLD =
("a"           :B1        ,(   0,   0,Saction    ),
 "act"         :B2        ,(  B1,  B3,Saction    ),
 "action"      :B3        ,(   0,   0,Saction    ),
 "charfile"    :B4        ,(  B2,  B5,Scharfile  ),
 "cons"        :B5        ,(   0,  B6,Sconssymb  ),
 "constant"    :B6        ,(   0,   0,Sconssymb  ),
 "cst"         :B7        ,(  B4, B11,Sconssymb  ),
 "datafile"    :B8        ,(   0, B85,Sdatafile  ),
 "e"           :B85       ,(   0,   0,Sexit      ),
 "end"         :B9        ,(  B8, B10,Sendsymb   ),
 "exit"        :B10       ,(   0,   0,Sexit      ),
 "external"    :B11       ,(  B9, B13,Sextsymb   ),
 "f"           :B12       ,(   0,   0,Sfunction  ),
 "fct"         :B13       ,( B12, B14,Sfunction  ),
 "func"        :B14       ,(   0,   0,Sfunction  ),
 "function"    :first bold,(  B7, B23,Sfunction  ),
 "p"           :B16       ,(   0,   0,Spredicate ),
 "pragmat"     :B17       ,( B16, B18,Spragsymb  ),
 "pred"        :B18       ,(   0,   0,Spredicate ),
 "predicate"   :B19       ,( B17, B21,Spredicate ),
 "q"           :B20       ,(   0,   0,Squestion  ),
 "qu"          :B21       ,( B20, B22,Squestion  ),
 "que"         :B22       ,(   0,   0,Squestion  ),
 "question"    :B23       ,( B19, B27,Squestion  ),
 "root"        :B24       ,(   0,   0,Srootsymb  ),
 "stack"       :B25       ,( B24, B26,Sstacksymb ),
 "static"      :B26       ,(   0,   0,Sstatic    ),
 "table"       :B27       ,( B25, B29,Stablesymb ),
 "var"         :B28       ,(   0,   0,Svarsymb   ),
 "variable"    :B29       ,( B28, B30,Svarsymb   ),
 "x"           :B30       ,(   0,   0,Sextsymb   )
).

'a'read bold+x>-n:
    next char,scratch+BUFFER,0->n,
    ((nxt-t: bold letter+t,extend+BUFFER+t,incr+n,:nxt;
             char=/'/,next char),
     pack string+BUFFER+n+LEXT,first bold->x,
     (nxt: x=0,error+unrecognizable bold+>>LEXT,Sdummy symb->x;
          compare string+BOLD+x+LEXT+>>LEXT+n,next+BOLD+x,
            (n>0,left*BOLD[x]->x,:nxt;
             n<0,right*BOLD[x]->x,:nxt;
             adm*BOLD[x]->x
            )
     ),
     unstack string+LEXT;
    pack string+BUFFER+n+LEXT,error+missing bold delimiter+>>LEXT,
    unstack string+LEXT,Sdummy symb->x).

$=============================================================$
$ IDENTIFIERS $
$ THE STACK "TTAG" -- character form of identifiers $
'stack'[40](left,right,adm,text=TTAG)TTAG =(
 "":first tag       ,(0*):Pfirst tag,
 "-dummy"           ,(0*):Pdummy,      $not a valid identifier
$ pragmat identifiers
 "on"               ,(0*):Pon,
 "off"              ,(0*):Poff,
 "mark"             ,(0*):Pmark,
 "rule"             ,(0*):Prule,
 "all"              ,(0*):Pall,
 "no"               ,(0*):Pno,
 "global"           ,(0*):Pglobal,
 "bounds"           ,(0*):Pbounds,
 "title"            ,(0*):Ptitle,
 "dictionary"       ,(0*):Pdict,
 "list"             ,(0*):Plist,
 "tabwidth"         ,(0*):Ptabwidth,
 "warninglevel"     ,(0*):Pwarning level,
 "stdlib"           ,(0*):Pstd lib,
 "include"          ,(0*):Pinclude,
 "require"          ,(0*):Prequire,
 "provide"          ,(0*):Pprovide,
 "compile"          ,(0*):Pcompile,
 "library"          ,(0*):Plibrary,
 "macro"            ,(0*):Pmacro,
 "inline"           ,(0*):Pinline,
 "module"           ,(0*):Pmodule,
 "public"           ,(0*):Ppublic,
 "export"           ,(0*):Pexport,
 "dump"             ,(0*):Pdump,
 "trace"            ,(0*):Ptrace,
 "count"            ,(0*):Pcount,
 "overflow"         ,(0*):Poverflow,
 "wrongbit"         ,(0*):Pwrong bit,
 "wrongstring"      ,(0*):Pwrong string,
 "if"               ,(0*):Pif,
 "ifnot"            ,(0*):Pifnot,
 "ifdef"            ,(0*):Pifdef,
 "ifndef"           ,(0*):Pifndef,
 "else"             ,(0*):Pelse,
 "endif"            ,(0*):Pendif,
$ vararg rules
 "shiftvarargblock" ,(0*):Pshift varargs,
 "getvarargblocks"  ,(0*):Pget varargs,
$ root, stringtable
 "@root"            ,(0*):Proot tag,
 "@StringTable"     ,(0*):Pstring table,
$ special rules
 "@make"            ,(0*):Parrow,
 "@mreq"            ,(0*):Pmreq,
 "@equal"           ,(0*):Pequal,
 "@noteq"           ,(0*):Pnot equal,
 "@more"            ,(0*):Pmore,
 "@less"            ,(0*):Pless,
 "@lseq"            ,(0*):Plseq:Plast tag
 ).

'stack'[1](tag,adm)RETAG. $ redefined entries go here $

'a'read tag+x>:
    scratch+BUFFER,extend+BUFFER+char,next char,
    (nxt-t: letgit+t,extend+BUFFER+t,:nxt;+),
    enter tag+x.
'a'pack selector+>sel+>tag+x>: $ tag.selector
    scratch+BUFFER,get tag+sel+sel,get tag+tag+tag,
    previous+TTAG+sel,previous+TTAG+tag,
    unpack string+TTAG+tag+BUFFER,extend+BUFFER+/./,
    unpack string+TTAG+sel+BUFFER,enter tag+x,get tag adm+x+x.
'a'enter predefined tag+>tag-n-x-y:
  first tag->y,
    (nxt:add+y+<>TTAG+x,compare string+TTAG+y+TTAG+tag+n,
       (n=0,error+internal error,'exit'3;
        n>0,left*TTAG[x]->y,
           (y>0,:nxt;tag->left*TTAG[x]);
        right*TTAG[x]->y,(y>0,:nxt;tag->right*TTAG[x]))).
'a'init identifiers-tag-y: $enter all predefined identifiers
    Plast tag->tag,(nxt:
    tag=Pfirst tag;
    previous+TTAG+tag,enter predefined tag+tag,
      string width+TTAG+tag+y,subtr+tag+y+tag,:nxt).
'a'new tag entry+>tag+x>:
    (* Iempty->type,0->repr->adm,tag->tag *)LADM,>>LADM->x.
'a'get tag adm+>tag+x>:
    adm*TTAG[tag]->x,(x=0,new tag entry+tag+x,x->adm*TTAG[tag];+).
'a'enter tag+x>-n-y:
    list length+BUFFER+n,pack string+BUFFER+n+TTAG,first tag->y,
    (nxt:add+y+<>TTAG+x,compare string+TTAG+y+TTAG+>>TTAG+n,
        (n=0,unstack string+TTAG;
         n>0,left*TTAG[x]->y,
             (y>0,:nxt;
              >>TTAG->left*TTAG[x],(*0->left->right->text->adm*)TTAG,
                  >>TTAG->x);
         right*TTAG[x]->y,
             (y>0,:nxt;
             >>TTAG->right*TTAG[x],(*0->left->right->text->adm*)TTAG,
                 >>TTAG->x)
        )
    ).
'a'redefine tag+>old+>new-x:
    tag*LADM[old]->x,x->tag*LADM[new],
    (* old->adm,x->tag *)RETAG, $save old values
    new->adm*TTAG[x].
'a'restore tags:
    >>RETAG < <<RETAG; $empty
    adm*RETAG->adm*TTAG[tag*RETAG],unstack+RETAG,:restore tags.
'f'find usage+>tag+usage>:
    tag=0,Sused->usage; $ but not defined
    (=type*LADM[tag]=
      [0],Snot mentioned->usage;
      [Iempty],Sused->usage;
      [Irule],(is rule flag+tag+r defined,Sdefined->usage;
               Sused->usage);
      Sdefined->usage).
'q'not library tag:
   is+in library,-;
   (=char=
    [ /%/;/a/:/z/;/A/:/Z/;/@/],-;
    +).
'a'read definition+x>-n:
    not library tag, Snoarg->x;
    $next char,$scratch+BUFFER,0->n,
    (char=/%/,extend+BUFFER+char,incr+n,next char;+),
    (nxt-t:letgit+t,extend+BUFFER+t,incr+n,:nxt;+),
    pack string+BUFFER+n+TTAG,first tag->x,
    (nxt:x=0,Snot mentioned->x; $not mentioned earlier
         compare string+TTAG+x+TTAG+>>TTAG+n,next+TTAG+x,
             (n>0,left*TTAG[x]->x,:nxt;
              n<0,right*TTAG[x]->x,:nxt;
              adm*TTAG[x]->inpt value,find usage+inpt value+x)
    ),
    unstack string+TTAG.
'q'is local tag+>tag-x:
    get tag+tag+x,previous+TTAG+x,string elem+TTAG+x+0+x,x=/%/.
$ delete tags starting with %
'a'delete local tags: %delete local tags+first tag.
'a'%delete local tags+>y-x-ch:
    y=0; $ nothing to do
    add+y+<>TTAG+x,
    ((string elem+TTAG+y+0+ch,ch=/%/),clean tag+x;+),
    %delete local tags+left*TTAG[x],
    right*TTAG[x]->y,:%delete local tags.
'a'clean tag+>x:
    adm*TTAG[x]=0;
    (-type:get type+adm*TTAG[x]+type,type=Iempty);
    0->adm*TTAG[x].
'a'print dictionary: %print dict+first tag.
'a'%print dict+>y-x:
    y=0;
    add+y+<>TTAG+x,%print dict+left*TTAG[x],
    DICT tag+x,
    right*TTAG[x]->y,:%print dict.
$================================================================$
$ SYMBOLIC READ AND SKIP $
'variable' optor=0. $ slash or char denotation $

'a'read+x>-ooptor:
    ppline>0,decr+ppline,Seol->x;
    optor->ooptor,0->optor,(nxt:=char=
         [/ /],next char,:nxt;
         [/A/:/Z/;/a/:/z/;/%/],1->optor,read tag+x;
         [/+/],next char,Splus->x;
         [/,/],next char,Scomma->x;
         [/;/],next char,Ssemicolon->x;
         [newline], next char,ooptor->optor,Seol->x;
         [/-/],next char,read minus+x;
         [/=/],next char,Sequals->x;
         [/(/],next char,read open+x;
         [/)/],next char,1->optor,Sclose->x;
         [/0/],next char,1->optor,read zero+x;
         [/1/:/9/],1->optor,read cons+x;
         [/'/],read bold+x;
         [/</],next char,read less+ooptor+x;
         [/>/],next char,read greater+ooptor+x;
         [/*/],next char,(char=/]/, next char, Sstarbus->x; Sasterisk->x);
         [/:/],next char,Scolon->x;
         [///],(is+ooptor,next char,Sslash->x;1->optor, read char denotation+x);
         [/./],next char,Spoint->x;
         [/@/],(is+in library,1->optor,read tag+x;
                error+illegal character+char,next char,:nxt);
         [/?/],next char,read definition+x;
$               (is+in library,read definition+x;
$                error+illegal character+char,next char,:nxt);
         [/$/],next char,long comment,:nxt;
         [/[/],next char,(char=/*/,next char,Ssubstar->x; Ssub->x);
         [/]/],next char,1->optor,Sbus->x;
         [/#/],next char,(short comment,:nxt;Snoarg->x);
         [/"/],$1->optor,$read string+x;
         [/!/],next char,(char=/=/,next char,Snot equal->x;error+illegal character+/!/,:nxt);
         $ boolean operators $
         [/~/],next char,Scomplement->x;
         [/|/],next char,Sboolor->x;
         [/&/],next char,Sbooland->x;
         [/^/],next char,Sboolxor->x;
         [str char],next char,Slstar->x;
         [end char],next char,Sendsymb->x;
         error+illegal character+char,next char,:nxt
    ).
'a'skip+x>:
   ppline>0,decr+ppline,Seol->x;
   (nxt:=char=
        [newline],next char,Seol->x;
        [///],next char,skip char denotation,:nxt;
        [/./],next char,Spoint->x;
        [/"/],next char,skip string,:nxt;
        [/#/],next char,(short comment,:nxt;:nxt);
        [/$/],next char,long comment,:nxt;
        [end char], Sendsymb->x;
        next char,:nxt
    ).
$ RESTORE FACILITIES $
$ init restore should be followed by exactly one of "make" or "forget".
$ .....********************......
$     ^old                ^in=out,  restorecount: difference, do=T
$ .....********************......
$     ^out=old            ^in       after make restore, do=F
$ .....********************......
$              ^out       ^in       reading from restore, do=F
$ .....********************......
$     ^old     ^out       ^in       reading from restore, do=T 
$ .....*******************......
$                        ^in=out=old  (restorecount=0)
$ .....*******************......
$     ^out=old           ^in          (restorecount!=0)
$  pending symbols are marked by "*". What "outrestore" points to has been
$  returned. "inrestore" points to the last saved position (the next one
$  will be filled next).
$  init restore: starts backtrack
$      T->do restore,
$      save "outrestore" in "old restore" (so that it can be reset)
$      save current inpt (as otherwise it is lost) and position.
$  make restore:
$      F->do restore;
$      old restore->outrestore, restore "inpt" and position to the 
$      saved value.
$  read from restore:
$      if outrestore=inrestore, return false, nothing in RESTORE
$      (and "restore count" must be zero);
$      otherwise advance outrestore and set inpt (and inpv) from RESTORE.
$      If not "do restore", decrease restore count.
$  save to restore:
$  next symbol: set the next inpt value, storing it if instructed so.
$      if "read from restore" returns true, accept that value.
$      otherwise ask for the next symbol. If "do restore" is true, store
$        "inpt" (and inpv). Advance "outrestore" as well, as if the current
$        "inpt" value is served from RESTORE

'constant' restore size=500.
'stack'[=restore size=]RESTORE=(0*restore size).

'variable'restore count=0,old restore=0,old inpt=0,old inpv=0,
     old linenum=0,
     do restore=0,
     inrestore=>RESTORE,outrestore=>RESTORE.
'a'init restore: $ initiate restore
    is+do restore, error+internal error,'exit' 2;
    outrestore->old restore, inpt->old inpt,inpt value->old inpv,
    linenum->old linenum,
    T->do restore.
'a'make restore: $ make restore
    do restore=F,error+internal error,'exit'2;
    restore count>restore size,error+too large backtrack,'exit'2;
    old restore->outrestore,
    old inpt->inpt,old inpv->inpt value,
    old linenum->linenum,
    F->do restore.
'a'forget restore: $ set line numbers in the DISC file right
    make restore,
    (nxt: read from restore, set symbol position, :nxt;+).
'a'save to restore:
    do restore=F,+; $ do nothing
    outrestore!=inrestore, error+internal error,'exit'2;
    save to restore1+inpt,
    ((inpt=Scons;inpt=Sstring),save to restore1+inpt value;+).
'a'save to restore1+>x:
    incr+restore count,count restore+inrestore,inrestore->outrestore,
    x->RESTORE[inrestore].
'p'read from restore:
    inrestore=outrestore,-;
    read from restore1+inpt,
     ((inpt=Scons;inpt=Sstring),read from restore1+inpt value;+).
'a'read from restore1+x>:
    count restore+outrestore,RESTORE[outrestore]->x,
    (is+do restore; decr+restore count),
    (restore count>=0; error+internal error).
'f'count restore+>x>:
    x=>>RESTORE,<<RESTORE->x;incr+x.

$ READING $

'variable' linenum=0.
$ used in error messages $
'a'set symbol position:
   inpt=Seol, incr+linenum,(is+do restore; D+Dline);
   +.

'variable' inpt=0,inpt value=0.

'a'next symbol:
    (read from restore; read+inpt,save to restore),
    set symbol position,
    (inpt=Seol,:next symbol;+).

'q'ahead+>x: inpt=x.
'p'R+>x:     inpt=x,next symbol.
'a'Rskip+>x: inpt=x,next symbol;
             (was+LADM+x,inpt=tag*LADM[x]),next symbol;
             +.
'a'must+>x:  inpt=x,next symbol;error+inserted+x.

$ is tag: if inrestore=outrestore and DICT is not
$  suspended; and tag type is not formal, then add it
$  to the DICT array before calling next symbol
'p'is tag+x>: was+TTAG+inpt,
     (inrestore=outrestore,add DICT+inpt+linenum;+),
     get tag adm+inpt+x,next symbol.
'p'is definition tag+>mark+x>: was+TTAG+inpt,
     (inrestore=outrestore,add DICT+inpt+linenum,
            (mark=0;add DICT+inpt+-1);+),
     get tag adm+inpt+x,next symbol.
'a'must tag+x>:is tag+x; error+internal error,'exit'3.
'p'is raw tag+x>: was+TTAG+inpt,inpt->x,next symbol.
'p'is cons+x>:inpt=Scons,inpt value->x,next symbol.
'p'is string+x>:inpt=Squote image,empty string->x,next symbol;
                inpt=Sstring,inpt value->x,next symbol.

$ SKIPPING $
'a'skip symbol:
    (read from restore;skip+inpt,save to restore),
    set symbol position,
    (inpt=Seol,:skip symbol;+).
'a'skip silently:
    ahead+Spoint;ahead+Sendsymb;skip symbol,:skip silently.
'a'skip all:
    ahead+Spoint;
    message+skipped,skip silently.
'a'skip to point:
    skip all,R skip+Spoint.

$ ***************** ERROR AND WARNING RULES ********************* $

'table'MESSAGE=(
 "internal error"               :internal error,
 "cannot (re)open temp file %p, error code=%d, aborting"
                                :cannot open disc file,
 "cannot open target file %p, error code=%d, aborting"
                                :cannot open target file,
 "hex digit expected after 0x"  :hex digit expected,
 "wrong character denotation"   :wrong character denotation,
 "unterminated string"          :unterminated string,
 "unknown keyword '%p'"         :unrecognizable bold,
 "missing delimiter "
     "after '%p'"               :missing bold delimiter,
 "illegal character: %c"        :illegal character,
$ backtrack
 "too large backtrack, aborting":too large backtrack,
 "program text skipped "
     "until the next point"     :skipped, $ info
$ program arguments
 "missing argument for comand "
     "line pragmat %p"          :missing argument for cmdline pragmat,
 "cannot open source file ""%p"" "
     "(errno=%d), skipped ..."  :error opening source, $ warning
 "no input file was specified"  :no input file,
 "no 'root' in the program"     :no root,
 "more than one 'root'"         :more than one root,
 "no 'root' in module"          :no root in module,
 "'static' can be used in library mode only":static in library only,
$ symbols, must()
 "symbol %p is inserted"        :inserted,
 "symbol %p is expected here"   :expected,
 "symbol %p is expected after %p":expected after,
 "wrong symbol %p here"         :wrong symbol,
$ general
 "tag %p: redefined (was %p)"   :tag redefined,
 "tag expected"                 :tag expected,
 "tag expected after %p"        :tag expected after,
 "string expected"              :string expected,
 "tag %p must be table or stack (%p)":must be of list type,
 "tag %p must be a constant"    :wrong constant type,
 "local tag %p cannot be external":no local tag for external,
$ warning 
 "standard tag ""%p"" redefined":standard tag redefined
).

'constant'line col=4,mess col=22.
'variable'error no=0,local error no=0.
'constant'default warning level=4.
'variable'warning level=default warning level, 
          save warning level=default warning level.

'a'clear local error+old>:
   local error no->old,0->local error no.
'p'was local error+>old-x:
   local error no->x,add+old+x+local error no,x>0.

'a'error+*+>mess:
   incr+error no,incr+local error no,
   error body+0+10,format print+MESSAGE+*,nlcr.
'a'Xerror+*+>mess:
   incr+error no,incr+local error no,
   error body+1+10,format print+MESSAGE+*,nlcr.

'a'error body+>noline+>level-n-str:
    save prpos, nlcr,
    (level<0,print char+/I/;
     level<10,print char+/W/,add+level+/0/+level,print char+level;
     print char+/E/),
      (is+noline;
       find linenum+linenum+n+str,tab line+line col,
       print form+n,print char+///,print base+LEXT+str),
      tab line+mess col.

$ warning levels
$ 0: all warnings, 1: somewhat less, 9: only serious warnings
'a'warning+>level+*+>mess:
    level<warning level;
    error body+0+level,format print+MESSAGE+*,nlcr.
'a'Xwarning+>level+*+>mess:
    level<warning level;
    error body+1+level,format print+MESSAGE+*,nlcr.

'a'set lib warning level:
    warning level->save warning level,
    (warning level<3,8->warning level;9->warning level).
'a'restore lib warning level:
    save warning level->warning level.
$ messages
'a'message+*+>mess:
   error body+0+-1,format print+MESSAGE+*,nlcr.
$ ***********************  PRELUDE  ************************* $

'table'DSYMB= $ disk symbols 
(0:Dbox,0:Dbus,0:Dcalibre,0:Dcharfile,0:Dclose,0:Dcolon,
 0:Dcomma,0:Dconstval,0:Ddatafile,0:Dend,0:Dexit,0:Dextension,
 0:Dinput,0:Djump,0:Dlabel,0:Dline,0:Dlocal,0:Dlwb,0:Dminus,0:Dnoarg,
 0:Dopen,0:Dplus,0:Dpoint,0:Dpragmat,0:Droot,0:Drule,
 0:Dsemicolon,0:Dstack,0:Dsub,0:Dtable,0:Dto,
 0:Dupb,0:Dvlwb,0:Dvupb,0:Dzone
).

'variable'Xroot tag=0,Xstring table=0,Xshift varargs=0,Xget varargs=0.

'variable'link string=0,std empty pointer=0.
$ @StringTable for inline strings; they are stored in LEXT
$ (starting with the empty string) and are linked through "link string".
$ The last offset is in fsize
'a'%new std pointer+>str+c>-w-offs:
    get fsize+Xstring table+offs,get string width+str+w,
    add+offs+w+offs,put fsize+Xstring table+offs,
    new tag entry+Pdummy+c,put type+c+Ipointer constant,
    put repr+c+offs,put adm+c+Xstring table.
$'q'%stdstring seen before+>str+offs>-ptr-ptr1-n:
$    link string->ptr,(nxt:ptr=0,-;
$      subtr+ptr+1+ptr1,compare string+LEXT+str+LEXT+ptr1+n,
$         (n=0,string width+LEXT+ptr1+offs,(nxt2:ptr=0;
$            LEXT[ptr]->ptr,subtr+ptr+1+ptr1,
$            string width+LEXT+ptr1+n,add+offs+n+offs,:nxt2);
$          LEXT[ptr]->ptr,:nxt)).
'a'add stdstring+>str+c>:
    str=empty string,std empty pointer->c;
    $ the same string is stored multiple times; one can search for them
    $ %stdstring seen before+str+offs,forget string+str,
    $       create new pointer to Xstring table with offs;
    str=>>LEXT,extend+LEXT+link string,>>LEXT->link string,
      %new std pointer+str+c;
    error+internal error,'exit'3.
'a'init stdstring table:
    get tag adm+Pstring table+Xstring table,
    put type+Xstring table+Itable,
    put adm+Xstring table+link list,Xstring table->link list,
    (* 0->ssel->calibre->flag->esize->fsize *)LADM,
    put repr+Xstring table+>>LADM,
    link string init->link string,
    %new std pointer+empty string+std empty pointer.

$ rules "shift vararg block" and "get vararg blocks"
'a'init shift varargs-affix-affix2:
    $ shift vararg blocks + *position.
    get tag adm+Pshift varargs+Xshift varargs,
    put type+Xshift varargs+Irule,set rule flag+Xshift varargs+r shiftarg,
    new tag entry+Pdummy+affix,put type+affix+Iformal shift,
    put adm+Xshift varargs+affix,
    $ get vararg blocks + n> + *position.
$    new tag entry+Pdummy+affix,put type+affix+Iformal out,
    get tag adm+Pget varargs+Xget varargs,
    put type+Xget varargs+Irule,set rule flag+Xget varargs+r getvararg,
    new tag entry+Pdummy+affix,put type+affix+Iformal out,
    put adm+Xget varargs+affix,
    new tag entry+Pdummy+affix2,put type+affix+Iformal shift,
    put adm+affix+affix2.
'a'prelude:
    F->root scanned,
    0->link list->link cons->link ext->link file->link rule,
    $ add an empty block to LADM
    (* 0->ssel->calibre->flag->esize->fsize *)LADM,
    init identifiers,
    init stdstring table, init shift varargs,
    add all args,default warning level->warning level,
    open disc+/w/.
$ pragmats as command line options:
$ -o <title>, -L, -M, -d, -l -W, -Wall, --{pragmat} 
'p'is string cmdline pragmat+>inpt>-ptr-eq:
   string*INPUT[inpt]->ptr,compare string+LEXT+ptr+"-o"+eq,eq=0,
     next+INPUT+inpt,
     (inpt> >>INPUT,Xerror+missing argument for cmdline pragmat+ptr;
      linenum->n*INPUT[inpt],string*INPUT[inpt]->program title,
           next+INPUT+inpt).
'p'is cmdline pragmat+>ptr-eq:
   (compare string+LEXT+ptr+"-L"+eq,eq=0),
        set library;
   (compare string+LEXT+ptr+"-M"+eq,eq=0),
        1->in module;
   (compare string+LEXT+ptr+"-d"+eq,eq=0),
        1->dict on;
   (compare string+LEXT+ptr+"-dd"+eq,eq=0),
        1->dict on,1->dict mark;
   (compare string+LEXT+ptr+"-l"+eq,eq=0),
        1->new give text;
   (compare string+LEXT+ptr+"-W"+eq,eq=0),
        3->warning level,Dwarning level;
   (compare string+LEXT+ptr+"-Wall"+eq,eq=0),
        0->warning level,Dwarning level;
   (string elem+LEXT+ptr+0+eq,eq=/-/,string elem+LEXT+ptr+1+eq,eq=/-/),
        init LEXT char+ptr,next symbol,pragmat.
$ open the next source file
'p'open source string+T[]+>str-errno-ptr-n:
  open file+SOURCE+/r/+T+str;
  get file error+SOURCE+errno,(errno!=2,-; $ cannot open string
     scratch+BUFFER,unpack string+T+str+BUFFER,>>BUFFER->ptr,
      (nxt: ptr<=<<BUFFER;
            (=BUFFER[ptr]=
              [/A/:/Z/;/a/:/z/;/0/:/9/], decr+ptr,:nxt;
              +)),
      ((ptr<=<<BUFFER;BUFFER[ptr]!=/./),
       extend+BUFFER+/./,extend+BUFFER+/a/,extend+BUFFER+/l/,extend+BUFFER+/e/,
       list length+BUFFER+n,pack string+BUFFER+n+LEXT,scratch+BUFFER,
       (open file+SOURCE+/r/+LEXT+>>LEXT,forget string+>>LEXT;
        forget string+>>LEXT,-);
       scratch+BUFFER,-)
  ).

'p'next source+>ptr>-cmpflag:
   ptr> >>INPUT,-;
   incr+linenum,n*INPUT[ptr]->cmpflag,linenum->n*INPUT[ptr],D+Dline,
   (is string cmdline pragmat+ptr,:next source;
    is cmdline pragmat+string*INPUT[ptr],next+INPUT+ptr,:next source;
    open source string+LEXT+string*INPUT[ptr],
$    open file+SOURCE+/r/+LEXT+string*INPUT[ptr],
        init char+1,next+INPUT+ptr,(cmpflag=-2,0->in compile;1->in compile);
    get file error+SOURCE+cmpflag,
      Xwarning+9+error opening source+string*INPUT[ptr]+cmpflag,next+INPUT+ptr,:next source).
'a'read sources-ptr-cnt:
   <<INPUT->ptr,0->in library,0->cnt,0->linenum,reset pragmats,
   (nxt:next source+ptr,next symbol,program,close file+SOURCE,
          delete local tags,reset pragmats,incr+cnt,:nxt;+),
   (cnt>0;Xerror+no input file).
'a'read stdlib-ptr:
   std lib=0; $ no standard lib
   add include+stdlib file,>>INPUT->ptr,reset pragmats,
    (nxt:next source+ptr,next symbol,program,close file+SOURCE,
         delete local tags,reset pragmats,:nxt;+).
$ ********************** POSTLUDE ******************* $
'a'postlude I:
    D+Dend,close disc,
    (is+root scanned;is+in module;Xerror+no root),
    list bounds,           $ compute table and stack bounds & calibre
    second constant sweep, $ finalize const and var initializers
    print dictionary,release DICT.

$ ************* type, sort, state *********************$
'table'INDICATOR=(
"undefined"          :Iempty,
   $ constants and variables
"constant"           :Iconstant,  $ constant
"external constant"  :Iext cons,  $ external constant
"cons expression"    :Ieconst,    $ constant expression
"rec initializer"    :Irecconst,  $ recursive constant expression
"variable"           :Ivariable,  $ variable
"external var"       :Iext var,   $ external variable
"static variable"    :Istatic var,$ static variable
"var expression"     :Ievar,      $ variable expression
"var expression"     :Istevar,    $ static var expression
   $ table, stack, selector, initialized pointers
"table"              :Itable,
"external table"     :Iext table,
"stack"              :Istack,
"external stack"     :Iext stack,
"static stack"       :Istatic stack,
"selector"           :Iselector,
"pointer constant"   :Ipointer constant,
   $ files
"charfile"           :Ichar file,
"datafile"           :Idata file,
   $ action,predicate,question,function
"rule"               :Irule,
   $ formal types, should come at the end ...
"formal"             :Ifirst formal type,
"formal selector"    :Iformal selector,
"formal stack"       :Iformal stack,
"formal table"       :Iformal table,
"formal file"        :Iformal file,
"formal in"          :Iformal in,
"formal out"         :Iformal out,
"formal inout"       :Iformal inout,
"formal repeat"      :Iformal repeat,
"formal shift"       :Iformal shift,  $ virtual type only
"macro parameter"    :Imacro,
"no argument"        :Inoarg,
"local"              :Ilocal,
"label"              :Ilabel).

$====================================================================$
$ PRAGMATS $
$ syntax:
$    pragmat :: tag1=PI , tag1=PI, ..., tag1=PI .
$    PI      :: ( PI, PI, ...) | cons | string | tag2
'table'MESSAGE=(
 "wrong pragmat syntax"                  :wrong pragmat,
 "unknown pragmat %p"                    :unknown pragmat,
 "pragmat %p: wrong value %p"            :wrong pragmat value,
 "pragmat %p: out of range value %d"     :wrong cons pragmat value,
 "pragmat endif=%p missing"              :missing endif pragmat,
 "pragmat %p=%p has no matching pair"    :misplaced if pragmat,
 "pragmat dump not allowed in module"    :no dump in module,
 "rule %p: cannot be macro"              :cannot be a macro,
 "rule %p: external cannot be macro"     :no external macro,
 "cannot export tag %p"                  :cannot export tag
).
'a'reset pragmats: $ call when input changes $
  0->dict on,8->new tab width,0->new give text,
    0->pgmskip->pgmiftag,D+Dinput,clear library.
'a'pragmat-x:
    is raw tag+x, must+Sequals, pragmat item+x,
     (R+Spoint;
      R+Scomma,:pragmat;
      must+Spoint,skip to point);
    error+wrong pragmat,skip to point.
'a'pragmat item+>x-y:
    R+Sopen,(nxt: pragmat item+x,(R+Scomma,:nxt;must+Sclose));
    is raw tag+y,tag pragmat2+x+y;
    is cons+y, cons pragmat2+x+y;
    is string+y, string pragmat2+x+y;
    error+unknown pragmat+x,skip all.
$ instead of a=(b,c,d) send a=b,a=c,a=d
'variable'pgmtag=0,pgmstate=0,pgmskip=0,pgmiftag=0.
$    0: ,       =>         ,        1
$    0: .       =>         .     exit
$    1: rawtag  =>         rawtag   2
$    1: other   =>         X      100
$    2: =       =>         =        3
$    2: other   =>         X      100 
$    3: (       =>                  4
$    3: [tag,const,string] X        0
$    3: other   =>         X      100
$    4: [tag,const,string] X        5
$    4: other   =>         X      100
$    5: ,       =>         ,        6
$    5: )       =>                  0
$    5: other   =>         X      100
$    6:                    rawtag   7
$    7:                    =        4
$  100: .       =>         .     exit
$  100: other   =>         X      100 
'a'next pragmat symbol:
  =pgmstate=
  [0],next symbol,(ahead+Scomma,1->pgmstate;100->pgmstate);
  [1],next symbol,(was+TTAG+inpt,inpt->pgmtag,2->pgmstate;100->pgmstate);
  [2],next symbol,(ahead+Sequals,3->pgmstate;100->pgmstate);
  [3],next symbol,(=inpt=
        [Sopen],4->pgmstate,:next pragmat symbol;
        [Scons;Squote image;Sstring],0->pgmstate;
        (was+TTAG+inpt,0->pgmstate;100->pgmstate));
  [4],next symbol,(=inpt=
       [Scons;Squote image;Sstring],5->pgmstate;
       (was+TTAG+inpt,5->pgmstate;100->pgmstate));
  [5],next symbol,(=inpt=
       [Scomma],6->pgmstate;
       [Sclose],0->pgmstate,:next pragmat symbol;
       100->pgmstate);
  [6],pgmtag->inpt,7->pgmstate;
  [7],Sequals->inpt,4->pgmstate;
  (inpt=Sendsymb;next symbol).
'a'program pragmat+err>: 100->pgmstate,program pragmat2+err.
'a'program pragmat2+err>:
  0->err, $ 0: OK, 1: error, 2: endif=XXXX
  (nxt:was+TTAG+inpt,(pgmstate=100,inpt->pgmtag,2->pgmstate;+),
        next pragmat symbol,
        (inpt!=Sequals,error+wrong pragmat,1->err;
         next pragmat symbol,program pragmat item+pgmtag+err,
          (is+err; $ error or endif=XXXX
           R+Spoint;
           ahead+Scomma,next pragmat symbol,:nxt;
           error+wrong pragmat,1->err));
   error+wrong pragmat,1->err).
'a'program pragmat item+>x+>err>-y:
    inpt=Scons,inpt value->y,next pragmat symbol,
        (is+pgmskip;cons pragmat2+x+y);
    inpt=Squote image,empty string->y,next pragmat symbol,
        (is+pgmskip;string pragmat2+x+y);
    inpt=Sstring,inpt value->y,next pragmat symbol,
        (is+pgmskip,forget string+y;string pragmat2+x+y);
    was+TTAG+inpt,inpt->y,next pragmat symbol,
        program tag pragmat2+x+y+err;
    error+unknown pragmat+x,1->err.
'a'find if condition+>x+>y+z>: $0: no, 1: yes
   =y=
   [Plist],    new give text->z;
   [Pdict],    (is+dict on,1->z;0->z);
   [Pmodule],  in module->z;
   [Pcompile], in compile->z;
   [Plibrary], in library->z;
   error+wrong pragmat value+x+y,0->z.
$ we are in 'pragmat'ifXXX=<cond>
$   prgram tag pragmat2 <== prgram pragmat item <== program pragmat
$ finish the pragmat, then go over the prograam until the matching
$  'pragmat'endif=<cond> is found ('pragmat' returns with err=2).
'a'find matching endif-err:
   $ tail of program pragmat:
   (R+Spoint,0->err; $ out of pragmat
    ahead+Scomma,next pragmat symbol,program pragmat2+err;
    error+wrong pragmat,1->err),
   (err=1,skip to point;+),
   (err=2; $ endif meanwhile
    program,(ahead+Send symb,error+missing endif pragmat+pgmiftag;+)).
'a'do pragmat skip+>iftag+>z-oldif-oldskip:
    pgmiftag->oldif,iftag->pgmiftag,pgmskip->oldskip,
       (is+z,incr+pgmskip;+),
       find matching endif,
       oldskip->pgmskip,oldif->pgmiftag.
$'a'do pragmat program+>iftag-oldif:
$    pgmiftag->oldif,iftag->pgmiftag,
$    find matching endif,
$    oldif->pgmiftag.
'a'program tag pragmat2+>x+>y+>err>-z:
   =x=
   [Pif],    find if condition+x+y+z,
                (is+z,do pragmat skip+y+0;do pragmat skip+y+1);
   [Pifnot], find if condition+x+y+z,
                (is+z,do pragmat skip+y+1;do pragmat skip+y+0);
   [Pifdef], find usage+adm*TTAG[y]+z,
                (z=Sdefined,do pragmat skip+y+0;do pragmat skip+y+1);
   [Pifndef],find usage+adm*TTAG[y]+z,
                (z!=Sdefined,do pragmat skip+y+1;do pragmat skip+y+0);
   [Pelse], (pgmiftag=y,(pgmskip=0,1->pgmskip;
                         pgmskip=1,0->pgmskip;
                         +);
             error+misplaced if pragmat+x+y,(pgmskip>0;1->pgmskip));
   [Pendif],(pgmiftag=y,2->err;
             error+misplaced if pragmat+x+y,(pgmiftag=0;2->err));
   (is+pgmskip;tag pragmat2+x+y).

'a'Dwarning level:
    D+Dpragmat,D+Pwarning level,D cons+warning level.
'a'set library:
   is+in library;
   1->in library,set lib warning level,
      D+Dpragmat,D+Plibrary,D cons+1,Dwarning level.
'a'clear library:
   is+in library,0->in library,restore lib warning level,
      D+Dpragmat,D+Plibrary,D cons+0,Dwarning level;
   +.
'a'on off pragmats+>x+>y:
   y=Pon,D+Dpragmat,D+x,D cons+1;
   y=Poff,D+Dpragmat,D+x,D cons+0;
   error+wrong pragmat value+x+y.
'a'tag pragmat2+>x+>y:   $  xxx=yyy
   =x=
   [Plist],   (y=Pon, 1->new give text;
               y=Poff,0->new give text;error+wrong pragmat value+x+y);
   [Pdict],   (y=Pon,1->dict on;
               y=Poff,0->dict on;
               y=Pmark,1->dict on,1->dict mark;
               error+wrong pragmat value+x+y);
   [Plibrary],(y=Pon,set library;
               y=Poff,clear library;
               error+wrong pragmat value+x+y);
   [Pcompile],(y=Pon,1->in compile;
               y=Poff,0->in compile;
               error+wrong pragmat value+x+y);
   [Pmodule], (y=Pon,1->in module,
                 (is+root scanned,error+no root in module;+);
$                 (is+pm dump,error+no dump in module;+);
$               (y=Poff,in module=0),+;
               error+wrong pragmat value+x+y);
   [Pstd lib],((y=Pno;y=Poff),0->std lib;error+wrong pragmat value+x+y);
   [Pdump],   (y=Pon,3->pm dump;
               y=Poff,0->pm dump;
               y=Pglobal,1->pm dump;
               y=Pall,3->pm dump;
               y=Prule,2->pm dump;error+wrong pragmat value+x+y);
   [Pmacro;Pinline],get tag adm+y+y,mark rule as macro+y,
               D+Dpragmat,D+Pmacro,D+y;
   [Ppublic;Pexport],((-x:y->x,previous+TTAG+x,string elem+TTAG+x+0+x,(x=/%/;x=/@/)),
                error+cannot export tag+y;
                get tag adm+y+y,D+Dpragmat,D+Ppublic,D+y);
   [Ptrace;Pcount;Pbounds;Poverflow;Pwrong bit;Pwrong string],
               on off pragmats+x+y;
   error+unknown pragmat+x.
'a'cons pragmat2+>x+>y:  $ xxx=123
   =x=
   [Ptab width], (=y= [1:20],y->new tab width;
                  error+wrong cons pragmat value+x+y);
   [Pwarning level],(=y= [0:9],y->warning level,Dwarning level;
                  error+wrong cons pragmat value+x+y);
   error+unknown pragmat+x.
'a'string pragmat2+>x+>y:    $ xxx="..."
   =x=
   [Pinclude], add include+y;
   [Prequire], add include+y, -2 -> n*INPUT; $ include with compile=off
   [Pprovide], forget string+y; $ just for checking
   [Ptitle], (is+in compile,y->program title;+);
   forget string+y,error+unknown pragmat+x.
$================================================================$
'table'MESSAGE=(
 "wrong selector syntax"              :wrong selector,
 "selector expected"                  :selector expected,
 "list tag is missing"                :list tag missing,
 "selector %p is redefined"           :doubly defined selector,
 "standard selector %p redefined"
    " differenty"                     :standard selector different,
 "different calibre for %p (was %d)"  :different calibre,
 "repeat constant tag %p not defined" :repeat constant tag not defined,
 "repeat constant expected"           :repeat constant expected,
 "syntax error in filling for list %p":error in filling,
 "missing initializer after colon"    :missing initializer,
 "filling block expected"             :filling list expected,
 "static stack %p: missing size estimate": size estimate missing,
 "stack %p: redefined"                :stack tag redefined,
 "the calibre of %p is not known"     :calibre not known,
 "wrong list declaration"             :wrong list declaration,
$ warning $
"repeat constant %d out of range (1 .. 10000)": repeat constant out of range,
"wrong filling block size (%d, expected %d)"
                                      :wrong filling block size
).
$ skip field list goes over a field list first time.
$   returns whether there was an error, and also issues
$   error messages when necessary.
'a'skip field list+>err>-sel:
   is+err;
   R+Sopen, (nxt: is tag+sel,(R+Scomma,:nxt;
                              R+Sequals,:nxt;
                              R+Sclose;
                              error+wrong selector,1->err);
             error+selector expected,1->err);
   +.
$ get list tag+tag> gives tag=Pdummy for error (with error message)
$  or the tag after the selector list (if any).
'a'get list tag+>mark+tag>-err:
   init restore, 0->err,skip field list+err, Pdummy->tag,
   (is definition tag+mark+tag;
    is+err;
    error+list tag missing,1->err),
   (is+err,Pdummy->tag, forget restore; make restore).
'a'selector list+>tag-n-x-ssel-repr: $syntax is OK, >tag has REPR
   R+Sopen,pack selector+tag+tag+ssel,get repr+ssel+x,
     (x=0,put type+ssel+Iselector,put adm+ssel+tag; 
      put repr+ssel+0),
     1->n,                    $number of selectors
     (nxt:
       (-sel-type: is tag+sel,pack selector+sel+tag+sel,get type+sel+type,
         (type=Iselector,$ was defined before $ get repr+sel+repr,
           (repr=n; $OK, same offset $
            repr=0,put repr+sel+n; $selector seen before$
            error+doubly defined selector+sel);
          type=Iempty,put type+sel+Iselector,put repr+sel+n,put adm+sel+tag;
          error+doubly defined selector+sel);
         error+selector expected, skip all $should not happen$ ),
       (R+Scomma,incr+n,:nxt;
        R+Sequals,:nxt;
        +)),
     must+Sclose,get repr+ssel+repr, $check L*L
     (repr=0, (x=0, -1->x;    $ L*L was not defined here
               x=-1;          $ L*L should not be defined
               error+standard selector different+ssel);
      repr=x;                 $ same as before
      x=0, repr->x;           $ defined now but not earlier
      error+standard selector different+ssel),
     put repr+ssel+x,         $ store the right value
     get calibre+tag+x,       $ check calibre
     (x=n;                    $ they are equal
      x=0, put calibre+tag+n; $ not defined previously
      error+different calibre+tag+x);
   +.                         $ no selector list, do nothing
$ link tag to a list
'a'add list to link+>tag+>type:
   =type=
   [Iext table;Iext stack],put adm+tag+link ext,tag->link ext;
   put adm+tag+link list,tag->link list.
$ (selectors)A  tag=Pdummy on syntax error (error message issued)
'a'list description+>listtype+tag>-type:
   get list tag+1+tag,
   (tag=Pdummy, skip all; $ error, skip until next point $
    get type+tag+type, $ selector list is OK $
    (type=Iempty,put type+tag+listtype,add list to link+tag+listtype,
       (*0->ssel->calibre->flag->esize->fsize*)LADM,
       put repr+tag+>>LADM,
       selector list+tag,Rskip+tag;
       $ calibre=0 if no selector list
     (type=listtype,(type=Itable;type=Istack)),
                 selector list+tag, Rskip+tag; $ continuation $
     (type=Istatic stack,listtype=Itable),selector list+tag, Rskip+tag;
     (type=Itable,listtype=Istatic stack),put type+tag+listtype,
                 selector list+tag, Rskip+tag;
     error+tag redefined+tag+type,skip all,Pdummy->tag
   )).
'a'repeat count+n>-tag:
   R+Sasterisk,1->n,
      (is cons+n;
       is tag+tag,
         (loose constant tag+tag+n;
          error+repeat constant tag not defined+tag);
       error+repeat constant expected),
      (=n=[1:10000],+;1->n,warning+9+repeat constant out of range+n);
   1->n.
'a'list fill+>tag-offs-calibre-x-n-w: $ warning if a block is not of size calibre
   R+Sopen,get calibre+tag+calibre, $ calibre can be zero $
     get fsize+tag+offs,
     (nxt:
       (is cons+x,repeat count+n,
               (nxt: n>0,D cons+x, incr+offs,decr+n,:nxt;+);
        is tag+x,repeat count+n,
               (nxt:n>0,D+x,incr+offs,decr+n,:nxt;+);
        is string+x,repeat count+n,get string width+x+w,
               (nxt: n>0,D string+x,add+offs+w+offs,decr+n,:nxt;
                forget string+x);
        R+Sopen,list fill block+tag+calibre+offs;
        error+error in filling+tag,skip all),
       initializer+tag+offs,
       (R+Scomma,:nxt;
        R+Sclose,put fsize+tag+offs;
        error+error in filling+tag,skip all)
     );
   +.
'a'initializer+>list+>offs-tag-type:
   R+Scolon,
    (is definition tag+1+tag,get type+tag+type, 
      ((type=Iext cons,unlink external+tag;type=Iempty),
         put type+tag+Ipointer constant,put repr+tag+offs,
         put adm+tag+list;
       error+tag redefined+tag+type),:initializer;
     error+missing initializer);
   +.
'a'repeat fill block+>from+>offs>-n-i:
   repeat count+n,(nxt:n>1,decr+n,from->i,
      (nxt2:i<>>LLOC,incr+i,(LLOC[i]=0, incr+i,D cons+LLOC[i];
                            incr+i,D+LLOC[i]),incr+offs,:nxt2;+),
   :nxt;+).
'a'list fill block+>tag+>calibre+>offs>-x-t-cnt-from: $ no strings inside
   $ LLOC should be empty here
   0->cnt->x->t,>>LLOC->from,(nxt:
     R+Scomma,:nxt;
     is cons+x,0->t,D cons+x,extend+LLOC+t,extend+LLOC+x,incr+cnt,:nxt;
     is tag+x,1->t,D+x,extend+LLOC+t,extend+LLOC+x,incr+cnt,:nxt;
     cnt=0,1->cnt,error+filling list expected,skip all;
     R+Sasterisk,
       (nxt:calibre=0,error+calibre not known+tag,
                 (R+Sclose;must+Sclose,skip all);
        cnt<calibre,(t=0,D cons+x;D+x),extend+LLOC+t,extend+LLOC+x,incr+cnt,:nxt;
        R+Sclose,repeat fill block+from+offs;
        must+Sclose,skip all);
     R+Sclose,repeat fill block+from+offs;
     error+filling list expected,skip all),
   unstack to+LLOC+from,
   (calibre=0;cnt=calibre;warning+2+wrong filling block size+cnt+calibre),
   add+offs+cnt+offs.
'a'table declaration-tag-type:
   (R+Ssub,must+Sbus;+),
   list description+Itable+tag,
   (tag=Pdummy,skip all; $ some error $
    R+Sequals,get type+tag+type,(
        type=Istatic stack,error+tag redefined+tag+type,skip all;
        ahead+Sopen,D+Dtable,D+tag,
             list fill+tag,D+Dpoint;
        error+filling list expected,skip all);
    +),
   (R+Scomma,:table declaration; 
    R+Spoint;
    error+wrong list declaration,skip to point).
'a'external list declaration+>xtype-tag:
   list description+xtype+tag,
   (tag=Pdummy,skip all;
    (is local tag+tag,error+no local tag for external+tag;+),
    correct calibre+tag,
    (R+Sequals,(-x:is string+x,forget string+x;
                 error+string expected);+)),
    (R+Scomma,:external list declaration;
     R+Spoint;
     must+Spoint,skip to point).
$- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ stack declaration: [estimate](fields)TAG
$ there must be brackets for the estimate, but it can be empty
$ (selector fields) can be omitted
$ estimate: [ number ] [=number=] [ tag ] [=tag=]
$ flag:         1           2        3       4
'a'stack size estimator+esize>+flag>:
   R+Ssub, (R+Sbox,1->flag;0->flag),
     (is cons+esize,(esize=0,0->flag;incr+flag);
      is tag +esize, add+flag+3+flag;
      0->esize->flag),
     Rskip+Sbox,
     must+Sbus;
   0->esize->flag. $ no estimator
$ type=Istack or type=Istatic stack
'a'stack declaration+>type-tag-esize-flag-oldflag:
   stack size estimator+esize+flag,$ 0: no estimator; 1,2,3,4 $
   list description+type+tag,
   (tag=Pdummy,skip all; $ some error $
    (flag=0,(type=Istack;error+size estimate missing+tag); $ no estimator $
     get flag+tag+oldflag,
      (oldflag=0,put flag+tag+flag,put esize+tag+esize;
       error+stack tag redefined+tag)
    ),
    (R+Sequals,( $initializer 
        ahead+Sopen,D+Dstack,D+tag,
             list fill+tag,D+Dpoint;
        error+filling list expected,skip all);
    +)),
   (R+Scomma,:stack declaration;
    R+Spoint;
    error+wrong list declaration,skip to point).
$================================================================$
$ constant and variable declaration $
$ 'const' const = <initializer>.
$ 'var'   var = <initializer>.
$ initializer is a constant expression. Expressions are stored
$ in the EXPRESSION stack. Symbolic read swallows the minus sign before
$ integer and hex denotation.
$ <L, >L, <>L, L, () * / + - ~ | & ^
'stack'[1]EXPRESSION.
'table'MESSAGE=(
 "wrong expression syntax"              :wrong expression,
 "wrong or missing expression"          :wrong or missing expression,
 "while computing %p:"
     " %p must be a stack or table" :in expr used as list,
 "while computing %p:"
     " %p refers to itself"         :rec expr,
 "while computing %p:"
     " %p has wrong type '%p'"      :expr undef tag,
 "while computing %p: division by zero"
                                        :division by zero,
$ warning
"only virtual bounds in constant expression" :virtual bounds only
).
$ store an expression to the EXPRESSION stack
'a'push expr+>x: extend+EXPRESSION+x.
'p'is expression+>err>:
   (R+Sminus,push expr+Sminus;+),
   exprbase+err,
    (nxt:is+err;
     R+Sboolor,push expr+Sboolor,exprbase+err,:nxt;
     R+Sbooland,push expr+Sbooland,exprbase+err,:nxt;
     R+Sboolxor,push expr+Sboolxor,exprbase+err,:nxt;
     R+Splus,push expr+Splus,exprbase+err,:nxt;
     R+Sminus,push expr+Sminus,exprbase+err,:nxt;
     $ as a*b-3 becomes "a" "*" "b" "-3" we need this trick
     ahead+Scons,push expr+Splus,exprbase+err,:nxt;
     R+Sasterisk,push expr+Sasterisk,exprbase+err,:nxt;
     R+Sslash,push expr+Sslash,exprbase+err,:nxt;
     +).
'p'exprbase+>err>-x:
  is cons+x,push expr+Scons,push expr+x;
  is tag+x,push expr+x;
  R+Scomplement,push expr+Scomplement,
     (exprbase+err;is+err;1->err,error+wrong expression);
  R+Svlwb,push expr+Svlwb,(is tag+x,push expr+x;1->err,error+tag expected);
  R+Svupb,push expr+Svupb,(is tag+x,push expr+x;1->err,error+tag expected);
  R+Slwb,warning+1+virtual bounds only,push expr+Svlwb,
        (is tag+x,push expr+x;1->err,error+tag expected);
  R+Supb,warning+1+virtual bounds only,push expr+Svupb,
        (is tag+x,push expr+x;1->err,error+tag expected);
  R+Scalibre,push expr+Scalibre,(is tag+x,push expr+x;1->err,error+tag expected);
  R+Sopen,push expr+Sopen,
      (is expression+err;is+err;1->err,error+wrong expression),push expr+Sclose,must+Sclose.
'q'loose calibre+>tag+val>-type:
   get type+tag+type,
   (type=Itable;type=Istack;type=Iext table;type=Iext stack;type=Istatic stack),
    get calibre+tag+val,val>0.
'p'loose constant tag+>tag+val>-type-expr:
   get type+tag+type,
     (type=Iconstant,get repr+tag+val;
      type=Ieconst,get repr+tag+expr,put type+tag+Irecconst,
           (loose eval expr+expr+val,put type+tag+Iconstant,
                        put repr+tag+val;
            put type+tag+Ieconst,-)).
'p'loose eval expr+>expr>+val>:loose eval bool+expr+val+Sboolor.
'p'loose eval bool+>expr>+val>+>op-v:
   loose eval arith+expr+val,(nxt: =EXPRESSION[expr]=
     [Sboolxor], incr+expr,loose eval arith+expr+v,boolxor+val+v+val,:nxt;
     [Sbooland], (op>Sbooland,+;incr+expr,loose eval bool+expr+v+Sboolxor,booland+val+v+val,:nxt);
     [Sboolor],  (op>Sboolor,+;incr+expr,loose eval bool+expr+v+Sbooland,boolor+val+v+val,:nxt);
     +).
'p'loose eval arith+>expr>+val>-v:
   (EXPRESSION[expr]=Sminus,incr+expr,loose eval term+expr+val,subtr+0+val+val;
    loose eval term+expr+val),
   (nxt: =EXPRESSION[expr]=
     [Splus], incr+expr,loose eval term+expr+v,add+val+v+val, :nxt;
     [Sminus],incr+expr,loose eval term+expr+v,subtr+val+v+val,:nxt;
     +).
'p'loose eval term+>expr>+val>-v:
   loose eval base+expr+val,(nxt: =EXPRESSION[expr]=
     [Sasterisk],incr+expr,loose eval base+expr+v,mult+val+v+val,:nxt;
     [Sslash],incr+expr,loose eval base+expr+v,v!=0,div+val+v+val,:nxt;
     +).
'p'loose eval base+>expr>+val>:
   =EXPRESSION[expr]=
   [Scomplement],incr+expr,loose eval base+expr+val,bool invert+val+val;
   [Scons], incr+expr,EXPRESSION[expr]->val,incr+expr;
   [Sopen], incr+expr,loose eval expr+expr+val,incr+expr;
   [Scalibre], incr+expr,loose calibre+EXPRESSION[expr]+val,incr+expr;
   [LADM], loose constant tag+EXPRESSION[expr]+val,incr+expr;
   -.
'a'expect expression+ptr>-err:
  >>EXPRESSION->ptr, 0->err,
  (is expression+err;1->err,error+wrong or missing expression),
  (is+err,unstack to+EXPRESSION+ptr,nil->ptr,skip all; $stop before . $
   push expr+Spoint,incr+ptr).
'a'unlink external+>tag-link:
   link ext=tag,get adm+tag+link ext;
   link ext->link,(nxt:link=0;
          adm*LADM[link]=tag,adm*LADM[tag]->adm*LADM[link];
          adm*LADM[link]->link,:nxt).
'a'add initializer+>ctype+>etype+>xtype+>tag-type-expr-expr1-val: $ constant or expression type
  get type+tag+type,
  ((type=xtype, $ was external constant/variable; unlink and reset the type $
       put type+tag+Iempty, unlink external+tag;
   type=Iempty),expect expression+expr,expr->expr1,
    (expr=nil; $ some error
      (loose eval expr+expr1+val,decr+expr,unstack to+EXPRESSION+expr,
         put type+tag+ctype,put repr+tag+val;
       put type+tag+etype,put repr+tag+expr),
      put adm+tag+link cons,tag->link cons
    );
   error+tag redefined+tag+type,skip all).
$ constant declaration $
'a'constant declaration-tag:
  (is definition tag+1+tag,
    (R+Sequals,add initializer+Iconstant+Ieconst+Iext cons+tag;
     define cv external+tag+Iext cons+Iconstant); $ add external constant definition
   error+tag expected,skip all),
  (R+Scomma,:constant declaration;
   R+Spoint;
   must+Spoint,skip to point).
'a'variable declaration-tag:
  (is definition tag+1+tag,(
    R+Sequals,add initializer+Ivariable+Ievar+Iext var+tag;
    define cv external+tag+Iext var+Ivariable); $ add external variable definition
   error+tag expected after+Svarsymb,skip all),
  (R+Scomma,:variable declaration;
   R+Spoint;
   must+Spoint,skip to point).
'a'static variable declaration-tag:
  (is definition tag+1+tag,must+Sequals,add initializer+Istatic var+Istevar+Iext cons+tag;
   error+tag expected,skip all),
  (R+Scomma,:static variable declaration;
   R+Spoint;
   must+Spoint,skip to point).
'a'define cv external+>tag+>xtype+>ytype-type:
  get type+tag+type,
    (is local tag+tag,error+no local tag for external+tag;
     type=Iempty,put type+tag+xtype,put adm+tag+link ext,tag->link ext;
     type=ytype;type=xtype;
     (type=Ipointer constant,ytype=Iconstant);
     error+tag redefined+tag+type).
'a'external cv declaration+>xtype+>ytype-tag:
  (is definition tag+1+tag,define cv external+tag+xtype+ytype,
$  get type+tag+type,
$    (is local tag+tag,error+no local tag for external+tag;
$     type=Iempty,put type+tag+xtype,put adm+tag+link ext,
$       tag->link ext;
$     type=ytype;
$     error+tag redefined+tag+type),
    (R+Sequals,(-x:is string+x,forget string+x;
                    error+string expected);+);
   error+tag expected,skip all),
  (R+Scomma,:external cv declaration;
   R+Spoint;
   must+Spoint,skip to point).
'a'external constant declaration:
  external cv declaration+Iext cons+Iconstant.
'a'external variable declaration:
  external cv declaration+Iext var+Ivariable.
$================================================================$
$ VIRTUAL ADDRESS SPACE DISTRIBUTION $
'constant'min virtual address=0x01000000,max virtual address=0x3fff0000,
          min private address=0x40000000,max private address=0x7fff0000.
'table'MESSAGE=(
 "stack %p: error computing size estimate"
                                  :not absolute constant as stack size,
 "stack %p: size estimate is not a constant type"
                                  :not a constant as stack size,
 "stack %p: size estimate is negative %d " :negative stack size,
 "list %p: virtual space is too small, should be at least %d"
                                  :too small virtual space,
 "insufficient virtual space"     :insufficient virtual space
).
$ first loose constant evaluation $
'a'correct calibre+>tag-x-ssel:
  (get calibre+tag+x,x=0),put calibre+tag+1,
    pack selector+tag+tag+ssel,put type+ssel+Iselector,put adm+ssel+tag,
    put repr+ssel+1; $ repr equals calibre $
  +.
'a'find ssel+>tag-x-ssel:
  pack selector+tag+tag+ssel,get repr+ssel+x,put ssel+tag+x.
'a'first constant eval+>tag-n-expr: $ loose eval changes expr
  type*LADM[tag]=Ieconst,put type+tag+Irecconst,get repr+tag+expr,
    (loose eval expr+expr+n,put type+tag+Iconstant,put repr+tag+n;
     put type+tag+Ieconst);
  +.
'a'first constant sweep-tag:
  link list->tag, $ correct calibre and ssel first $
    (nxt: tag=0;
          correct calibre+tag,get adm+tag+tag,:nxt),
  link cons->tag, $ loose constant evaulation can use calibre $
      (nxt: tag=0;
          first constant eval+tag, get adm+tag+tag,:nxt).
$ collect absolute and relative sizes $
'a'get constant value+>tag+val>-repr-type:
  get esize+tag+repr,get type+repr+type,
    (type=Iconstant,get repr+repr+val; $ OK $
     type=Ieconst,error+not absolute constant as stack size+tag,0->val;
     error+not a constant as stack size+tag,0->val).
'a'get raw estimates+>tag+abs>+rel>-flag-type:
  0->abs,0->rel,get flag+tag+flag,
  (=flag= $ 1: [number]  2: [=number=], 3: [var], 4:[=var=]
   [0],get type+tag+type,(type=Itable;
          1->rel,put esize+tag+rel,put flag+tag+1);
   [1],get esize+tag+rel,
        (rel<0,Xerror+negative stack size+tag+rel,0->rel;+),
        put esize+tag+rel;
   [2],get esize+tag+abs,
        (abs<0,Xerror+negative stack size+tag+abs,0->abs;+),
        put esize+tag+abs;
   [3],get constant value+tag+rel,
        (rel<0,Xerror+negative stack size+tag+rel,0->rel;+),
        put esize+tag+rel;
   [4],get constant value+tag+abs,
        (abs<0,Xerror+negative stack size+tag+abs,0->abs;+),
        put esize+tag+abs;
   +).
'a'get estimates+>tag+abs>+rel>-fill:
  get raw estimates+tag+abs+rel, $ absolute, relative $
  (rel=0,get fsize+tag+fill,(abs<fill,fill->abs;+),
        incr+abs,incr+abs,put esize+tag+abs,put flag+tag+2;
        $ add one to avoid overlapping virtual spaces $
   +).
'a'set list bounds+>tag+>virtual>+>by-flag-size-fill:
  get esize+tag+size,get flag+tag+flag,
  (=flag= [1;3], $ relative size $
      mult+size+by+size, get fsize+tag+fill,
      (size<=fill,Xerror+too small virtual space+tag+fill;+);
   + $ absolute size $ ),
  put vlwb+tag+virtual,add+virtual+size+size,size->virtual,
     decr+size,decr+size,put vupb+tag+size.
$ returns the total absolute and relative request sizes
'a'list size claims+abs>+rel>-tag-a-r:
  link list->tag, 0->abs,0->rel,
    (nxt: tag=0; 
          get estimates+tag+a+r,add+abs+a+abs,add+rel+r+rel,
            get adm+tag+tag,:nxt).
'a'list bounds-rel-abs-max-min-by-tag-addr:
    first constant sweep, $ corrects all calibre $
    list size claims+abs+rel,
    (is+in module,min private address->min,max private address->max;
       min virtual address->min,max virtual address->max),
    subtr+max+min+by,subtr+by+abs+by,
    (rel=0,1->by;div+by+rel+by,(by<=0,0->by,Xerror+insufficient virtual space;+)),
    link list->tag,min->addr,
    (nxt: tag=0;
          set list bounds+tag+addr+by,find ssel+tag,
          put flag+tag+0,get adm+tag+tag,:nxt).
$ list vlwb: index zero, first element is at index 1.
$ list vupb: last index
$ list ssel: standard selector (<=0 if not set)
$ list calibre: set
$ list flag: zero
$ = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = $
$ straightening constant and variable initializers $
'var'tag evaluated=0. $ tag under evaluation
'a'second constant eval+>tag-n-expr:
  =type*LADM[tag]=
  [Ieconst],tag->tag evaluated,put type+tag+Irecconst,
    get repr+tag+expr,strict eval expr+expr+n,
    put type+tag+Iconstant,put repr+tag+n;
  [Ievar],tag->tag evaluated,get repr+tag+expr,
    strict eval expr+expr+n,
    put type+tag+Ivariable,put repr+tag+n;
  [Istevar],tag->tag evaluated,get repr+tag+expr,
    strict eval expr+expr+n,
    put type+tag+Istatic var,put repr+tag+n;
  +.
'q'is list type+>tag-type:
   get type+tag+type,(type=Itable;type=Istack;type=Istatic stack).
'a'strict calibre+>tag+val>-type:
  get type+tag+type,(=type=
  [Itable;Istack;Istatic stack;Iext table;Iext stack],
            get calibre+tag+val;
  0->val,Xerror+in expr used as list+tag evaluated+tag).
'a'strict upb+>tag+val>:
  is list type+tag,get vupb+tag+val;
  0->val,Xerror+in expr used as list+tag evaluated+tag.
'a'strict lwb+>tag+val>-cal:
  is list type+tag,get calibre+tag+cal,get vlwb+tag+val,
       add+val+cal+val;
  0->val,Xerror+in expr used as list+tag evaluated+tag.
'a'strict pointer+>tag+val>-list:
  get adm+tag+list,(is list type+list,
   get vlwb+list+val,add+val+repr*LADM[tag]+val;
  0->val,error+internal error).
'a'strict constant tag+>tag+val>-expr-oldtag:
  =type*LADM[tag]=
  [Iconstant],get repr+tag+val;
  [Ieconst], tag evaluated->oldtag,tag->tag evaluated,
             get repr+tag+expr,put type+tag+Irecconst,
             strict eval expr+expr+val,put type+tag+Iconstant,
             put repr+tag+val,oldtag->tag evaluated;
  [Irecconst],error+rec expr+tag evaluated+tag,
             0->val, put type+tag+Iconstant,put repr+tag+val;
  [Ipointer constant], strict pointer+tag+val;
  0->val,Xerror+expr undef tag+tag evaluated+tag+type*LADM[tag].
'a'strict eval expr+>expr+val>:strict eval bool+expr+val+Sboolor.
'a'strict eval bool+>expr+val>+>op-v:
  strict eval arith+expr+val,(nxt: =EXPRESSION[expr]=
    [Sboolxor],incr+expr,strict eval arith+expr+v,boolxor+val+v+val,:nxt;
    [Sbooland],(op>Sbooland,+;incr+expr,strict eval bool+expr+v+Sboolxor,
                  booland+val+v+val,:nxt);
    [Sboolor], (op>Sboolor,+;incr+expr,strict eval bool+expr+v+Sbooland,
                  boolor+val+v+val,:nxt);
    +).
'a'strict eval arith+>expr>+val>-v:
  (EXPRESSION[expr]=Sminus,incr+expr,strict eval term+expr+val,subtr+0+val+val;
   strict eval term+expr+val),
  (nxt: =EXPRESSION[expr]=
    [Splus], incr+expr,strict eval term+expr+v,add+val+v+val,:nxt;
    [Sminus],incr+expr,strict eval term+expr+v,subtr+val+v+val,:nxt;
    +).
'a'strict eval term+>expr>+val>-v:
  strict eval base+expr+val,(nxt:=EXPRESSION[expr]=
    [Sasterisk],incr+expr,strict eval base+expr+v,mult+val+v+val,:nxt;
    [Sslash],incr+expr,strict eval base+expr+v,
       (v=0,0->val,Xerror+division by zero+tag evaluated,:nxt;
        div+val+v+val,:nxt);
    +).
'a'strict eval base+>expr>+val>:
  =EXPRESSION[expr]=
  [Scomplement],incr+expr,strict eval base+expr+val,bool invert+val+val;
  [Scons],incr+expr,EXPRESSION[expr]->val,incr+expr;
  [Sopen],incr+expr,strict eval expr+expr+val,incr+expr;
  [Scalibre],incr+expr,strict calibre+EXPRESSION[expr]+val,incr+expr;
  [Svlwb],incr+expr,strict lwb+EXPRESSION[expr]+val,incr+expr;
  [Svupb],incr+expr,strict upb+EXPRESSION[expr]+val,incr+expr;
  strict constant tag+EXPRESSION[expr]+val,incr+expr.
'a'second constant sweep-tag: $ go over const and var decralations
  link cons->tag,
  (nxt:tag=0;
     second constant eval+tag,get adm+tag+tag,:nxt).
$================================================================$
$ Charfile, datafile declaration $
'table'MESSAGE=(
 "file-string expected"           :file string expected,
 "read or write direction only"   :file direction,
 "too many datafile area (max %d)":too many datafile area
).
'a'file initializer+mode>+path>:
  R+Sequals,(R+Sright,/r/->mode;/w/->mode),
    (is string+path;empty string->path),
    (path=empty string,error+file string expected,0->path;
     add stdstring+path+path),
    (R+Sright,(mode=/w/;error+file direction);
     mode=/r/;error+file direction);
  error+file string expected,/*/->mode,0->path.
'a'set file type+>tag+>type-otype:
  get type+tag+otype,
    (otype=Iempty,put type+tag+type,put adm+tag+link file,
          tag->link file;
     error+tag redefined+tag+otype).
'a'charfile declaration-tag-mode-path:
  (is definition tag+1+tag,file initializer+mode+path,
       set file type+tag+Icharfile,
       D+Dcharfile,D tag+tag,D cons+mode,D tag+path;
   error+tag expected,skip all),
  (R+Scomma,:charfile declaration;
   R+Spoint;
   must+Spoint,skip to point).   
'a'file area-tag-type-cnt:
  is+Ssub,D+Dsub,0->cnt,(nxt:
    (is tag+tag,incr+cnt,D tag+tag,get type+tag+type,
       (=type= 
        [Iempty;Itable;Istack;Istatic stack;Iext table;Iext stack],+;
        error+must be of list type+tag+type);
     error+tag expected after+Ssub),
    (cnt<max datafile area;error+too many datafile area+max datafile area),
    (R+Ssemicolon,:nxt;must+Sbus),D+Dbus);
  +.
'a'datafile declaration-tag-mode-path:
  (is definition tag+1+tag, D+Ddatafile,D tag+tag,file area,
       file initializer+mode+path,
       set file type+tag+Idatafile,
       D cons+mode,D tag+path;
   error+tag expected,skip all),
  (R+Scomma,:datafile declaration;
   R+Spoint;
   must+Spoint,skip to point).
$================================================================$
$ formal affix $
'table'MESSAGE=(
 "rule %p: wrong formal affix (tag expected)": formal tag expected,
 "rule %p: rule as formal affix"          :rule in affix,
 "rule %p: error in rule head"            :in rule head,
 "formal affix %p: has wrong type (was %p)"  :formal type mismatch,
 "formal affix %p: redefined"             :formal affix redefined,
 "%p is not a rule (%p), cannot be macro" :not a rule,
 "rule %p: redefined with different type" :rule type different,
 "rule %p: extra formal affixes"          :extra affix,
 "rule %p: missing formal affixes"        :missing formal affix,
 "rule %p: more than one repeat affix"    :more repeat affix,
 "rule %p: repeat affix is the last one"  :last repeat affix,
 "no formal repeat affix defined for rule %p" :no formal repeat affix,
$ warning
 "rule %p: function without out affixes"  :function without out affixes
).
$======================================================================$
$ SKIP OVER FORMAL AFFIXES $
$ check syntax, set 1->err and issue error message
$ expected symbol after the sequence: equals, comma, minus, colon, point
'a'subbus+>err>:
  is+err,Rskip+Ssub,Rskip+Sbus;
  R+Ssub,(R+Sbus;1->err,error+expected+Sbus);
  1->err,error+expected+Ssub.
'a'expect formal tag+>ruletag+>err>-tag:
  is+err,(is raw tag+#;+);
  is tag+tag,(tag=ruletag,1->err,error+rule in affix+tag;+);
  1->err,error+formal tag expected+ruletag.
'a'skip formal affix+>ruletag+>err>:
  is+err;
  ahead+Ssub,subbus+err,
       skip field list+err,expect formal tag+ruletag+err,subbus+err;
  ahead+Sopen,skip field list+err,expect formal tag+ruletag+err,subbus+err;
  R+Squote image,expect formal tag+ruletag+err;
  R+Sright,expect formal tag+ruletag+err,R skip+Sright;
$ !!!!!!!!!!!!!!!!!!!
  R+Sasterisk,(is raw tag+#;+);
$                  expect formal tag+ruletag+err;
  expect formal tag+ruletag+err,(R+Sright;ahead+Ssub,subbus+err;
      1->err,error+expected+Sright).
$ err=1: syntax error; fast=1/0 for prototype/declaration
$ don't do when there was an error
'a'peek after formal affixes+>ruletag+>err>+fast>:
  is+err, 0->fast;
  init restore,0->fast,
  (nxt:R+Splus,skip formal affix+ruletag+err,:nxt;+),
  (is+err;
   ahead+Spoint,1->fast;
   ahead+Scomma,1->fast;
   ahead+Sequals,1->fast;
   ahead+Sminus;ahead+Scolon;
   error+in rule head+ruletag,1->err),
  (is+err,forget restore;make restore).
$======================================================================$
$ FORMAL AFFIXES $
$ formal affix+ >fast + >formal> + >err>:
$   work only when err=0, looking at a valid formal affix.
$   when fast=1, check/set type; when fast=0 it is a definition
$   formal=0: create new, formal!=0: check against it.

$ read a formal affix. It is syntactically correct, read second time
'q'has formal type+>tag-type:
  get type+tag+type,type>=Ifirst formal type.
$ formal is either zero, or an entry in LADM
$ if zero, create one and fill type (repr=0)
'a'check as formal+>formal>+>tag+>type+>err>-otype:
  is+err;
  is+formal,get type+formal+otype,(otype=type;
      error+formal type mismatch+tag+otype,1->err);
  new tag entry+tag*LADM[tag]+formal,put type+formal+type.
$ formal is either zero of is an entry in LADM
$ create new "formal" (if necessary) and make "tag" refer to it.
'a'define as formal+ >formal> + >tag + >type +>err>:
  is+err;
  has formal type+tag,1->err,error+formal affix redefined+tag;
  check as formal+formal+tag+type+err,(is+err;redefine tag+tag+formal).
$ define all selectors for a formal list, including the standard one
$ on entry type*tag is "formal stack" or "formal table"
$ store calibre in repr*tag
$ set err if the same selector is defined twice
'a'define formal selector list+>tag+>err>-sel-fmsel-n:
  is+err; $ some error meanwhile
  R+Sopen,1->n, $ we have a selector list $
    (nxt:(is tag+sel,pack selector+sel+tag+sel,
            (has formal type+sel,1->err,error+doubly defined selector+sel;
             new tag entry+tag*LADM[sel]+fmsel,redefine tag+sel+fmsel,
              put adm+fmsel+tag,
              put type+fmsel+Iformal selector,put repr+fmsel+n);
          error+internal error,'exit'3),
         (R+Scomma,incr+n,:nxt;
          R+Sequals,:nxt;
          +)),
    must+Sclose,put repr+tag+n, $ calibre $
    pack selector+tag+tag+sel, $ L*L
    (has formal type+sel; $ if L*L defined, if not, set it to -1 $
     new tag entry+tag*LADM[sel]+fmsel,redefine tag+sel+fmsel,
     put adm+fmsel+tag,
     put type+fmsel+Iformal selector, put repr+fmsel+-1);
  $ no selector list, create standard selector =1 $
  put repr+tag+1,$ calibre $
    pack selector+tag+tag+sel,new tag entry+tag*LADM[sel]+fmsel,redefine tag+sel+fmsel,
    put adm+fmsel+tag,
    put type+fmsel+Iformal selector,put repr+fmsel+1.
$ formal affix
$ if "fast" is set, then this is a prototype (no selectors, no tags)
$ if "formal" is not zero, stored type is checked,
$ otherwise "formal" is created. If fast=0 it is attached to the tag read
$ when entering, err=0
'a'formal list affix+>fast+>formal>+>ftype+>err>-tag:
  get list tag+0+tag, $ read after selector list, if any $
  (tag=Pdummy,error+internal error,'exit'3;
   is+fast,skip field list+err,must tag+tag,subbus+err,
    check as formal+formal+tag+ftype+err;
   define as formal+formal+tag+ftype+err,
     define formal selector list+formal+err,Rskip+tag,subbus+err).
$ when fast=1: don't fill tag in "formal"
$ when entering err=0
'a'formal flat affix+>fast+>formal>+>tag+>ftype+>err>:
   is+fast,check as formal+formal+tag+ftype+err;
   define as formal+formal+tag+ftype+err.
$ !!!!!!!!!!!!!!!!!!!!!!
$ when fast=1: don't fill tag in formal
'a'formal repeat affix+>formal>+>err>-otype:
   is+err;
    $is+fast,=> check; if "formal" is set then it must have the same type;
    $        otherwise make "formal" a fine LADM entry
    $        otherwise the same, but call "redefine"
   is+formal,get type+formal+otype,
     (otype=Iformal repeat;error+formal type mismatch+Iformal repeat+otype,1->err);
   new tag entry+Pdummy+formal,put type+formal+Iformal repeat.
$ fast=1: don't fill tag in formal
$ when err=1 might not advance properly
'a'formal affix+>fast+>formal>+>err>-tag-type:
  is+err;
  R+Ssub,R skip+Sbus,  $[](selector list)tag[] or []tag[]$
     formal list affix+fast+formal+Iformal stack+err;
  ahead+Sopen, $(selector list)tag[] $
     formal list affix+fast+formal+Iformal table+err;
  R+Squote image,must tag+tag, $ ""f $
     formal flat affix+fast+formal+tag+Iformal file+err;
  R+Sright,must tag+tag, $ >tag | >tag> $
     (R+Sright,Iformal inout->type; Iformal in->type),
     formal flat affix+fast+formal+tag+type+err;
  R+Sasterisk, $ * or (*)
     Iformal repeat->type,(is raw tag+#;+),
$ !!!!!!!!!!!!!!!!!!!!!! dummy tag for a dummy formal affix
$     must tag+tag,formal flat affix+fast+formal+tag+type+err;
     formal repeat affix+formal+err,
       (is+err;is+fast;formal->repeat affix);
  must tag+tag, $ tag> | tag[] $ $ valid only when err=0 $
     (R+Sright,formal flat affix+fast+formal+tag+Iformal out+err;
      Rskip+Ssub, $ looking at Sbus
        formal flat affix+fast+formal+tag+Iformal table+err,
        (is+fast;define formal selector list+formal+err),Rskip+Sbus).
$------------------------------------------------------------------$
$ LADM rule flags $
$ rule flags are stored in repr*rule as bits
$ when the rule appears in a pragmat, its type is set, but not
$  "r proto", which indicates that a valid prototype has been read.
$  "r defined" says that the rule was defined (and no need to define)
$
'constant'
  $ type: 'a','p','f','q','e'
    r side effect=2, $ has side effects
    r can fail=4,    $ question of predicate
    r type=6,        $ 'a','p','f','q','e'
    r action=2,r pred=6,r func=0,r que=4,
  $ other flags
    r defined=1,     $ was defined
    r macro=8,       $ macro or inline
    r proto=0x10,    $ had prototype
    r vararg=0x20,   $ has * as a formal affix
    r outvararg=0x40,$ has out> as formal vararg
    r shiftrule=0x80,
    r external=0x100,$ is in an 'x'; implies r defined
    r public=0x200,  $ public, compile even if macro
    r called=0x400,  $ called
    r exit=0x800,    $ 'exit' inside the rule
    r optimize=r side effect|r outvararg|r exit|r shiftrule, 
                     $ don't optimize out if any of these are set
  $ flags when checking macros for recursive calls
    r mchecking=0x1000,  $ checking right now
    r mchecked =0x2000,  $ has been checked OK
  $ flags for "shift vararg block" and "get vararg blocks"
    r shiftarg=r shiftrule|r external|r defined|r proto|r que,
    r getvararg=r shiftrule|r external|r defined|r proto|r func.
'f'get rule flag+>rule+>flag+x>:
   bool and+repr*LADM[rule]+flag+x.
'q'is rule flag+>rule+>flag-x:
   bool and+repr*LADM[rule]+flag+x,x!=0.
'a'set rule flag+>rule+>flag:
   bool or+repr*LADM[rule]+flag+repr*LADM[rule].
'a'clear rule flag+>rule+>flag-mask:
   bool invert+flag+mask,bool and+repr*LADM[rule]+mask+repr*LADM[rule].
$ ruletype: r action |r func | r que | r pred
$  if type not defined, then set, otherwise must agree
$  rule tag can occur in pragmats earlier to their definition
'a'check rule type+>ruletype+>ruletag+err>-otype:
   0->err,get type+ruletag+otype,
   (otype=Iempty,put type+ruletag+Irule,
        set rule flag+ruletag+ruletype;
    otype=Irule,get rule flag+ruletag+r type+otype,
       ((is rule flag+ruletag+r proto,otype!=ruletype),
           error+rule type different+ruletag,1->err;
        set rule flag+ruletag+ruletype);
    error+tag redefined+ruletag+otype,1->err).
$ set the rule to be a macro
'a'mark rule as macro+>ruletag-type:
   get type+ruletag+type,
   (ruletag=Xshift varargs,error+cannot be a macro+ruletag;
    ruletag=Xget varargs,error+cannot be a macro+ruletag;
    type=Iempty,put type+ruletag+Irule,
      set rule flag+ruletag+r macro;
    type=Irule,
       (is rule flag+ruletag+r external,error+no external macro+ruletag;
        set rule flag+ruletag+r macro);
    error+not a rule+ruletag+type).

$ check formal affixes just after the rule tag.
$  called when the rule has prototype, should not be defined
$  fast=1 when prototype only
$  when err=1, might skip just before the next point.
$  set repeat affix when appropriate
'a'check formal affixes+>fast+>rtag+err>-formal:
   0->err,get adm+rtag+formal, $ go over all defined formal affixes
    (nxt: is+err; $ error meanwhile
          R+Splus,
           (formal=0,error+extra affix+rtag,1->err;
            formal affix+fast+formal+err,get adm+formal+formal,:nxt);
          +),
    (is+err, skip all;
     formal=0;
     error+missing formal affix+rtag,1->err).
$ create formal affixes first time
$  called when the rule does not have prototype yet.
$  fast=1 when creating prototype only
$  when err=1 might skip just before the next point.
$ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'variable'repeat affix=0.
'a'create formal affixes+>fast+>rtag+err>-link-formal-flag:
  0->err->flag,0->repeat affix,rtag->link,
   (nxt: is+err; $ error meanwhile
         R+Splus,0->formal,formal affix+fast+formal+err,
           (is+err;
            (=type*LADM[formal]=
             [Iformal repeat],(is+flag,1->err,error+more repeat affix+rtag;
                               $ if fast=0 then formal=repeat affix $
                               1->flag,set rule flag+rtag+r vararg);
             [Iformal out],(is+repeat affix,set rule flag+rtag+r outvararg;+);
             +),
            put adm+link+formal,formal->link,:nxt);
         flag=0;
         (-type:get type+link+type,type=Iformal repeat),
              1->err,error+last repeat affix+rtag;
         +),
   $ if error, redo possible assignments $
   (is+err,put adm+rtag+0,skip all;
    is rule flag+rtag+r type; $ not a 'function'
    get adm+rtag+formal,0->flag,
      (nxt-type:formal=0;
        get type+formal+type,(=type=
          [Iformal out;Iformal inout],1->flag;+),
        get adm+formal+formal,:nxt),
      (is+flag;
       warning+4+function without out affixes+rtag)
   ).
$------------------------------------------------------------------$
'table'MESSAGE=(
 "rule tag expected"            :rule tag expected
).
$ call "restore tags" no matter what $

$ we are after the rule tag and just before the first + symbol
$ either generate types, or check types
$ the formal affix sequence is syntactically correct.
$ in case of error might skip to the next point
'a'check external rule+>external+>rtag:
  external=0;
  is local tag+rtag,error+no local tag for external+rtag;
  is rule flag+rtag+r macro,error+no external macro+rtag;
  set rule flag+rtag+r defined,set rule flag+rtag+r external,
  (* link rule->adm, rtag->tag *)LADM,>>LADM->link rule.
'a'rule prototype+>rtag+>external-err:
  is rule flag+rtag+r proto, $ we have a prototype, check it
    ((is+external,is rule flag+rtag+r defined),
                         error+tag redefined+rtag+Irule;
     check formal affixes+1+rtag+err,
     (is+err;check external rule+external+rtag));
  create formal affixes+1+rtag+err, $ no prototype $
    (is+err;
     set rule flag+rtag+r proto,check external rule+external+rtag).
'a'rule prototype sequence+>ruletype+>external:
  $ skip external strings $
  (R+Sequals,(-x:is string+x,forget string+x;error+string expected);+),
  (R+Scomma,
    (-ruletag-err:is definition tag+1+ruletag,
        check rule type+ruletype+ruletag+err,
        peek after formal affixes+ruletag+err+#,
        (is+err,skip all; rule prototype+ruletag+external),
        :rule prototype sequence;
     error+rule tag expected,skip all,:rule prototype sequence);
   R+Spoint;
   must+Spoint,skip to point).
$ a rule definition, here are only the formal affixes
$ the main work is done in "rule body+ruletag"
'a'rule definition+>rtag-err:
  is rule flag+rtag+r defined,
    error+tag redefined+rtag+Irule,skip to point;
  (is rule flag+rtag+r proto, $ we have a prototype, check it
    check formal affixes+0+rtag+err;
   create formal affixes+0+rtag+err),
    (is+err,(R+Spoint;skip to point);
     set rule flag+rtag+r defined,set rule flag+rtag+r proto,
     rule body+rtag).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ just after 'a','p','f','q' symbol (external declaration included)
$ ruletype is one of r action | r func | r que | r pred
$ skips over the next point
'a'rule declaration+>ruletype+>external-ruletag-err-fast:
  is definition tag+1+ruletag,check rule type+ruletype+ruletag+err,
    peek after formal affixes+ruletag+err+fast,
    (is+err,skip to point; $ error in formal affixes
     (is+external;is+fast),
       rule prototype+ruletag+external,
       rule prototype sequence+ruletype+external;
     rule definition+ruletag,restore tags);
  error+rule tag expected,skip to point.

$==================================================================$
$ Local affixes $
$ tag: index in LADM[]; type*LADM[tag]=Ilocal; adm*LADM[tag]=LLOC[idx]
$ orepr,otype: original content of (repr,type)*LADM[tag]
$  local flags: filled (before); set (after)
$ formal affixes: index in LADM; repr->LLOC
$ local affixes:  index in LLOC
$  labels are NOT handled separately, rather for each jump locals
$  are searched for the right index in LLOC, and return the LLOC index
'table'MESSAGE=(
 "source or tag expected"       :source or tag expected,
 "wrong affix form"             :wrong affix form,
 "unknown label %p"             :unknown label,
 "formal selector %p is undefined"   :undefined formal selector,
 "source expected after %p"     :source expected,
 "formal affix %p is used as a rule" :wrong rule type,
 "member expected"              :member expected,
 "wrong zone"                   :wrong zone
).

'a'handle formal list+>formal+>local-ssel:
  =type*LADM[formal]=
  [Iformal stack;Iformal table], 
      repr*LADM[formal]->calibre*LLOC[local],D cons+calibre*LLOC[local],
      pack selector+formal+formal+ssel,repr*LADM[ssel]->ssel*LLOC[local],
      D cons+ssel*LLOC[local];
  +.
$ open a range:
'a'set up local stack+>rtag+loc>-formal-local:
    scratch+LLOC,get adm+rtag+formal,
    $ formal affixes $
    (nxt: formal=0;
       (*0->flag->repr,type*LADM[formal]->type,formal->tag,0->orepr->otype *)LLOC,
       >>LLOC -> local, handle formal list+formal+local, put repr+formal+local,
       get adm+formal+formal,:nxt),
    >>LLOC->loc,
    $ add rule tag as label $
    D+Dlabel,D+rtag,
    (* 0->flag->repr,Ilabel->type,rtag->tag,0->orepr->otype *)LLOC.
'a'open new local range+>label+old>:
    >>LLOC->old,
    (is+label,
      (* 0->flag->repr->orepr->otype,Ilabel->type,label->tag *)LLOC,
      D+Dlabel,D+label;+).
'a'add local affix+>tag-orepr-otype:
    get repr+tag+orepr,get type+tag+otype,
    (* 0->flag->repr,Ilocal->type,tag->tag,orepr->orepr,otype->otype *)LLOC,
    put type+tag+Ilocal,put repr+tag+>>LLOC.
'a'close local range+>old:
   >>LLOC <= old;
   $ type*LLOC can be Ilocal,ILabel,or some formal value $
   (type*LLOC=Ilocal,put repr+tag*LLOC+orepr*LLOC,put type+tag*LLOC+otype*LLOC;+),
   unstack+LLOC,:close local range.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'skip over an index+>err>:
   R+Ssub,skip over source+#+err,
         (R+Sbus;is+err; 1->err,error+expected+Sbus);
   +.
'a'skip over source+single>+>err>:
   0->single,(is+err;
      is cons+#;
      is tag+#,(R+Sasterisk,(is tag+#, skip over an index+err;
                         1->err,error+tag expected);
                ahead+Ssub,skip over an index+err;
                1->single);
     (R+Slwb;R+Supb;R+Svlwb;R+Svupb;R+Scalibre),
               (is tag+#;1->err,error+tag expected);
     1->err,error+source or tag expected).
$ skip over an extension when looking at * or lstar 
$  tag>    the stack to be extended;
$  simple> 1 if started with (* but ended with *<tag>; 2 if [* ... *]
$  err>    there was an error
'a'skip over destination+>err>-tag:
  is+err;
  R+Sarrow,(nxt: is tag+tag,(R+Sarrow,:nxt;+);
            1->err,error+selector expected);
  1->err,error+expected+Sarrow.
'a'skip over extension+tag>+simple>+err>:
   init restore,0->tag->err->simple,
   (R+Slstar;R+Ssubstar,2->simple;R+Sasterisk,1->simple;1->err),
   $ source -> destination
   (nxt: is+err;
         skip over source+#+err,skip over destination+err,
           (R+Scomma,:nxt;+)),
   $ * <tag> or *) <tag> $
   (simple=2,(R+Sstarbus;1->err,error+expected+Sstarbus);
    R+Sasterisk;
    is+err;
    1->err,error+expected+Sasterisk),
   (is+simple;R+Sclose;1->simple),
   (is tag+tag;is+err;1->err,error+selector expected),
   (is+err,forget restore,skip all;make restore).
$ check affix form, tranport, or relation.
$ if "err" is set, error messages are given; advance before point
$ if "tag" is set, it is transport (Darrow) or relation (others)
'a'peek after source+tag>+err>-single tag:
   init restore,0->err->tag,skip over source+single tag+err,
     (is+err;
      ahead+Sarrow,   get tag adm+Parrow+tag;
      ahead+Sequals,  get tag adm+Pequal+tag;
      ahead+Smore,    get tag adm+Pmore+tag;
      ahead+Sless,    get tag adm+Pless+tag;
      ahead+Snotequal,get tag adm+Pnotequal+tag;
      ahead+Slseq,    get tag adm+Plseq+tag;
      ahead+Smreq,    get tag adm+Pmreq+tag;
      is+single tag;
      1->err,error+wrong affix form),
     (is+err,forget restore,skip all;make restore).
$===================================================================$
$ RULE BODY $
$ formal affixes are read and OK; nothing has been emitted yet.
$  looking at local affix sequence and colon

'a'search jump+>tag-loc: $ search tag as a label; complain if not found
  >>LLOC->loc,(nxt:
     loc<<<LLOC,error+unknown label+tag;
     (type*LLOC[loc]=Ilabel,tag*LLOC[loc]=tag),D+Djump,D+loc;
     previous+LLOC+loc,:nxt).
'p'terminator-x:
  R+Splus,D+Dplus;
  R+Sminus,D+Dminus;
  R+Sexit,D+Dexit,0->x,source+Sexit+x;
  R+Scolon,(is tag+x,search jump+x;error+tag expected).
$ index source: just after a*b or abter b looking at [ $
$ indexed: called after []
$ list tag: called after <<, >>, <>
$ source:  a source must come, sets err if there was an error
'a'D selector+>sel+>tag-type-repr:
  pack selector+sel+tag+sel,
  (has formal type+tag,get type+sel+type,
      (type=Iformal selector,get repr+sel+repr;-1->repr),D cons+repr,
      (repr<=0,error+undefined formal selector+sel;+);
   D tag+sel).
'a'index source+>tag+>err>:
  R+Ssub,D+Dsub,source+tag+err,D+Dbus,
    (R+Sbus;is+err;1->err,error+expected after+Sbus+tag);
  D+Dsub,D+Supb,D tag+tag,D+Dbus.
'a'list tag+err>-tag:
  is tag+tag,0->err,D tag+tag;
  1->err,error+tag expected.
$ !!!!!!!!!!!!!!!!!!
'a'source+>tag+>err>-x-y:
  is+err;
  is cons+x,D cons+x;
  is tag+x,(R+Sasterisk,(is tag+y,index source+y+err,D tag+y,D selector+x+y;
                         1->err,error+tag expected after+Sasterisk);
            ahead+Ssub,index source+x+err,D tag+x,D selector+x+x;
            D tag+x);
  R+Slwb,D+Dlwb,list tag+err;
  R+Supb,D+Dupb,list tag+err;
  R+Svlwb,D+Dvlwb,list tag+err;
  R+Svupb,D+Dvupb,list tag+err;
  R+Scalibre,D+Dcalibre,list tag+err;
  1->err,error+source expected+tag,skip all.
'a'source or string+>tag+>err>-x-c:
  is string+x,add stdstring+x+c,
      D+Dplus,D tag+Xstring table,D+Dplus,D tag+c;
  R+Snoarg,D+Dplus,D+Dnoarg;
  D+Dplus,source+tag+err.
$ !!!!!!!!!!!!!!!!!!!
'p'vararg block+>tag+>err>:
  R+Sasterisk,(is+repeat affix,D+Dplus,D tag+repeat affix;
       error+no formal repeat affix+tag,1->err).
$ just before a "source" followed by ->, <, =, >=, etc.
'a'special affix form+>tag-err:
   D tag+tag,D+Dplus,0->err,source+tag+err,
     $ go over the relation or ->
     (is+err; next symbol,D+Dplus),source+tag+err,
     (tag*LADM[tag]=Parrow,(nxt: is+err;R+Sarrow,D+Dplus,source+tag+err,:nxt;+);
      +).
$ affix form of rule+af1+af2+....
'a'affix form-tag-err:
  is tag+tag,(has formal type+tag,error+wrong rule type+tag,skip all;
         D+tag,0->err,(nxt: R+Splus,(vararg block+tag+err;source or string+tag+err,:nxt);+));
  error+tag expected,skip all.
'a'to selectors+>tag+>err>-sel:
  R+Sarrow,(nxt: is tag+sel,D+Dto,D selector+sel+tag,(R+Sarrow,:nxt;+);
       is+err;
       1->err,error+selector expected,skip all);
  is+err;
  1->err,error+expected+Sarrow.
'a'extension+>tag-err:
  D+Dextension,D tag+tag,
  Rskip+Sasterisk,Rskip+Slstar,Rskip+Ssubstar,0->err,
  (nxt: source+tag+err,to selectors+tag+err,(R+Scomma,:nxt;+)),
  D+Dextension,Rskip+Sasterisk,Rskip+Sclose,Rskip+Sstarbus,Rskip+tag.
'q'looking at a member:
  =inpt=
  [Sopen;                 $ compound member $
   Sasterisk;Slstar;Ssubstar;         $ extension $
   Slwb;Supb;Svlwb;Svupb;Scalibre;    $ limit $
   Scons;TTAG             $ constant; tag
  ],+;
  -.
'a'member-err-tag-simple:
  R+Sopen,(ahead+Slstar,skip over extension+tag+simple+err,
             (is+err; $ error
              is+simple,compound member;
              extension+tag);
           compound member);
  (ahead+Sasterisk;ahead+Slstar;ahead+Ssubstar),skip over extension+tag+#+err,
             (is+err;extension+tag);
  peek after source+tag+err,
             (is+err;
              is+tag,special affix form+tag;
              affix form).
$ after ( check whether the next tag is a label
'a'peek label+label>:
  init restore,0->label,
    (is tag+label,(ahead+Scolon;ahead+Sminus;0->label);+),
    make restore.
'a'skip label+>label:
  is+label,must tag+#,Rskip+Scolon;+.
'a'add local affixes-tag:
  init restore,
   ((R+Sminus,is tag+#),make restore,D+Dlocal,
     (nxt:R+Sminus,(is tag+tag,D+tag,add local affix+tag,:nxt;
              error+tag expected,skip all);
          R+Scolon,D+Dcolon;
          error+expected+Scolon,skip all);
    make restore).
'a'compound member-label-loc: $ we are after ( $
  D+Dopen,
  peek label+label,open new local range+label+loc,
  skip label+label,add local affixes,
  (R+Sbox,classification; alternative series),
  (R+Sclose;error+expected+Sclose,skip all),
  D+Dclose,close local range+loc.
'a'alternative:
   terminator;
   looking at a member,member,(R+Scomma,D+Dcomma,:alternative;+);
   error+member expected.
'a'alternative series:
   alternative,(R+Ssemicolon,D+Dsemicolon,:alternative series;+).
'a'classifier-x-empty:
   0->empty,
   (is tag+x,D tag+x;is cons+x,D cons+x;1->empty),
   (R+Scolon,0->empty,D+Dcolon,(is tag+x,D tag+x;is cons+x,D cons+x;+);+),
   (is+empty,error+wrong zone;+),
   (R+Ssemicolon,D+Dsemicolon,:classifier;
    R+Sbus;
    error+wrong zone).
'a'zone+>err>+last>:
   R+Ssub,0->last,D+Dzone,classifier,D+Dzone,D+Dcomma,
     (R+Scomma;is+err;1->err,error+expected+Scomma),
     alternative;
   1->last,D+Dzone,D+Dcolon,D+Dzone,D+Dcomma,alternative.
$ classification, we are after the box $
'a'classification-err-last:
   D+Dbox,0->err,source+Sbox+err,D+Dbox,(R+Sbox;is+err;error+expected+Sbox),
    (nxt: zone+err+last,(is+last;R+Ssemicolon,D+Dsemicolon,:nxt;+)),
    (is+err,skip all;+).
'a'rule body+>rule tag-loc:
  D+Drule,D+rule tag,
  set up local stack+rule tag+loc, $ formal part and main label
  (ahead+Sminus,add local affixes;
   R+Scolon;
   error+expected+Scolon,skip all),
  (R+Sbox,classification; alternative series),
  D+Dpoint,close local range+loc,
  (R+Spoint; error+expected+Spoint,skip to point).
'a'root-loc:
  is+in module,error+no root in module,skip to point;
  is+root scanned,error+more than one root,skip to point;
  1->root scanned,D+Droot,get tag adm+Proot tag+Xroot tag,
  put type+Xroot tag+Irule, set rule flag+Xroot tag+r pred,
  set rule flag+Xroot tag+r called,
  set up local stack+Xroot tag+loc,add local affixes,
   (R+Sbox,classification;alternative series),
   D+Dpoint,close local range+loc,
   (R+Spoint; error+expected+Spoint,skip to point).
$================================================================$
$ external declarations
'a'external declaration:
  R+Saction,    rule declaration+r action+1;
  R+Sfunction,  rule declaration+r func+1;
  R+Squestion,  rule declaration+r que+1;
  R+Spredicate, rule declaration+r pred+1;
  R+Sexit,      rule declaration+r action+1;
  R+Stable symb,external list declaration+Iext table;
  R+Sstack symb,external list declaration+Iext stack;
  R+Scons symb, external constant declaration;
  R+Svar symb,  external variable declaration;
  R+Sdummy symb,skip to point; $ lexical error
  error+wrong symbol+inpt,skip to point.
$ static declaration
'a'static declaration:
  is+in library,
    (R+Svar symb,  static variable declaration;
     R+Sstack symb,stack declaration+Istatic stack;
     R+Sdummy symb,skip to point;
     error+wrong symbol+inpt,skip to point);
  error+static in library only,skip to point.
$================================================================$
'a'program-err:
  ahead+Send symb;
  R+Sprag symb,program pragmat+err,
                (err=2;
                 err=1,skip to point,:program;
                 :program);
  is+pgmskip,skip silently,R skip+Spoint,:program;
  R+Stable symb,table declaration,:program;
  R+Sstack symb,stack declaration+Istack,:program;
  R+Svar symb,  variable declaration,:program;
  R+Scons symb, constant declaration,:program;
  R+Scharfile,  charfile declaration,:program;
  R+Sdatafile,  datafile declaration,:program;
  R+Saction,    rule declaration+r action+0,:program;
  R+Sfunction,  rule declaration+r func+0,:program;
  R+Squestion,  rule declaration+r que+0,:program;
  R+Spredicate, rule declaration+r pred+0,:program;
  R+Sexit,      rule declaration+r action+0,:program;
  R+Sext symb,  external declaration,:program;
  R+Sroot symb, root,:program;
  $ library rules
  R+Sstatic,    static declaration,:program;
  R+Snot mentioned,skip silently,R skip+Spoint,:program;
  ahead+Sdefined,warning+8+standard tag redefined+inpt value,
         skip silently,R skip+Spoint,:program;
  R+Sused,:program; $ execute this
  R+Sdummy symb,skip to point,:program; $ lexical error
  error+wrong symbol+inpt,skip to point,:program.

$================================================================$
'a'pass I:
  4->warning level,$ default warning level $
  0->error no,     $ no errors
  prelude,read sources,read stdlib,
  postlude I.
  
$ ***********************  PASS II  **************************** $
'variable'
   link macro=0,    $ link macros
   link public=0,   $ public tags
   link fill=0,     $ head of list fill link
   link fill tail=0.$ tail of list fill link
$ reading from DISC file
'variable'Qsymbol=0,Qtype=0,Qposition=0,Qlinenum=0.
$ macro substitution
'stack'[1]QBUFFER.
'variable'Qbuffer ptr=0,Qsave local=0,Qsubstitute=0.
'a'putQ+*+>v:
   extend+QBUFFER+v,(shift vararg block+*,:putQ;+).
'a'read from QBUFFER:
   incr+Qbuffer ptr,QBUFFER[Qbuffer ptr]->Qsymbol,
   (Qsymbol=Dend,0->Qbuffer ptr,next disc symbol;
    Qsymbol=Dconstval,0->Qtype,incr+Qbuffer ptr,QBUFFER[Qbuffer ptr]->Qsymbol;
    1->Qtype).
$ save replaced tag in Qsave local until the first Qtag call
'a'substitute formals:
   was+LLOC+Qsymbol,add+Qsymbol+Qsubstitute+Qsymbol,
     (is local flag+Qsymbol+Lsubstitute,Qsymbol->Qsave local,
            repr*LLOC[Qsymbol]->Qbuffer ptr,read from QBUFFER;
      +);
   +.
'a'next disc symbol:
  is+Qbuffer ptr,0->Qsave local,read from QBUFFER;
  get file pos+DISC+Qposition,linenum->Qlinenum,
  (get data+DISC+Qsymbol+Qtype,
   ((Qsymbol=Dline,Qtype=1),incr+linenum,:next disc symbol;
    (Qsymbol=Dinput,Qtype=1),d reset pragmats,:next disc symbol;
    (is+Qsubstitute,Qtype=1),substitute formals;
    +);
   Dend->Qsymbol,1->Qtype).
$ save position and line number to be restored later
'f'save disc position+pos>+lnum>:
  is+Qbuffer ptr,error+internal error,'exit'5;
  Qposition->pos,Qlinenum->lnum.
'a'restore disc position+>pos+>lnum:
  set file pos+DISC+pos,lnum->linenum,next disc symbol.

'p'Q+>x: (x=Qsymbol,Qtype=1),next disc symbol.
'q'Qahead+>x: is+Qtype,x=Qsymbol.
'a'must Q+>x:Q+x;error+internal error,'exit'3.
'p'Q cons+x>:
  Qtype=0,Qsymbol->x,next disc symbol.
'a'must Qcons+x>:
  is+Qtype,error+internal error,'exit' 3;
  Qsymbol->x,next disc symbol.
'p'Qtag+x>:
  is+Qtype,(=Qsymbol=
    [LADM;LLOC],Qsymbol->x,next disc symbol;
    -).
'a'must Qtag+x>:
  Qtag+x;
  error+internal error,'exit'3.
$ table/stack in macro replacement:
$   if local is defined, use local calibre and ssel
$ they should come in this order as Qtag distroys Qsave local
$'p'Qlist+tag>+local>:
$  Qsave local->local,Qtag+tag.
'a'must Qlist+tag>+local>:
  Qsave local->local,must Qtag+tag.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'prelude II:
  0->link macro->link public,0->link fill->link fill tail,
  default warning level->warning level,0->in library,
  open disc+/r/,0->Qsymbol->Qtype->Qbuffer ptr->Qsubstitute,
  0->linenum,next disc symbol.
$================================================================$
$ zone sequences
'table'MESSAGE=(
 "tag %p in the zone must be constant%*"      :wrong zone type,
 "list tag %p in zone is followed by a colon" :wrong zone upb,
 "in zone lower bound=%d is bigger than upper bound=%d" :zone wrong limits
).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -$
$ a zone is the disjoint UNION_i [a_i,b_i]   (from [min int,max int] )
$ it is stored as a linked list of (lw,up,next)
$ the head's [a_0,b_0] values are ignored.
'stack'[1](lb,up,next)ZONE.
'a'create empty zone+zone>:
  (*0->lb->up->next*)ZONE,>>ZONE->zone.

$ first element in set is [a_i,b_i] where b_i<=up. 
$ merge subsequent elements until up.
'a'find interval pair+>set+>up-ni:
   up<=up*ZONE[set];
   next*ZONE[set]->ni,up->up*ZONE[set],(nxt:
     ni=0,0->next*ZONE[set];
     up<lb*ZONE[ni],ni->next*ZONE[set];
     up<=up*ZONE[ni],up*ZONE[ni]->up*ZONE[set],next*ZONE[ni]->next*ZONE[set];
     next*ZONE[ni]->ni,:nxt).
$ add interval +>set + [lb,up] + >new>
$  new is 1 if [lb,up] is not contained in the interval set "set"
$ call "merge intervals+>set" after "add interval"
'a'add interval+>set+>lb+>up+>new>-ni:
  next*ZONE[set]->ni,
   (ni=0,1->new,(*lb->lb,up->up,0->next*) ZONE,
             >>ZONE->next*ZONE[set];
    lb<lb*ZONE[ni],1->new, $start before
      (up<lb*ZONE[ni],(*lb->lb,up->up,ni->next*)ZONE,
             >>ZONE->next*ZONE[set];
       lb->lb*ZONE[ni],find interval pair+ni+up);
    lb<=up*ZONE[ni], $start inside, keep old starting point
      (up<=up*ZONE[ni]; $ not new
       1->new,find interval pair+ni+up);
    ni->set,:add interval).
'f'shrink interval+>set+>lb>+>up>+new>:
   next*ZONE[set]->set,1->new,
   (nxt:set=0,(up>=lb;0->new);
    ((lb*ZONE[set]<=lb,lb<=up*ZONE[set]),up*ZONE[set]->lb,
       (lb=max int,0->new;incr+lb);+),
    ((lb*ZONE[set]<=up,up<=up*ZONE[set]),lb*ZONE[set]->up,
       (up=min int,0->new;decr+up);+),
    next*ZONE[set]->set,:nxt).
'a'merge intervals+>set-ni: $ merge [a,b],[b+1,c]
   next*ZONE[set]=0;
   next*ZONE[set]->set,next*ZONE[set]->ni,
     (nxt:(ni!=0,diff1+up*ZONE[set]+lb*ZONE[ni]),
           up*ZONE[ni]->up*ZONE[set],
           next*ZONE[ni]->next*ZONE[set]->ni,:nxt;
      :merge intervals).
'q'diff1+>x+>y-z: subtr+y+x+z,z=1.
'f'incomplete zone+>set+incomp>:
  1->incomp,next*ZONE[set]->set,
  (set=0; lb*ZONE[set]!=min int; up*ZONE[set]!=maxint; 0->incomp).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -$
'a'zone interval+lb>+ub>+>err>-tag-type:
  0->lb->ub->tag,Iconstant->type,
  (is+err,(Qcons+#;Qtag+#;+);
   Qcons+lb;
   Qtag+tag,get type+tag+type,
     (=type=
      [Iconstant], get repr+tag+lb,lb->ub;
      [Ipointer constant],strict pointer+tag+lb,lb->ub,Iconstant->type;
      [Itable;Istack;Istatic stack],get vlwb+tag+lb,get vupb+tag+ub;
      1->err,error+wrong zone type+tag+type);
   min int->lb),
  (Q+Dcolon,
      (is+err,(Qcons+#;Qtag+#;+);
       type=Iconstant,
         (Q cons+ub;
          Qtag+tag,get type+tag+type,(=type=
             [Iconstant],get repr+tag+ub;
             [Ipointer constant],strict pointer+tag+ub;
             1->err,error+wrong zone type+tag+type);
          max int->ub);
       1->err,error+wrong zone upb+tag,(Qcons+#;Qtag+#;+));
   lb->ub),
  (is+err;
   lb<=ub;
   1->err,error+zone wrong limits+lb+ub).
'a'create zone+set>+err>-oldzone-lb-up-new:
  >>ZONE->oldzone,(*0->lb->up->next*)ZONE,>>ZONE->set,
  0->err,0->new,
  (nxt: zone interval+lb+up+err,(is+err;add interval+set+lb+up+new),
        (Q+Dsemicolon,:nxt;+)),
  (is+err,unstack to+ZONE+oldzone,0->set;merge intervals+set).

$ it could happen that the result is [min int,max int]
$ new=1 if something has been added to "first"
$ first is modified to be the merged system
'a'merge zones+>first+>second+new>:
  0->new,(second=0;
   (nxt: next*ZONE[second]->second,
     (second=0;
      add interval+first+lb*ZONE[second]+up*ZONE[second]+new,:nxt))).
$================================================================$
'table'MESSAGE=(
 "out formal affix %p not set"               :vararg out formal not set,
 "selector %p is undefined"                  :undefined selector,
 "constant as destination or index"          :constant as index,
 "tag %p has wrong type (%p)"                :wrong tag type,
 "rule %p: wrong # affix type (position %d)" :rule dummy affix,
 "rule %p: constant as destination or index (position %d)"  :rule constant as index,
 "rule %p: affix error (position %d)"        :rule affix error,
 "rule %p: affix %p (position %d) has wrong type %p":rule type error,
 "extension %p: constant as index (position %d)":stack constant as index,
 "extension %p: tag %p (position %d) has wrong type %p":stack type error,
 "extension %p: field %d doubly filled"      :transport dbly filled,
 "affix %p uninitialized"                    :affix uninitialized error,
 "rule %p: affix %p (position %d) uninitialized":rule affix uninitialized,
 "rule %p: out formal affix %p uninitialized" :out formal not set,
 "extension %p: tag %p (position %d) uninitialized":stack affix uninitialized,
 "macro %p: cannot modify formal affix %p (position %d)":cannot modify read only affix,
 "rule %p: vararg number mismatch"           :vararg number mismatch,
 "rule %p: vararg type mismatch for %p (required: %p, given: %p)"
                                             :vararg type mismatch,
 "rule %p: additional actual affixes"        :additional affixes,
 "macro %p: cannot call itself"              :recursive macro rule,
 "macro %p: cannot call ""shift vararg block""":macro cannot call varargs,
 "rule %p: undefined"                        :undefined rule,
 "rule %p: missing actual affixes"           :missing affixes,
 "stack %p: wrong extension block"           :wrong extension block,
 "extension: tag %p must be a stack (%p)"    :stack type expected,
 "cannot reach this alternative"             :cannot reach this alternative,
 "cannot reach this member"                  :cannot reach this member,
 "wrong jump to label %p"                    :wrong jump,
 "cannot reach this zone"                    :cannot reach this zone,
 "rule %p: can fail"                         :rule can fail,
 "rule %p: cannot fail"                      :rule cannot fail,
 "rule %p: has global side effect"           :rule has global side effect,
 "rule %p: does not handle variable args"    :no shiftargs called,
$ warnings
 "%*constant tag %p (position %d) maybe wrong index":maybe wrong index,
 "classification may fail"              :classification may fail,
 "local affix or label %p not used"     :local var or label not used,
 "rule %p: cannot succeed"              :rule cannot succeed,
 "rule %p: has no global side effect"   :rule has no side effect,
 "rule %p: can have global side effect when fails" :fail and rule side effect,
 "rule %p: local or formal affix %p not used"   :local or formal var not used,
 "rule %p: formal stack affix %p not set, can be a table":stack formal not set,
 "rule %p: formal affix %p might change on true exit":formal might change on true,
 "rule %p: formal affix %p does not change"     :formal does not change,
 "rule %p: formal affix %p might change on false exit" :formal might change on false
).
$ formal, local variables in LLOC:
$   flags:   has value,
$            used
'constant' $ formal/local affixes $
  Lmentioned=1,           $ set when the affix mentioned $
  LTset=2,                $ has value when leaving rule with true $
    LTsetMask=~LTset,
  LFset=4,                $ has value when leaving rule with false $
    LFsetMask=~LFset,
  LTmod=8,
    LTmodMask=~LTmod,
  LFmod=0x10,
    LFmodMask=~LFmod,
  Lsubstitute=0x80,       $ substitute for macros
  Lvararg=0x100.          $ formal after a variable argument $
'q'is local flag+>loc+>flag-x:
  was+LLOC+loc,bool and+flag*LLOC[loc]+flag+x,x!=0.
'a'set local flag+>loc+>flag:
  bool or+flag*LLOC[loc]+flag+flag*LLOC[loc].
'a'clear local flag+>loc+>mask:
  bool and+flag*LLOC[loc]+mask+flag*LLOC[loc].
'a'mark formal as used+>tag:
  was+LLOC+tag,set local flag+tag+Lmentioned;+.
$ copy flags LTset/LTmod to LFset/LFmod
'a'copy local Tflag to F-ptr:
  >>LLOC->ptr,(nxt:ptr<<<LLOC;
    (is local flag+ptr+LTset,set local flag+ptr+LFset;
     clear local flag+ptr+LFsetMask),
    (is local flag+ptr+LTmod,set local flag+ptr+LFmod;
     clear local flag+ptr+LFmodMask),
       previous+LLOC+ptr,:nxt).
$ shift vararg block called; reset all flags for formal vararg variables
$ LTset is true when all hidden affixes are set
$ complain if a formal out is not set
'a'reset varargs-ptr:
  <<LLOC->ptr,(nxt:ptr>>>LLOC;
   type*LLOC[ptr]=Ilabel; $ this is rule as the label; end of arguments
          $ all formal out has been set by passing all varargs
   type*LLOC[ptr]=Iformal repeat,set local flag+ptr+LFset,
       (is local flag+ptr+LTset;next+LLOC+ptr,:nxt);
   ((is local flag+ptr+Lvararg,type*LLOC[ptr]=Iformal out),
       (is local flag+ptr+LTset;
        error+vararg out formal not set+tag*LLOC[ptr]),
       clear local flag+ptr+LTsetMask;+),
   next+LLOC+ptr,:nxt).

'p'Mtag+x>: $mark x as used
  Qtag+x,mark formal as used+x.
'a'must Mtag+x>:
  must Qtag+x,mark formal as used+x.

$ the rule command flow is stored in the RULE stack
'stack'[1](type,flag,data)RULE.

'table'RULE type=(
  0:Urule,                $ data: LADM[rule]
  $ affixes; interesting when the actual affix is formal/local
  $    Uin/Uout/Uinot:    data: link to LLOC[] (formal in,out,inout;local)
  $    Urepeat:           no corresponding actual affix
  $    Uaffix:            all other combinations (e.g, formal in, local stack,
  $                       a*b[<cons pointer>], etc. )
  0:Uout,0:Uinout,0:Uin,  $ data: link to LLOC[], readonly: >=Uin
  0:Uslicein,0:Usliceout,0:Usliceinout,
$  0:Uaffix,
  0:Urepeat,              $ data: number of iterations (>=1)
$  0:Ushift,

  0:Ustore,               $ store formal/local "set" attributes
                          $   should be skipped
  0:Usemicolon,
  $ extension, inside extension for selectors
  0:Uextension,          $ data: stack (link to LADM/LLOC)
  0:Uexto,               $ data: 0/ or link to LLOC; flag=0/1 (1 for filled)
                         $  <>STACK many entries follow,

  $ where continue when t or f; terminators; comes just after Urule
  0:Ufcont,0:Utcont,
  0:U plus,0:U minus,
  0:Uexit,
  0:Ulabel,              $ data: link to LADM (label text)
  0:Ujump,               $ data: link to RULE with Ulabel
  $ compound
  0:Uopen,0:Uclose,

  0:Ubox,                $ data: 0/previous label
  0:Uendbox,             $ end of classification
  0:Uzone,               $ zone
  0:Uempty zone,         $ empty zone (only Utcont follows)
  0:UTexit,              $ rule T/F exit
  0:UFexit,
  0:Uend                 $ not used
).

$ flags for Ustore
'constant'UnoTset=1,      $ not set on TRUE exit
          UnoFset=2,      $ not set on FALSE exit
          UTmod=4,        $ might be modified on TRUE exit
          UFmod=8,        $ might be modified on FALSE exit
          UETset=0x10,    $ Tset when entering
          UETmod=0x20,    $ Tmod when entering
          Ualtset=0x40,   $ Tset on head of next alternative
          Ualtmod=0x80,   $ Tmod on head of next alternative 
            Uealtset=(UETset|Ualtset),
            Uealtmod=(UETmod|Ualtmod|UTmod),
          UtailFset=0x100,$ alt tail false exit
          UtailFmod=0x200,$ alt tail false modified
            UtailBits=(UtailFset|UtailFmod),
          Uredo=0x2000.   $ redo the region

$==================================================================$
'a'push RULE+>type+>data: 
  (* type->type,0->flag,data->data*)RULE.
'a'pushf RULE+>type+>data+>flag:
  (* type->type,flag->flag,data->data*)RULE.
'a'set RULE flag+>ptr+>flag:
  bool or+flag*RULE[ptr]+flag+flag*RULE[ptr].
'q'is RULE flag+>ptr+>flag-x:
  bool and+flag*RULE[ptr]+flag+x,x!=0.
'a'clear RULE flag+>ptr+>flag-mask:
  bool invert+flag+mask,bool and+flag*RULE[ptr]+mask+flag*RULE[ptr].
$ =============================================================== $
$ check data flow for a rule body

$ called after the locals are pushed to LLOC. Original
$ values of modT for the block; LTset/LTmod for formals
$ are stored as <Ustore,0/LLOC,flags>
'a'd start region+>modT-ptr:
   <<LLOC->ptr,push RULE+Ustore+0, $ border $
   (is+modT,set RULE flag+>>RULE+UETmod;+),
   (nxt: >>LLOC < ptr;
     (type*LLOC[ptr]=Ilabel;
      push RULE+Ustore+ptr,
        $ save how they entered the region; set up first alt
        (is local flag+ptr+LTset,set RULE flag+>>RULE+Uealtset;+),
        (is local flag+ptr+LTmod,set RULE flag+>>RULE+Uealtmod;+)),
     next+LLOC+ptr,:nxt).
$ recompute Ustore flags, reset LTset/LTmod for formal/local
'a'recompute RULE flags+>ptr-set-mod-loc:
   (is RULE flag+ptr+UETset,1->set;0->set),
   (is RULE flag+ptr+UETmod,1->mod;0->mod),
   0->flag*RULE[ptr],data*RULE[ptr]->loc,
   (is+set,set RULE flag+ptr+Uealtset,set local flag+loc+LTset;
          clear local flag+loc+LTsetMask),
   (is+mod,set RULE flag+ptr+Uealtmod,set local flag+loc+LTmod;
          clear local flag+loc+LTmodMask).
$ labels come just after the region head
'a'd add label+>label:
   is+label,push RULE+Ulabel+tag*LLOC[label],>>RULE->repr*LLOC[label];
   +.
$ check if original modT, LTset/LTmod flags has changed
'p'd redo region+>optr+modT>-ptr:
  optr->ptr,
  (nxt: data*RULE[ptr]=0;previous+RULE+ptr,:nxt),
  is RULE flag+ptr+Uredo,
    (is RULE flag+ptr+UETmod,1->modT,UETmod->flag*RULE[ptr];
     0->modT->flag*RULE[ptr]),
    (nxt: optr<=ptr; next+RULE+ptr,recompute RULE flags+ptr,:nxt).
$ setup jump mod flags, ptr> is the end of region
'a'setup rule jump mod+>modT+>ptr-loc-redo:
   0->redo,(nxt: data*RULE[ptr]->loc,
   (loc=0,$ this comes at the end
          (is RULE flag+ptr+UETmod; 
           is+modT,set RULE flag+ptr+UETmod,1->redo;+),
          (is+redo,set RULE flag+ptr+Uredo;+);
    (is local flag+loc+LTmod, $ LTmod might increase
          (is RULE flag+ptr+UETmod;
           set RULE flag+ptr+UETmod,1->redo);+),
    (is local flag+loc+LTset; $ LTset might decrease
     is RULE flag+ptr+UETset,clear RULE flag+ptr+UETset,1->redo;+),
     previous+RULE+ptr,:nxt)).
$ at the beginning of an alternative, reset LTset and LTmod flags for all
$   locals in LLOC
'a'setup rule alt head+>ptr-lloc:
  data*RULE[ptr]->lloc,
  (lloc=0;
   (is RULE flag+ptr+Ualtset,set local flag+lloc+LTset;
    clear local flag+lloc+LTsetMask),
   (is RULE flag+ptr+Ualtmod,set local flag+lloc+LTmod;
    clear local flag+lloc+LTmodMask),
   previous+RULE+ptr,:setup rule alt head).
$ after the first member in the alternative update Ualtset and Ualtmod
'a'save rule alt head+>ptr:
   data*RULE[ptr]=0;
   (is local flag+data*RULE[ptr]+LFset,set RULE flag+ptr+Ualtset;+),
   (is local flag+data*RULE[ptr]+LFmod,set RULE flag+ptr+Ualtmod;+),
   previous+RULE+ptr,:save rule alt head.
$ at the end of an alternative series, use the UTset/UFset/UTmod/UTmod
$  save flags to set the LTset/LTset/LTmod/LFmod flags in LLOC.
$ Observe: UnoTset is set if the var is *not* set at the end of one
$  of the alternatives.
'a'setup rule alt sequence+>ptr-lloc:
   data*RULE[ptr]->lloc,
   (lloc=0;
     (is RULE flag+ptr+UnoTset,clear local flag+lloc+LTsetMask;
           set local flag+lloc+LTset),
     (is RULE flag+ptr+UnoFset,clear local flag+lloc+LFsetMask;
           set local flag+lloc+LFset),
     (is RULE flag+ptr+UTmod,set local flag+lloc+LTmod;
           clear local flag+lloc+LTmodMask),
     (is RULE flag+ptr+UFmod,set local flag+lloc+LFmod;
           clear local flag+lloc+LFmodMask),
     previous+RULE+ptr,:setup rule alt sequence).
$ at the end of an alternative collect saved flags: 
$ Tset and Fset are AND-ed (must be set at all exit);
$ Tmod and Fmod are OR-ed (can be set at any exit)
'a'save rule alt sequence+>ptr+>tf+>ff-lloc:
   data*RULE[ptr]->lloc,(lloc=0;
     (is+tf,(is local flag+lloc+LTset;set RULE flag+ptr+UnoTset),
            (is local flag+lloc+LTmod,set RULE flag+ptr+UTmod;+);+),
     (is+ff,(is local flag+lloc+LFset;set RULE flag+ptr+UnoFset),
            (is local flag+lloc+LFmod,set RULE flag+ptr+UFmod;+);+),
   previous+RULE+ptr,:save rule alt sequence).
$ clear UtailFset and UtailFmod bits; called just after the first member
$   in an alternative
'a'clear rule tail Fbits+>ptr:
   type*RULE[ptr]!=Ustore,error+internal error,'exit'3;
   data*RULE[ptr]=0;
   clear RULE flag+ptr+UtailBits,previous+RULE+ptr,:clear rule tail Fbits.
$ indicate LFset and LFmod bits when a member fails
$  LFset is on when all false exit sets it;
$  LFmod is on when some false exit sets it
'a'update rule tail Fbits+>ptr:
   type*RULE[ptr]!=Ustore,error+internal error,'exit'3;
   data*RULE[ptr]=0;
   (is local flag+data*RULE[ptr]+LFset; $ it has set
    set RULE flag+ptr+UtailFset),       $ it was not
   (is local flag+data*RULE[ptr]+LFmod,
     set RULE flag+ptr+UtailFmod;+),
   previous+RULE+ptr,:update rule tail Fbits.
'a'setup rule tail Fbits+>ptr-lloc:
   data*RULE[ptr]->lloc,(lloc=0;
     (is RULE flag+ptr+UtailFset,clear local flag+lloc+LFsetMask;
         set local flag+lloc+LFset),
     (is RULE flag+ptr+UtailFmod,set local flag+lloc+LFmod;
         clear local flag+lloc+LFmodMask),
     previous+RULE+ptr,:setup rule tail Fbits).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ tag: formal out/local
$ utype: Uin,Uout,Uinout,Uslicein,Usliceout,Usliceinout
$ tag type is formal in/out/inout/local
$ if utype!=Uout LTset must be set;
$ if utype=Uout: set LTset true
'q'u read only+>utype: utype>=Uin.
'f'utype to slice+>utype+type>:
   =utype= [Uin],Uslicein->type;
           [Uout],Usliceout->type;
           [Uinout],Usliceinout->type;
           utype->type.
'a'check and set local flag+>utype+>tag+err>:
  utype=Uout,0->err,set local flag+tag+LTset;
  is local flag+tag+LTset,0->err;
  1->err.
$------------------------------------------------------------------------$
'a'd set formal affix+>flag>:
  (is+flag,set local flag+>>LLOC+Lvararg;+),
  (=type*LLOC=
  [Iformal stack;Iformal table],
     must Qcons+calibre*LLOC,must Qcons+ssel*LLOC;
  [Iformal repeat], 1->flag,clear local flag+>>LLOC+LTsetMask;
  [Iformal out],clear local flag+>>LLOC+LTsetMask;
  +).
'a'd setup formal stack+>rtag-formal-flag:
  scratch+LLOC,
  0->flag,get adm+rtag+formal,
  (nxt: formal=0;
    (* LTset->flag,0->repr,type*LADM[formal]->type,formal->tag,0->calibre->ssel *)LLOC,
    d set formal affix+flag, get adm+formal+formal,:nxt).
$ add a label to LLOC
'a'd setup label+label>:
  Q+Dlabel,must Qtag+label,
    (*0->repr,Ilabel->type,label->tag,0->flag->orepr->otype*)LLOC,
    >>LLOC->label;
  0->label.
$ read local definitions and add them to LLOC
'a'd setup locals-local:
  Q+Dlocal,(nxt: Q+Dcolon;
    must Qtag+local,
    (*0->flag,d compound level->repr,Ilocal->type,
              local->tag,0->orepr->otype*)LLOC,
    :nxt);
  +.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ actual rule $
'q'has list type+>tag-type:
  get type+tag+type,(=type=
   [Itable;Istack;Iformal table;Iformal stack;
    Iext table;Iext stack;Istatic stack],+;-).
'a'd check ssel+>tag-x:
  has list type+tag,get ssel+tag+x,
     (x>0;error+undefined selector+tag);
  +.
'a'd read selector+x>-tag:
  Q cons+x; $ this is the selector
  must Qtag+tag,get repr+tag+x,
     (x>0;error+undefined selector+tag).
'a'd mark list+>tag-type:
  get type+tag+type,(=type=
   [Itable;Istack;Iext table;Iext stack;Istatic stack],put flag+tag+1;
   +).
'a'dskip over source:
   Q cons+#;
   (Q+Dlwb;Q+Dupb;Q+Dvlwb;Q+Dvupb;Q+Dcalibre),must Qtag+#;
   Q+Dsub,dskip over source,must Q+Dbus,must Qtag+#,(Qtag+#;must Qcons+#);
   Q+Dnoarg;
   must Qtag+#.
'a'dskip over affixes:
   Q+Dplus,dskip over source,:dskip over affixes;
   +.
$-------------------------------------------------------------------$
$  rtag: rule; stack (extension), 0 box/exit
$  cnt: affix number, or field
$  atag: actual affix (tag, or 0--missing or wrong affix); 
'a'affix type error+>rtag+>cnt+>atag-type-atype:
   rtag=0,$ classification,exit cnt=0 $
      (atag<=0,error+constant as index;
       get type+atag+atype,error+wrong tag type+atag+atype);
   get type+rtag+type,
     (type=Irule,(
         atag=-2,error+rule dummy affix+rtag+cnt;
         atag=-1,error+rule constant as index+rtag+cnt;
         atag=0,error+rule affix error+rtag+cnt;
         get type+atag+atype,error+rule type error+rtag+atag+cnt+atype);
      atag<=0,error+stack constant as index+rtag+cnt;
      get type+atag+atype,error+stack type error+rtag+atag+cnt+atype).
'a'affix uninitialized+>rtag+>cnt+>atag:
   rtag=0,error+affix uninitialized error+atag;
   (-type:get type+rtag+type,type=Irule),
        error+rule affix uninitialized+rtag+atag+cnt;
   error+stack affix uninitialized+rtag+atag+cnt.
$-------------------------------------------------------------------$
$ formal: file, actual: file
'a'd ffile affix+>rtag+>cnt-atag-type:
  Mtag+atag,get type+atag+type,(=type=
      [Iformal file;Ichar file;Idata file],+;
      affix type error+rtag+cnt+atag);
  affix type error+rtag+cnt+0,dskip over source.
$ formal: table, actual: formal/global table or stack
'a'd ftable affix+>tag+>cnt-atag:
  Mtag+atag,(has list type+atag,d mark list+atag;
     affix type error+tag+cnt+atag);
  affix type error+tag+cnt+0,dskip over source.
$ formal stack: actual: formal/global stack
'a'd fstack affix+>tag+>cnt-atag-type:
  Mtag+atag,d mark list+atag,get type+atag+type,(=type=
    [Istatic stack],
         (is+in library;affix type error+tag+cnt+atag);
    [Istack;Iext stack],+;
    [Iformal stack],set local flag+atag+LTmod;
    affix type error+tag+cnt+atag);
  affix type error+tag+cnt+0,dskip over source.
$ formal shift affix: actual must be formal repeat
'a'd fshift affix+>tag+>cnt-atag-type:
  Mtag+atag,get type+atag+type,
    (type=Iformal repeat;affix type error+tag+cnt+atag);
  affix type error+tag+cnt+0,dskip over source.
$ utype: Uin,Uout,Uinout,Uslicein,Usliceout,Usliceinout
$   tag: <rule tag>,<stack (formal/global for extension)>, 0 (box)
$ o sets local/formal flags LTset and LTmod
$ mod: 0/1 for global side effect
'a'd fsimple affix+>tag+>cnt+>utype+mod>-atag-type-err:
  0->mod,(
  Q cons+#,(utype=Uin;affix type error+tag+cnt+-1);
  (Q+Dvlwb;Q+Dvupb;Q+Dlwb;Q+Dupb),must Mtag+atag,
      (has list type+atag;
       get type+atag+type,error+must be of list type+atag+type),
      (u read only+utype;affix type error+tag+cnt+atag);
  Q+Dcalibre,must Mtag+atag,
      (has list type+atag;
       get type+atag+type,error+must be of list type+atag+type),
      (utype=Uin;affix type error+tag+cnt+atag);
  Q+Dsub,utype to slice+utype+type,
      d fsimple affix+tag+cnt+type+#,must Q+Dbus,must Mtag+atag,
      d read selector+#,get type+atag+type,(back:=type=
        [Istatic stack],(is+in library,Istack->type,:back;
                         Itable->type,:back);
        [Itable;Iformal table;Iext table],d mark list+atag,(u read only+utype;
              affix type error+tag+cnt+atag);
        [Istack;Iext stack],d mark list+atag,(u read only+utype;1->mod);
        [Iformal stack],(u read only+utype;1->mod,set local flag+atag+LTmod);
        error+must be of list type+atag+type);
  Q+Dnoarg,(utype=Uout;affix type error+tag+cnt+-2);
  must Mtag+atag,get type+atag+type,(back:=type=
      [Istatic var],(is+in library,Ivariable->type,:back;
                    Iconstant->type,:back);
      [Istatic stack],(is+in library,Istack->type,:back;
                    Itable->type,:back);
      [Itable;Iformal table;Iext table],d check ssel+atag,d mark list+atag,
            (u read only+utype;affix type error+tag+cnt+atag);
      [Istack;Iext stack],d check ssel+atag,d mark list+atag,
            (u read only+utype;1->mod);
      [Iformal stack],d check ssel+atag,
            (u read only+utype;1->mod,set local flag+atag+LTmod);
      [Iconstant;Iext cons],(utype=Uin;
            u read only+utype,warning+2+maybe wrong index+tag+atag+cnt;
            affix type error+tag+cnt+atag);
      [Ipointer constant],(u read only+utype;
            affix type error+tag+cnt+atag);
      [Ivariable;Iext var],(u read only+utype;1->mod);
      [Iformal in],(u read only+utype;
            set local flag+atag+LTmod,
             (is rule flag+d rule compiled+r macro,
               error+cannot modify read only affix+tag+atag+cnt;+));
      [Iformal inout],
           (u read only+utype;set local flag+atag+LTmod);
      [Iformal out;Ilocal],
           check and set local flag+utype+atag+err,
           (u read only+utype;type=Ilocal;set local flag+atag+LTmod),
           (is+err,affix uninitialized+tag+cnt+atag;+);
      affix type error+tag+cnt+atag)
  ).
$ sets LTset and LTmod flags for formal/local variables
$ mod: side effect level of this affix
'a'd match formal actual+>tag+>cnt+>ftype+mod>:
  =ftype= $ this is the formal's type $
  [Iformal file],  d ffile affix+tag+cnt,0->mod;
  [Iformal table], d ftable affix+tag+cnt,0->mod;
  [Iformal stack], d fstack affix+tag+cnt,1->mod;
  [Iformal shift], d fshift affix+tag+cnt,0->mod;
  [Iformal in],    d fsimple affix+tag+cnt+Uin+mod;
  [Iformal out],   d fsimple affix+tag+cnt+Uout+mod;
  [Iformal inout], d fsimple affix+tag+cnt+Uinout+mod;
  error+internal error,'exit'3.
$------------------------------------------------------$
$ actual: after Iformal repeat in rule just compiled;
$ formal: formal affix in rtag to be called
'q'd compatible types+>provide+>require:
  provide=require;
  (=require=
  [Iformal table],provide=Iformal stack;
  [Iformal in],provide=Iformal inout;
  [Iformal inout],provide=Iformal in;
  -).
$ compute global modT flag;
$ also set local flags LTset, LTmod whenever appropriate.
'a'd match varargs+>rtag+>actual+>formal+>modT>-type-ftype:
  get adm+formal+formal,next+LLOC+actual,get type+actual+type,
  (formal=0,(type=Ilabel;error+vararg number mismatch+rtag);
   type=Ilabel,error+vararg number mismatch+rtag;
   get type+formal+ftype,
     (d compatible types+type+ftype,set local flag+actual+Lmentioned,
        $  set local flags LTset,LTmod; update modT
        (ftype=Iformal stack,1->modT,set local flag+actual+LTmod;
         ftype=Iformal out,set local flag+actual+LTset,
                           set local flag+actual+LTmod;
         ftype=Iformal inout,set local flag+actual+LTmod;
        +),:d match varargs;
      error+vararg type mismatch+rtag+actual+type+ftype)).
$ pass all formal varargs to a rule
'p'd pass varargs+>rtag+>fml+>modT>-dpos-dline-tag-type:
  save disc position+dpos+dline,
   ((Q+Dplus,Qtag+tag,get type+tag+type,type=Iformal repeat),
      set local flag+tag+Lmentioned,set local flag+tag+LTset,
         $ LTset indicates that all out varargs are set
      (Qahead+Dplus,error+additional affixes+rtag,dskip over affixes;
       d match varargs+rtag+tag+fml+modT);
    restore disc position+dpos+dline,-).
'a'd check macro rule+>rtag:
    is rule flag+d rule compiled+r macro,
      (rtag=d rule compiled,error+recursive macro rule+rtag;
       rtag=Xshift varargs,error+macro cannot call varargs+rtag;
       +);
    +.
$--------------------------------------------------------------$
$ canF: rule can fail
$ modT: rule has side effect when true
$ if rule is "shift vararg block", call "reset varargs"
'a'd actual rule+canF>+>modT>
  -rtag-type-formal-repeat-cnt-lmod:
  must Qtag+rtag,get type+rtag+type,1->canF,
   (type!=Irule,error+undefined rule+rtag,dskip over affixes;
     d check macro rule+rtag,
     (rtag=d rule compiled;set rule flag+rtag+r called),
     (rtag=Xshift varargs,reset varargs;+),
     (is rule flag+rtag+r can fail;0->canF),
     (is rule flag+rtag+r side effect,1->modT;+),
     get adm+rtag+formal,0->repeat,1->cnt,
     (nxt: formal=0,
             (Qahead+Dplus,
                (repeat=0,error+additional affixes+rtag,dskip over affixes;
                 d pass varargs+rtag+repeat+modT;
                 get adm+repeat+formal,:nxt);
              +);
           get type+formal+type,
            (type=Iformal repeat, $ no actual instance $
                  (d pass varargs+rtag+formal+modT;
                   formal->repeat,get adm+formal+formal,:nxt);
             Q+Dplus,d match formal actual+rtag+cnt+type+lmod,
                  (is+lmod,1->modT;+),
                  incr+cnt,get adm+formal+formal,:nxt;
             error+missing affixes+rtag))
   ).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ extension $
'a'd skip extension:
  Q+Dextension;Qahead+Dend;next disc symbol,:d skip extension.
'a'd transport dest+>tag+>cal+>cnt-x-ptr:
  Q+Dto,d read selector+x, $ x=1,2,...,cal
    (x<=0;
     cal<x,error+internal error,'exit' 3;
     decr+x,mult+x+<>RULE+x,subtr+>>RULE+x+ptr,
       (flag*RULE[ptr]=0;error+transport dbly filled+tag+cnt),
       1->flag*RULE[ptr]),
    :d transport dest;
  +.
'a'd check extension block+>tag+>cal-ptr-cnt: $ Uexto, 0/1, 0/loc/fml
  mult+cal+<>RULE+cnt,subtr+>>RULE+cnt+ptr,next+RULE+ptr,1->cnt,
  (flag*RULE[ptr]!=0;error+wrong extension block+tag),
  (nxt:cal<cnt;flag*RULE[ptr]=0;next+RULE+ptr,incr+cnt,:nxt),
  (nxt:cal<cnt;flag*RULE[ptr]=0,next+RULE+ptr,incr+cnt,:nxt;+),
  (cal<cnt;error+wrong extension block+tag).
'a'd transport+>tag+>cal-rptr-cnt:
  >>RULE->rptr,cal->cnt,(nxt: push RULE+Uexto+0,decr+cnt,(cnt>0,:nxt;+)),
  1->cnt,(nxt:
      d fsimple affix+tag+cnt+Uin+#,d transport dest+tag+cal+cnt,
        incr+cnt,(Qahead+Dend;Q+Dextension;:nxt)),
  d check extension block+tag+cal,
  unstack to+RULE+rptr.
'a'd extension-tag-type-calibre:
  must Mtag+tag,get type+tag+type,(=type=
   [Istack;Iformal stack],get calibre+tag+calibre,
         d transport+tag+calibre,
         (type=Istack;set local flag+tag+LTmod);
   error+stack type expected+tag+type,d skip extension).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ box and zone $
'a'd read box: $ after Q+Dbox $
   d fsimple affix+0+0+Uin+#,mustQ+Dbox.
'a'd read zone+zone>: $after Q+Dzone
   create zone+zone+#,mustQ+Dzone.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ on exit from a member: 
$ canT>, canF> 0/1 can be true, can be false
$ modT>, modF> 0/1 are the side effect for true, false exit
$ jmplevel>: the very first label in RULE to which the member jumps, or 0.
$    check for no continuation when there is a jump (tail
$    recursion only).
$ for each local/formal variable: 
$    Lmentioned: variable mentioned  >*>   (cumulative)
$    LTset: set on true exit,        >*>   (only if canT)
$    LFset: set on false exit         *>   (only if canF)
$    LTmod: modified on true exit    >*>   (only if canT)
$    LFmod: modified on false exit    *>   (only if canF)
$
$ for an alternative:
$    1) restore LTset/LTmod flags in LLOC (saved as Ualtset/Ualtmod);
$          set modT from modAlt
$    2) call leading member, returning canT,canF,modT,modF,jumplevel;
$           update jumplevel
$       a) if canF, merge LFset/LFmod to Ualtset/Ualtmod; modF->modAlt
$       b) if canT (keep LTset,LTmod) update modT
$    3) before each subsequent member: 
$       a) if canT=FALSE before: error
$       b) if jumplevel<region: wrong jump; reset jumplevel.
$    4) member returns canT,canF,modT,modF,jumplevel:
$           update jumplevel;
$       a) if canF, merge LFset/LFmod to UFset/UFmod; update modF
$       b) if canT (keep LTset,LTmod) update modT
$ at the end of the alternative:
$       a) if canT (alternative succeeds) update UTset/UTmod
$
$ at the end of a region: if nextAlt (last leading member failed):
$    update UFset/UFmod from Ualtset/Ualtmod; update modF from modAlt;
$    if canF: set LFset/LFmod and modF (check label set);
$    if canT: set LTset/LTmod and modT (check label set)
$
$ when encoutering a jump to a label: put modT into the label flag, 
$    indicating the inevitable side effect;
$    for each formal/local copy LTmod to UJmod
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'd alt sequence+>rloc+canT>+canF>+>modT>+modF>+jumpto>
    -lT-lF-mT-mF-nextAlt-nextMod-lJ:
  0->canT->canF->jumpto,0->modF,modT->nextMod,
  (nxt:nextMod->mT,d member+lT+nextAlt+mT+mF+lJ,
    $ if we start with side effect, we will have one no matter what
    (is+nextMod,1->mT->mF;+),
    $ update LFset and LFmod flags for the next leading member
    (is+nextAlt,mF->nextMod,save rule alt head+rloc;+),
    $ alt tail, >lT>,>mT>,>lJ>
    d alt tail+rloc+lT+lF+mT+mF+lJ,
    (is+lT,1->canT,max+mT+modT;+),(is+lF,1->canF,max+mF+modF;+),
    (jumpto=0,lJ->jumpto;lJ<jumpto,lJ->jumpto;+),
    save rule alt sequence+rloc+lT+lF,$ collect which formal/local are set
    (is+nextAlt,setup rule alt head+rloc;+),$ reset LTset/LTmod flags
    (Q+Dsemicolon,
           (is+nextAlt;error+cannot reach this alternative),:nxt;+)),
  $ no more members, see if we can fail
  (is+nextAlt,1->canF,max+nextMod+modF,
    copy local Tflag to F,
    save rule alt sequence+rloc+0+1;+).
$ for each formal/local variable expect LTset, LTmod at enter,
$     set LTset/LFset, LTmod/LFmod when leaving 
'a'd alt tail+>rloc+>canT>+canF>+>modT>+modF>+>jumpto>-lF-lJ-mT-mF:
  0->canF->modF,modT->mT,clear rule tail Fbits+rloc,
  (nxt:Q+Dcomma,
         (canT=0,0->mT,error+cannot reach this member;
          jumpto=0;
          jumpto<=rloc,next+RULE+jumpto,
             error+wrong jump+data*RULE[jumpto],0->jumpto;
          +),
         d member+canT+lF+mT+mF+lJ,
         ((is+canT,is+mT),1->modT;+),
         (is+lF,max+mF+modF,update rule tail Fbits+rloc,1->canF;+),
         (lJ=0;rloc<lJ; $ no jump, or local jump only
          jumpto=0,lJ->jumpto;
          lJ<jumpto,lJ->jumpto;+),
         :nxt;+),
  $ if the tail can fail, set up LLOC LFset/LFmod bits
  (is+canF,setup rule tail Fbits+rloc;+).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'd classification+>rloc+canT>+canF>+>modT>+modF>+jumpto>
  -lT-lF-mT-mF-nextAlt-nextMod-nzone-zone-new-lJ:
  0->canT->canF->jumpto,0->modF,modT->nextMod,
  create empty zone+zone,
  (nxt:must Q+Dzone,
    d read zone+nzone,merge zones+zone+nzone+new,
    merge intervals+zone,incomplete zone+zone+nextAlt,
    (is+new;warning+8+cannot reach this zone),
    1->lT,0->lJ,nextMod->mT,d alt tail+rloc+lT+lF+mT+mF+lJ,
    (is+lT,1->canT,max+mT+modT;+),(is+lF,1->canF,max+mF+modF;+),
    (jumpto=0,lJ->jumpto;lJ<jumpto,lJ->jumpto;+),
    save rule alt sequence+rloc+lT+lF,$ which formal/local is set
    (is+nextAlt,setup rule alt head+rloc;+), $formal/local
    (Q+Dsemicolon,
           (is+nextAlt;warning+8+cannot reach this alternative),:nxt;+)),
  (is+nextAlt,1->canF,max+nextMod+modF,
       copy local Tflag to F,
       save rule alt sequence+rloc+0+1,
       warning+3+classification may fail;+).
$ Compound member.
'a'd compound+canT>+canF>+>modT>+modF>+jumpto>:
  incr+d compound level,
  d rule body+canT+canF+modT+modF+jumpto,
  must Q+Dclose,
  decr+d compound level.
$ compute global modT and formal LTset/LTmod flags. Rescan if necessary
'a'd rule body+canT>+canF>+>modT>+modF>+jumpto>
      -loc-label-rloc-dpos-dnum:
   >>LLOC->loc,d setup label+label,d setup locals,
   d start region+modT,>>RULE->rloc,d add label+label,
   save disc position+dpos+dnum,
   (again-old:
    clear local error+old,
    (Q+Dbox,d read box,d classification+rloc+canT+canF+modT+modF+jumpto;
     d alt sequence+rloc+canT+canF+modT+modF+jumpto),
     $ check if we should redo it again
     $ do it only if there were no errors
    (was local error+old;
     d redo region+rloc+modT,restore disc position+dpos+dnum,:again;
     +)),
   $ set up true and false exit flags; valid only when canT/canF set.
   setup rule alt sequence+rloc,
   (is+canT;0->modT),(is+canF;0->modF),
   $ check all local variables +label from <<loc for usage
   (nxt:>>LLOC<=loc;
      (is local flag+>>LLOC+Lmentioned;
         (type*LLOC=Ilabel,d compound level=0);
         warning+4+local var or label not used+tag*LLOC),
      unstack+LLOC,:nxt).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'd get constant value+x>-tag-type:
  Q cons+x;
  must Qtag+tag,get type+tag+type,(=type=
    [Iconstant],get repr+tag+x;
    [Ipointer constant],strict pointer+tag+x;
    [Iext cons],0->x; $ just for the case being
    error+wrong constant type+tag,0->x).

$ canT: whether the member can succeed (0/1). If 1, LTset flags are OK
$ canF: whether the member can fail (0/1). If 1, LFset flags are OK
$ modT: side effect when succeds (only if canT)
$ modF: side effect when fails (only if canF)
$ jumpto: 0 if no jumps, otherwise the smallest label in RULE
$ formal/local variables: LTset and LTmod are set on entry
$  on axit: LTset/LTmod if canT; LFset/LFmod if canF
'a'd member+canT>+canF>+>modT>+modF>+jumpto>-label:
  0->jumpto->canF,1->canT,0->modF,
  (Q+Dopen,d compound+canT+canF+modT+modF+jumpto;
   Q+Dextension,d extension,1->modT;
   Q+Djump,must Mtag+label,repr*LLOC[label]->jumpto,
        setup rule jump mod+modT+jumpto,0->canT;
   Q+Dplus;
   Q+Dminus,copy local Tflag to F,1->canF,0->canT,modT->modF;
   Q+Dexit,d fsimple affix+0+0+Uin+#,set rule flag+d rule compiled+r exit,0->canT;
   copy local Tflag to F,d actual rule+canF+modT
  ).
$================================================================$

'variable'd compound level=0,d rule compiled=0.

$ check the rule flow
'a'd check rule+>rtag-canT-canF-modT-modF:
$  get file pos+DISC+d rule position,must Qtag+rtag,
  scratch+RULE,scratch+ZONE,0->d compound level,
  rtag->d rule compiled,
  d setup formal stack+rtag, $ formal affixes
  0->modT,d rule body+canT+canF+modT+modF+#,
  (rtag=Xroot tag; $ only when this is not the root
   (is+canT;0->modT,warning+6+rule cannot succeed+rtag),
   (is+canF,(is rule flag+rtag+r can fail;
             error+rule can fail+rtag);
    0->modF,(is rule flag+rtag+r can fail,
             error+rule cannot fail+rtag;+)),
   (is+modT,(is rule flag+rtag+r side effect;
             error+rule has global side effect+rtag);
    canT=0;
    is rule flag+rtag+r side effect,warning+4+rule has no side effect+rtag;+),
   (is+modF,(is rule flag+rtag+r side effect,
               warning+5+fail and rule side effect+rtag;
               error+fail and rule side effect+rtag);+)),
$ check all formal/local variables for usage
  (nxt: >>LLOC < <<LLOC;
        (-check-tag:type*LLOC=Ilabel;
         type*LLOC=Iformal repeat;
         tag*LLOC->tag,
         (is local flag+>>LLOC+Lmentioned;
          warning+4+local or formal var not used+rtag+tag),
         (=type*LLOC=
           [Iformal repeat],0->check,(is local flag+>>LLOC+LTset;
                   is rule flag+rtag+r outvararg,error+no shiftargs called+rtag;
                   warning+5+no shiftargs called+rtag);
           [Iformal stack],0->check,(is local flag+>>LLOC+LTmod;
                   warning+3+stack formal not set+rtag+tag);
           [Iformal in],canF->check,(is local flag+>>LLOC+LTmod,
                   warning+2+formal might change on true+rtag+tag;+);
           [Iformal out],canF->check,(is local flag+>>LLOC+LTset;
                   error+out formal not set+rtag+tag);
           [Iformal inout],canF->check,(is local flag+>>LLOC+LTmod;
                   warning+3+formal does not change+rtag+tag);
           0->check),
           (-level: (is+check,is local flag+>>LLOC+LFmod),
                  (is rule flag+rtag+r macro,9->level;2->level),
                   warning+level+formal might change on false+rtag+tag;+)),
        unstack+LLOC,:nxt),
  must Q+Dpoint.
'a'd store macro+>rtag-dpos-dnum:
  error no>0;
  is rule flag+rtag+r macro,save disc position+dpos+dnum,
    (* dnum->dnum,dpos->dpos,link macro->adm,rtag->tag *)LADM,
    >>LADM->link macro;
  +.
$================================================================$
$ pragmat $
'table'MESSAGE=(
"rule %p: external or not defined, cannot be a macro" :macro rule not defined,
"pragmat public: tag %p has wrong type %p" :wrong public type
).
'variable'dptrace=0,dpcount=0,dpbounds=0,
          dpoverflow=0,dpwrong bit=0,dpwrong string=0.
'a'd reset pragmats:
  0 ->dptrace ->dpcount ->dpbounds ->dpoverflow
    ->dpwrong bit ->dpwrong string.
'a'd link public+>tag-ptr:
    d mark list+tag,link public->ptr,
    (nxt:ptr=0,(* link public->adm,tag->tag *)LADM, >>LADM->link public;
     tag*LADM[ptr]=tag;
     get adm+ptr+ptr,:nxt).
'a'd public+>tag-type:
  get type+tag+type,(=type=
   [Iconstant;Ipointer constant;Istatic var;Ivariable;
    Itable;Istatic stack;Istack],d link public+tag;
   [Irule],(is rule flag+tag+r external,error+wrong public type+tag+type;
            set rule flag+tag+r public,d link public+tag);
   error+wrong public type+tag+type).

'a'd read pragmat-tag:
  Q+Pwarning level,must Qcons+warning level;
  Q+Plibrary,must Qcons+in library;
  Q+Ptrace,must Qcons+#;
  Q+Pcount,must Qcons+#;
  Q+Pbounds,must Qcons+#;
  Q+Poverflow,must Qcons+#;
  Q+Pwrong bit,must Qcons+#;
  Q+Pwrong string,must Qcons+#;
  Q+Pmacro,must Qtag+tag,
     ((is rule flag+tag+r defined,(is rule flag+tag+r external,-;+));
      error+macro rule not defined+tag);
  Q+Ppublic,must Qtag+tag,d public+tag;
  error+internal error,'exit'3.
$ charfile, datafile $
'a'd charfile-tag-dpos:
  must Qtag+tag,save disc position+dpos+#,
    put repr+tag+dpos,put flag+Xstring table+1,
    ((Qcons+#,Qtag+#);error+internal error,'exit'3).
'a'd file area-tag-type:
  Q+Dsub,(nxt:must Qtag+tag,
              (has list type+tag;
               get type+tag+type,error+must be of list type+tag+type),
              (Q+Dbus;:nxt));
  +.
'a'd datafile-tag-dpos:
  must Qtag+tag,save disc position+dpos+#,put repr+tag+dpos,
  d file area,put flag+Xstring table+1,
    ((Qcons+#,Qtag+#);error+internal error,'exit'3).
$ table and stack fill
'a'd list fill-tag-dpos:
  must Qtag+tag,
  (error no>0; $ don't save
   save disc position+dpos+#,
   (* dpos->repr,0->adm,tag->tag *)LADM,
     (link fill=0,>>LADM->link fill;>>LADM->adm*LADM[link fill tail]),
     >>LADM->link fill tail),
  (nxt:Q+Dpoint;d get constant value+#,:nxt).
$================================================================$
'a'postlude II:
  (is+in module,is+pm dump),0->pm dump,Xwarning+2+no dump in module;
  +.
'a'pass II:
  error no>0;
  prelude II,
  (nxt: Q+Drule,(-rtag: must Qtag+rtag,d store macro+rtag,
                         d check rule+rtag),:nxt;
        Q+Droot,d check rule+Xroot tag,:nxt;
        Q+Dpragmat,d read pragmat,:nxt;
        Q+Dcharfile,d charfile,:nxt;
        Q+Ddatafile,d datafile,:nxt;
        Q+Dstack,d list fill,:nxt;
        Q+Dtable,d list fill,:nxt;
        Q+Dend;
        error+internal error,next disc symbol,:nxt),
  postlude II.
$ *********************** PASS II/A **************************** $
$ check macros for recursive calls
'table'MESSAGE=(
 "macro %p: calls itself recursively" :macro calls itself
).
'a'm rule body:
    (Q+Dlabel,must Qtag+#;+),
    (Q+Dlocal,(nxt:Q+Dcolon;must Qtag+#,:nxt);+),
    (Q+Dbox,dskip over source,must Q+Dbox,m classification;
     m alt sequence).
'a'm classification:
    mustQ+Dzone,(nxt:Q+Dzone;Qahead+Dend;next disc symbol,:nxt),
        mustQ+Dcomma,m alt,(Q+Dsemicolon,:m classification;+).
'a'm alt:
   m member,(Q+Dcomma,:m alt;+).
'a'm alt sequence:
   m alt,(Q+Dsemicolon,:m alt sequence;+).
'a'm member-tag-dpos-dnum:
   Q+Dopen,m rule body,must Q+Dclose;
   Q+Dextension,must Qtag+#,d skip extension;
   Q+Djump,must Qtag+#;
   Q+Dplus;
   Q+Dminus;
   Q+Dexit,dskip over source;
   must Qtag+tag,save disc position+dpos+dnum,
      m check macro+tag,restore disc position+dpos+dnum,dskip over affixes.
'a'm skip formals+>tag-formal:
   get adm+tag+formal,(nxt:formal=0;
     (=type*LADM[formal]=[Iformal stack;Iformal table],must Qcons+#,must Qcons+#;+),
   get adm+formal+formal,:nxt).
'a'm read formals+>tag+>loc-formal-x:
   get adm+tag+formal,(nxt:formal=0;
     next+LLOC+loc,
       (=type*LADM[formal]=[Iformal stack;Iformal table],must Qcons+x,
               x->calibre*LLOC[loc],must Qcons+x,x->ssel*LLOC[loc];+),
       get adm+formal+formal,:nxt).
'a'm goto macro+>tag-link:
   link macro->link,
   (nxt: link=0,error+internal error,'exit'3;
    tag*LADM[link]=tag,restore disc position+dpos*LADM[link]+dnum*LADM[link];
   get adm+link+link,:nxt).
$'a'm eval rule+>tag-link:
$   link macro->link,
$   (nxt: link=0,error+internal error,'exit'3;
$    tag*LADM[link]=tag,restore disc position+dpos*LADM[link]+dnum*LADM[link],
$    m skip formals+tag,m rule body;
$    get adm+link+link,:nxt).
'a'm check macro+>tag:
   is rule flag+tag+r mchecked; $ has been checked, nothing to do
   is rule flag+tag+r macro,
     (is rule flag+tag+r mchecking,error+macro calls itself+tag;
      set rule flag+tag+r mchecking,m goto macro+tag,m skip formals+tag,m rule body),
      clear rule flag+tag+r mchecking,
      set rule flag+tag+r mchecked;
   +.
'a'm check all macro rules-link-tag:
  link macro->link,
  (nxt:link=0;
   get tag+link+tag,m check macro+tag,get adm+link+link,:nxt).
'a'pass IIA:
  error no>0;
  m check all macro rules.

$ ************************  PASS III  *************************** $
$ target
'charfile'TARGET="/dev/null">.
'a'open target file-err:
  open file+TARGET+/w/+LEXT+target file;
  get file error+TARGET+err,
     Xerror+cannot open target file+target file+err,
     'exit'2.
'a'close target file: close file+TARGET.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'emit char+>ch:put char+TARGET+ch.
'a'emit int+>n:
    n=min int, emit char+/-/, subtr+-1+n+n,%emit int1+n+/1/;
    n<0, emit char+/-/,get abs+n+n,%emit int1+n+/0/;
    %emit int1+n+/0/.
'a'%emit int1+>n+>c-q-r:
    divrem+n+10+q+r,(q=0; %emit int1+q+/0/),
        add+r+c+r, emit char+r.
'a'emit string+T[]+>p:
   was+T+p,put string+TARGET+T+p;
   error+internal error,'exit'3.
'a'emit hex+>n:
    (0<=n,n<10),emit int+n;
    emit string+"0x",(n=0,emit char+/0/;%emit hex1+n).
'a'%emit hex1+>n-z:
    n=0;bool and+n+0xf+z,right clear+n+4,%emit hex1+n,
    (z<10,add+z+/0/+z,emit char+z;
     add+z+/a/+z,subtr+z+10+z,emit char+z).
'a'emit tag idx+>tag:
    was+LADM+tag,subtr+tag+<<LADM+tag,emit char+/$/,emit int+tag;
    emit char+/$/,emit hex+tag.
'a'emit ptr+>ptr:
    ptr=0,emit string+"[NULL]";
    was+TTAG+ptr,previous+TTAG+ptr,emit string+TTAG+ptr;
    was+LADM+ptr,tag*LADM[ptr]->ptr,:emit ptr;
    was+INDICATOR+ptr,emit string+INDICATOR+ptr;
    was+LEXT+ptr,emit string+LEXT+ptr;
    emit string+"[?",emit hex+ptr,emit char+/]/.
'a'format emit+T[]+*+>fmt-optr-ptr:
    $ format: %c - char,    %d - integer,  %x - hex 0xab12
    $         %p - pointer, %n - newline
    $         %t - 1234
    $         %T - 1234=tag
    >>BUFFER->optr,unpack string+T+fmt+BUFFER,optr->ptr,incr+ptr,
    (nxt:>>BUFFER < ptr;
      BUFFER[ptr]!=/%/,emit char+BUFFER[ptr],incr+ptr,:nxt;
      incr+ptr,(>>BUFFER<ptr,emit char+/%/;
         (=BUFFER[ptr]=
          [/d/],(shift vararg block+*,emit int+fmt;emit string+"[?]");
          [/c/],(shift vararg block+*,emit char+fmt;emit string+"[?]");
          [/x/],(shift vararg block+*,emit hex+fmt;emit string+"[?]");
          [/t/],(shift vararg block+*,emit tag idx+fmt;emit string+"[?]");
          [/T/],(shift vararg block+*,emit tag idx+fmt,emit char+/=/,
                     emit ptr+fmt;emit string+"[?]");
          [/p/],(shift vararg block+*,emit ptr+fmt;emit string+"[?]");
          [/n/],emit char+newline;
          emit char+BUFFER[ptr]),incr+ptr,:nxt)),
    (shift vararg block+*,emit string+"[...]";+),
    unstack to+BUFFER+optr.
'a'emit+*+>mess: format emit+EMIT+*.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'table'EMIT=(
  "ALEPH MODULE %p%n"    :open module,
  "END aleph module%n"   :close module,
  "ALEPH PROGRAM %p%n"   
  "   dump: %d (1: vars,2:rules)%n" :open program,
  "END aleph program%n"  :close program
).
'a'g program head:
  (is+program title;default title->program title),
  (is+in module,emit+open module+program title;
   emit+open program+program title+pm dump).
'a'g program tail:
  is+in module,emit+close module;
  emit+close program.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ PUBLIC section
'table'EMIT=(
  "PUBLIC section%n"     :open public section,
  " CONS   %T, %x%n"     :public cons,
  " SCONS  %T%n"         :public static cons,
  " VAR    %T%n"         :public var,
  " TABLE  %T%n"         :public table,
  " STACK  %T%n"         :public stack,
  " RULE   %T%n"         :public rule,
  "END public section%n" :close public section
).
'a'g public tag+>tag-type-val:
  get tag+tag+tag,get type+tag+type,(=type=
   [Iconstant],           get repr+tag+val,emit+public cons+tag+val;
   [Ipointer constant],   strict pointer+tag+val,emit+public cons+tag+val;
   [Istatic var],         emit+public static cons+tag;
   [Ivariable],           emit+public var+tag;
   [Itable;Istatic stack],emit+public table+tag;
   [Istack],              emit+public stack+tag;
   [Irule],               emit+public rule+tag;
   +).
'a'g all public tags-ptr:
   link public=0;
   emit+open public section,link public->ptr,
     (nxt:ptr=0,emit+close public section;
      g public tag+ptr,get adm+ptr+ptr,:nxt).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ external constants, variables, tables and stacks, rules
'table'EMIT=(
  "EXTERNAL section%n"       :open external section,
  " %p %T%n"                 :external tag,
  "END external sexction%n"  :close external section
).
'a'g single external tag+>tag-type-flag:
  get type+tag+type,(=type=
    [Iext table;Iext stack],get flag+tag+flag,
      (is+flag,emit+external tag+type+tag;+);
    [Iext cons;Iext var;Irule],emit+external tag+type+tag;
    +).
'a'g external tag-ptr-tag:
   (link ext=0,link rule=0);
   emit+open external section,link ext->ptr,
    (nxt: ptr=0;
     g single external tag+ptr,get adm+ptr+ptr,:nxt),
   $ external rules
   link rule->ptr,(nxt:ptr=0;
     get tag+ptr+tag,
     (is rule flag+tag+r called,g single external tag+tag;+),
     get adm+ptr+ptr,:nxt),
   emit+close external section.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ variables
'table'EMIT=(
  "VARIABLES section%n"     :open variables section,
  " VAR %T, %x%n"           :single var decl,
  "END variables section%n" :close variables section
).
'a'g single variable+>tag-type-repr:
   get type+tag+type,(=type=
    [Ivariable;Istatic var],get repr+tag+repr,
      emit+single var decl+tag+repr;
    +).
'a'g variables section-ptr:
   emit+open variables section,link cons->ptr,
   (nxt:ptr=0;
    g single variable+ptr,get adm+ptr+ptr,:nxt),
   emit+close variables section.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ charfile and datafile
$ datafile area can be external list, so no bounds are available
$  this means that the are contains list ID (and not the bounds)
$ consequently lists without actual storage must have their head
'table'EMIT=(
  "FILES section%n"       :open files section,
  " CHARFILE %T, mode=%c, path=(%t,%x)%n" :char file decl,
  " DATAFILE %T, mode=%c, path=(%t,%x)%n"
  "     area[%d]=["       :data file decl head,
  "(%t,%x)"               :data file area decl,
  ",%n              "     :data file area sep,
  "]%n"                   :data file decl tail,
  "END files section%n"   :close files section
).
'a'g file area+cnt>-tag-x:
   Q+Dsub,1->cnt,(nxt: must Qtag+tag,$ tag is of list type
      extend+BUFFER+tag,get tag+tag+x,previous+TTAG+x,
      simplehash+TTAG+x+x,extend+BUFFER+x,
      (Q+Dbus;incr+cnt,:nxt));
   0->cnt.
'a'g single file+>tag-dpos-type-mode-idx-optr-ptr-cnt:
   get repr+tag+dpos,get type+tag+type,
   restore disc position+dpos+0,
   (type=Icharfile,must Qcons+mode,must Qtag+idx,strict pointer+idx+idx,
       emit+char file decl+tag+mode+Xstring table+idx;
    type=Idatafile,>>BUFFER->optr,
       g file area+cnt,must Qcons+mode,
       must Qtag+idx,strict pointer+idx+idx,
       emit+data file decl head+tag+mode+Xstring table+idx+cnt,
       optr->ptr,(nxt:cnt=0;
         (optr=ptr;emit+data file area sep),
         incr+ptr,BUFFER[ptr]->tag,incr+ptr,BUFFER[ptr]->idx,
         emit+data file area decl+tag+idx,decr+cnt,:nxt),
       emit+data file decl tail,unstack to+BUFFER+optr;
    error+internal error,'exit'5).
'a'g all files-ptr:
   link file=0;
   emit+open files section,link file->ptr,
    (nxt:ptr=0,emit+close files section;
         g single file+ptr,get adm+ptr+ptr,:nxt).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ lists
$ two separate sections are generated: declared lists, and fills
$ mem=0 if no storage required, in this case no storage is generated
$ The address space is [l+1,u]; initially <<LIST = l.
'table'EMIT=(
  "LIST section%n"          :open list section,
  " LIST %T, mem=%d, cal=%d, l=%x, u=%x%n"
                            :single list decl,
  "END list section%n"      :close list section,
  "FILL section%n"          :open fill section,
  " LIST %T, l=%x, u=%x%n"
  "    "                    :single fill head,
  ",%n     "                :single fill newline,
  ", "                      :single fill separator,
  "%x"                      :single fill value,
  "%n ELIST %t, count=%d%n" :single fill tail,
  "END fill section%n"      :close fill section
).
'a'g single list+>tag-flag-c-l-u:
   get flag+tag+flag,get calibre+tag+c,get vlwb+tag+l,get vupb+tag+u,
   emit+single list decl+tag+flag+c+l+u.
'a'g next fill value+>tag+>x+>cnt>-r-l-u:
   incr+cnt,divrem+cnt+6+#+r,
    (cnt=1,get vlwb+tag+l,get vupb+tag+u,emit+single fill head+tag+l+u;
     r=1,emit+single fill newline;
     emit+single fill separator),
    emit+single fill value+x.
'a'g close fill part+>tag+>cnt:
   cnt=0; $ nothing
   emit+single fill tail+tag+cnt.
$ standard strings in Xstring table
'a'g single LEXT string+>ptr+>cnt>-w:
   decr+ptr,string width+LEXT+ptr+w,subtr+ptr+w+ptr,
     (nxt:w=0;
      incr+ptr,decr+w,
      g next fill value+Xstring table+LEXT[ptr]+cnt,:nxt).
'a'g dump stdstring-ptr1-ptr2-cnt:
   $ reverse linked list
   0->ptr1,(nxt:LEXT[link string]->ptr2,ptr1->LEXT[link string],
        (ptr2=0;link string->ptr1,ptr2->link string,:nxt)),
   link string->ptr1,0->cnt,(nxt: ptr1=0;
        g single LEXT string+ptr1+cnt,LEXT[ptr1]->ptr1,:nxt),
   g close fill part+Xstring table+cnt.
'a'g single fill+>tag-ptr-cnt-dpos-x:
   (-flag:get flag+tag+flag,flag=0);
   tag=Xstring table,g dump stdstring;
   link fill->ptr,0->cnt,(nxt:
     ptr=0;
     (tag*LADM[ptr]=tag,get repr+ptr+dpos,
       restore disc position+dpos+0,
       (nxt: Q+Dpoint;
         d get constant value+x,g next fill value+tag+x+cnt,:nxt),
       get adm+ptr+ptr,:nxt);+),
    g close fill part+tag+cnt.
'a'g all lists-ptr:
   link list=0;
   emit+open list section,link list->ptr,
   (nxt:ptr=0;g single list+ptr,get adm+ptr+ptr,:nxt),
   emit+close list section,
   emit+open fill section,link list->ptr,
   (nxt:ptr=0;g single fill+ptr,get adm+ptr+ptr,:nxt),
   emit+close fill section.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'g read pragmat:
  Q+Pwarning level,must Qcons+warning level;
  Q+Plibrary,must Qcons+in library;
  Q+Ptrace,must Qcons+dptrace;
  Q+Pcount,must Qcons+dpcount;
  Q+Pbounds,must Qcons+dpbounds;
  Q+Poverflow,must Qcons+dpoverflow;
  Q+Pwrong bit,must Qcons+dpwrong bit;
  Q+Pwrong string,must Qcons+dpwrong string;
  Q+Pmacro,must Qtag+#;
  Q+Ppublic,must Qtag+#;
  error+internal error,'exit'3.
'a'g skip charfile:
   must Qtag+#,next disc symbol,must Qtag+#.
'a'g skip datafile:
   must Qtag+#,(Q+Dsub,(nxt:must Qtag+#,(Q+Dbus;:nxt));+),
   d get constant value+#,must Qtag+#.
'a'g skip list fill:
   must Qtag+#,(nxt:Q+Dpoint;d get constant value+#,:nxt).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ skip a rule
'a'g skip rule body:
   (Q+Dlabel,must Qtag+#;+),
   (Q+Dlocal,(nxt:Q+Dcolon;must Qtag+#,:nxt);+),
   (Q+Dbox,dskip over source,must Q+Dbox,g skip classification;
    g skip alt sequence).
'a'g skip classification:
   mustQ+Dzone,(nxt:Q+Dzone;Qahead+Dend;next disc symbol,:nxt),
     mustQ+Dcomma,g skip alt,(Q+Dsemicolon,:g skip classification;+).
'a'g skip alt:
   g skip member,(Q+Dcomma,:g skip alt;+).
'a'g skip alt sequence:
   g skip alt,(Q+Dsemicolon,:g skip alt sequence;+).
'a'g skip member:
   Q+Dopen,g skip rule body,must Q+Dclose;
   Q+Dextension,must Qtag+#,d skip extension;
   Q+Djump,must Qtag+#;
   Q+Dplus;
   Q+Dminus;
   Q+Dexit,dskip over source;
   must Qtag+#,dskip over affixes.
$ =============================================================== $
$ RULE flags for pass III
'constant'
$ Ustore flags
     Ulocal=1,           $ local for this region (no initial value)
     UBset=2,            $ has value when entering the region
     UTset=4,            $ has value at T exit
     UFset=8,            $ has value at F exit
     UBused=0x10,        $ used starting from beginning
     UTused=0x20,        $ used at T exit
      Uset and used=UBset|UTused,
     UFused=0x40,        $ used at F exit
     UBtoT=0x100,        $ pass through to T exit
     UBtoF=0x200,        $ pass through to F exit
     Uw1=0x10000000,     $ work bits 1--4
     Uw2=0x20000000,
     Uw3=0x40000000,
     Uw4=0x80000000,
$ open,close:
$    UBtoT,UBtoF,Ufirst
$ affix: UTused
$ label value computed
     Ulabel OK=1,        $ label is in data
     Ulabel find=2,      $ search label value
$ flag for Utcont,Ufcont
     Ujump from=0x1000,  $ jump to a label
$ rule,plus,minus,jump,open,close,extension,exit,fcont
     Ufirst=0x10000,     $ group leader
$ rule can be optimized out if has no out affixes
     Uoptimize=0x20000,
$ rule,extension,exit,zone,label,Texit,Fexit
     Ujumpedto=0x40000.  $ generate label for this item
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ ssel and calibre for formal lists
'f'g get ssel+>tag+>loc+x>:
   is+loc,ssel*LLOC[loc]->x;get ssel+tag+x.
'f'g get calibre+>tag+>loc+x>:
   is+loc,calibre*LLOC[loc]->x;get calibre+tag+x.   
'f'g final selector+>tag+>loc+>x>-cal:
   x<=0;$ x= 1,2,...,calibre
   g get calibre+tag+loc+cal,subtr+x+cal+x,
     (x<=0;error+internal error,'exit'5).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'g store formal+>ptr+>flag:
   d compound level>0,push RULE+Ustore+ptr;
   pushf RULE+Ustore+ptr+flag.
'a'g start region+>lloc+rloc>-ptr: $ just after ( formal/local affixes
   push RULE+Ustore+0,>>RULE->rloc,<<LLOC->ptr,
   (nxt: >>LLOC < ptr;
     (=type*LLOC[ptr]=
      [Iformal in],g store formal+ptr+UBset;
      [Iformal out],g store formal+ptr+UTused;
      [Iformal inout],g store formal+ptr+Uset and used;
      [Ilocal],(ptr<=lloc,push RULE+Ustore+ptr;pushf RULE+Ustore+ptr+Ulocal);
      +),next+LLOC+ptr,:nxt).
'a'g close region+>rloc:
   +.
$ extension $
'a'g transport dest+>cal+>cnt>-x:
  Q+Dto,d read selector+x, $ x=1,2,...,cal
   subtr+cal+x+x,push RULE+Uexto+x,incr+cnt,:g transport dest;
  +.
'a'g transport+>rptr+>cal-cnt:
  0->cnt,
  (nxt:g fsimple affix+Uin,g transport dest+cal+cnt,
     (Qahead+Dend;Q+Dextension;:nxt)),
  cnt->data*RULE[rptr].
'a'g extension+>head-rptr-tag-local-calibre:
  must Qlist+tag+local,g get calibre+tag+local+calibre,
  pushf RULE+Uextension+0+head,>>RULE->rptr,
  push RULE+Utcont+0,g transport+rptr+calibre.
$ box and zone $
'a'g read box:
   g fsimple affix+Uin,mustQ+Dbox.
$'a'g read zone+zone>:
$   create zone+zone+#,mustQ+Dzone,push RULE+Uzone+0.
'a'g classification-zone-nzone-nextAlt:
   create empty zone+zone,(nxt:
     mustQ+Dzone,create zone+nzone+#,mustQ+Dzone,
     merge zones+zone+nzone+#,merge intervals+zone,
     incomplete zone+zone+nextAlt,
     (is+nextAlt,push RULE+Uzone+0,push RULE+Utcont+0,pushf RULE+Ufcont+0+Ufirst;
      push RULE+Uempty zone+0,push RULE+Utcont+0),
     g alt tail,(Q+Dsemicolon,push RULE+Usemicolon+0,:nxt;+)).
$ actual rule
'a'g compound+>head-rloc:
   incr+d compound level,pushf RULE+Uopen+0+head,
   >>RULE->rloc,
   g rule body+0,mustQ+Dclose,
   pushf RULE+Uclose+rloc+head,>>RULE->data*RULE[rloc],
   decr+d compound level.
'a'g alt sequence:
   g member+Ufirst,g alt tail,
       (Q+Dsemicolon,push RULE+Usemicolon+0,:g alt sequence;+).
'a'g alt tail:
   Q+Dcomma,g member+0,:g alt tail;+.
'a'g member+>head-tag:
   Q+Dopen,g compound+head;
   Q+Dextension,g extension+head;
   Q+Djump,must Qtag+tag,pushf RULE+Ujump+repr*LLOC[tag]+head;
   Q+Dplus,pushf RULE+Uplus+0+head;
   Q+Dminus,pushf RULE+Uminus+0+head;
   Q+Dexit,pushf RULE+Uexit+0+head,g fsimple affix+Uin;
   must Qtag+tag,
     (is rule flag+tag+r macro,g expand macro+head+tag;
      g actual rule+head+tag).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'p'm limit+x>:
   Qsymbol->x,(Q+Dvlwb;Q+Dvupb;Q+Dlwb;Q+Dupb;Q+Dcalibre).
'a'm fsimple affix+type>-x-tag-loc:
   Qcons+x,putQ+Dconstval+x,Iconstant->type;
   m limit+x,must Qtag+tag,putQ+x+tag,Ipointer constant->type;
   Q+Dsub,putQ+Dsub,m fsimple affix+type,must Q+Dbus,must Qlist+tag+loc,
     d read selector+x,g final selector+tag+loc+x,putQ+Dbus+tag+Dconstval+x;
   Q+Dnoarg,Inoarg->type;
   must Qlist+tag+loc,get type+tag+type,(=type=
     [Istatic var;Iconstant;Iext cons;Ipointer constant;Ivariable;Iext var;
      Iformal in;Iformal out;Iformal inout;Ilocal],putQ+tag;
     [Istatic stack;Itable;Iformal table;Iext table;Istack;Iext stack;
      Iformal stack],g get ssel+tag+loc+x,g final selector+tag+loc+x,
                putQ+Dsub+Dvupb+tag+Dbus+tag+Dconstval+x;
     [Iformal repeat],putQ+tag;
     error+internal error,'exit'6).
'a'm match formal actual+>ftype+type>-tag:
   =ftype=
   [Iformal file;Iformal table;Iformal stack],
       must Qtag+tag,get type+tag+type,putQ+tag;
   [Iformal in;Iformal out;Iformal inout],m fsimple affix+type;
   error+internal error,'exit'6.
$ macro + >a + *rep + >q: q->b,call+a+b+rep.
$  ... ,macro+1+2+T1+T2+rep2, ...
$               ^ ==> q       
$               ^^^^^^^^^^^^ ==> rep
$  replacement:  2->b,call+1+b+2+T1*T1[>>T1]+T2*T2[>>T2]+rep2,
$  ... ,macro+1+rep2, ...  
$ [formal definition of rep2: XXX+...+ *rep2 + s ]
$  replacement:  s->b,call+1+b+rep2
'a'copy QBUFFER affix+>ptr>:
   =QBUFFER[ptr]= [Dplus;Dend],incr+ptr,putQ+Dend;
     [Dconstval],incr+ptr,putQ+Dconstval+QBUFFER[ptr],incr+ptr,:copy QBUFFER affix;
     putQ+QBUFFER[ptr],incr+ptr,:copy QBUFFER affix.
'a'm expand varargs+>repeat-formal-ftype-atype-lrep-cnt-qptr:
  $ repeat is the formal repeat affix of the macro
  get adm+repeat+formal,>>LLOC->lrep,0->cnt,
  (nxt:get type+formal+ftype,m match formal actual+ftype+atype,
       (atype=Iformal repeat; $ last argument
        (cnt=0,(* Lsubstitute->flag,0->repr,formal->tag,0->calibre->ssel,Imacro->type *)LLOC;+),
        (atype!=Inoarg;
         cnt=0,0->flag*LLOC,d compound level->repr*LLOC,Ilocal->type*LLOC,putQ+>>LLOC;
         putQ+Dnoarg),
        get adm+formal+formal,(formal=0,1->cnt,get adm+repeat+formal;+),
        (Q+Dplus,putQ+Dplus,:nxt;+))),
  (-aformal: cnt=0, $ the last actual affix is Iformal repeat and is in QBUFFER
     QBUFFER->aformal,putQ+Dend,get adm+aformal+aformal, $now formal and aformal match
     (nxt:formal=0; $ and then aformal=0
        (* Lsubstitute->flag,>>QBUFFER->repr,formal->tag,0->calibre->ssel,Imacro->type *)LLOC,
        putQ+repr*LADM[aformal]+Dend,
        get adm+formal+formal,get adm+aformal+aformal,:nxt);
   $ copy replacement text except when flag=0 (local for Inoarg)
   putQ+Dend,repr*LLOC[lrep]->qptr,incr+qptr,(nxt:formal=0;
       next+LLOC+lrep,(flag*LLOC[lrep]=Lsubstitute,>>QBUFFER->repr*LLOC[lrep];+),
       copy QBUFFER affix+qptr,get adm+formal+formal,:nxt)).
'a'm macro arguments+>tag-formal-type-x:
   get adm+tag+formal,(nxt:formal=0;
   (* Lsubstitute->flag,>>QBUFFER->repr,formal->tag,0->calibre->ssel,Imacro->type *)LLOC,
     mustQ+Dplus,get type+formal+type,
     (type=Iformal repeat,m expand varargs+formal;
      m match formal actual+type+x,
        (x=Inoarg,0->flag*LLOC,d compound level->repr*LLOC,Ilocal->type*LLOC;
         x=Iformal repeat,error+internal error,'exit'6;
         putQ+Dend),get adm+formal+formal,:nxt)).
'a'g expand macro+>head+>tag-Qptr-Qsub-Lptr-rloc-dpos-lnum:
   >>QBUFFER->Qptr,Qsubstitute->Qsub,incr+d compound level,
   $ Add LLOC entry for all formal, adjust d compound level
   >>LLOC->Lptr,m macro arguments+tag,
   save disc position+dpos+lnum,m goto macro+tag,m read formals+tag+Lptr,
   pushf RULE+Uopen+0+head,>>RULE->rloc,
   subtr+Lptr+<<LLOC+Qsubstitute,next+LLOC+Qsubstitute,
   g rule body+Lptr,mustQ+Dpoint,
   $ unstack to+LLOC+Lptr is done by g rule body
   pushf RULE+Uclose+rloc+head,>>RULE->data*RULE[rloc],
   restore disc position+dpos+lnum,
   decr+d compound level,
   Qsub->Qsubstitute,unstack to+QBUFFER+Qptr.

'a'g actual rule+>head+>rtag-formal-type-repeat-repptr-rptr-opt:
   pushf RULE+Urule+rtag+head,>>RULE->rptr,
   $ if rtag is question or function, no exit called, no out varargs,
   $ and no global out affix, set the "optimize out" flag
   (is rule flag+rtag+r optimize,1->opt;0->opt),
   push RULE+Utcont+0,(is rule flag+rtag+r can fail,pushf RULE+Ufcont+0+head;+),
   get adm+rtag+formal,0->repeat->repptr,
   (nxt:Q+Dplus,get type+formal+type,
          (type=Iformal repeat,push RULE+Urepeat+0,>>RULE->repptr,
           get adm+formal+formal,get type+formal+type,formal->repeat;+),
          opt->g global out,g match formal actual+type,g global out->opt,
          get adm+formal+formal,
          (formal=0,(is+repptr,incr+data*RULE[repptr];+),repeat->formal;+),:nxt;
    +),
    (is+opt;set RULE flag+rptr+Uoptimize).
$ set to 1 if an out affix changes global value
'variable'g global out=0.
'a'g match formal actual+>formal:
  =formal=
  [Iformal file;Iformal table;Iformal stack],must Qtag+#;
  [Iformal shift],must Qtag+#;
  [Iformal in],g fsimple affix+Uin;
  [Iformal out],g fsimple affix+Uout;
  [Iformal inout],g fsimple affix+Uinout;
  [Iformal repeat],must Qtag+#;
  error+internal error,'exit'9.
'a'g fsimple affix+>utype-tag-type:$ Uin,Uout,Uinout: transport, box, exit
  Qcons+#;
  m limit+#,must Qtag+#;
  Q+Dsub,utype to slice+utype+type,g fsimple affix+type,
     must Q+Dbus,must Qtag+#,d read selector+#;
  Q+Dnoarg;
  must Qtag+tag,get type+tag+type,(=type=
   [Iformal in;Iformal out;Iformal inout;Ilocal],push RULE+utype+tag;
   ((utype=Uout;utype=Uinout),1->g global out;+)
   ).
'a'g rule body+>loc-label-rloc:
   (loc=0,>>LLOC->loc;+),d setup label+label,d setup locals,
   g start region+loc+rloc,d add label+label,
   (Q+Dbox,push RULE+Ubox+0,g read box,g classification,push RULE+Uendbox+0;
    g alt sequence),
   g close region+rloc,unstack to+LLOC+loc. 
$ = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = $
$ traverse RULE forward/backward
'variable'RULE ptr=0,this RULE=0.
'a'U next: RULE ptr->this RULE,next+RULE+RULE ptr.
'p'U+>x:type*RULE[RULE ptr]=x,U next.
'a'Umust+>x:U+x;Xerror+internal error,'exit'12.
'a'B prev: RULE ptr->this RULE,previous+RULE+RULE ptr.
'p'B+>x:type*RULE[RULE ptr]=x,B prev.
'q'is Rflag+>flag:
   is RULE flag+this RULE+flag.
'a'set Rflag+>flag+>v:
   v=0,clear RULE flag+this RULE+flag;
   set RULE flag+this RULE+flag.

$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ asign labels to Utcont/Utcont entries. 
$ make sure there are no redirections
$ Units which are jumped to (and they do not follow lexically)
$  are flagged by Ujumpedto. Utcont/Ufcont going not to the
$  lexically next unit are flagged by Ujumpfrom
$ some trivial cases of infinite loops are detected

'table'MESSAGE=(
 "rule %p: infinite loop starting at label %p"
     " (after macro expansion)"                    :infinite loop,
 "rule %p: area #%d jumps immediately to label %p" :infinite zone
).

$ find the unit where a label refers to
'a'l find label+>rtag+>ptr+value>:
   is RULE flag+ptr+Ulabel OK,data*RULE[ptr]->value;
   is RULE flag+ptr+Ulabel find,Xerror+infinite loop+rtag+data*RULE[ptr],
        ptr->value,clear RULE flag+ptr+Ulabel find,
        set RULE flag+ptr+Ulabel OK,value->data*RULE[ptr];
   set RULE flag+ptr+Ulabel find,ptr->value,next+RULE+value,
      (nxt:=type*RULE[value]=
       [Urule;Uextension;Uexit;Ubox;UTexit;UFexit],+;
       [Uplus;Uminus;Ujump],data*RULE[value]->value,:nxt;
       [Ulabel],l find label+rtag+value+value;
       next+RULE+value,:nxt),
      clear RULE flag+ptr+Ulabel find,set RULE flag+ptr+Ulabel OK,
         value->data*RULE[ptr].
$ ptr is a tcont/fcont destination. If it is a label, find the
$   ultimate destination. If not lexically next, mark both
'a'l jump destination+>rtag-dest-p:
   data*RULE[this RULE]->dest,
     (=type*RULE[dest]=
       [Urule;Uextension;Uexit;Ubox;Uzone;UTexit;UFexit],+;
       [Ulabel],l find label+rtag+dest+dest,dest->data*RULE[this RULE];
       Xerror+internal error,'exit'42
     ),
     this RULE->p,next+RULE+p,
     (dest<=this RULE;
      (nxt: =type*RULE[p]=
       [Urule;Uextension;Uexit;Ubox;Uzone;UTexit;UFexit],+;
       next+RULE+p,:nxt)),
     (p=dest;set RULE flag+dest+Ujumpedto,set RULE flag+this RULE+Ujumpfrom).
$ (nxt: (=a= [37],:nxt;-); + )
$   check that tcont,fcont for Uzone (Uempty zone) is not 
$   the address of the corresponding Ubox. For the message
$   it would be worth to keep the label.
$ Ubox ends with Uendbox
'a'l check zone+>rtag-box-cnt:
    this RULE->box,0->cnt,(nxt:
      U+Ubox,l check zone+rtag,:nxt;
      U+Uzone,incr+cnt,
          (U+Utcont,
             (box=data*RULE[this RULE],Xerror+infinite zone+rtag+cnt+data*RULE[box];
              +);+),
          (U+Ufcont,
             (box=data*RULE[this RULE],Xerror+infinite zone+rtag+cnt+data*RULE[box];
              +);+),:nxt;
      U+Uempty zone,incr+cnt,
          (U+Utcont,
             (box=data*RULE[this RULE],Xerror+infinite zone+rtag+cnt+data*RULE[box];
              +);+),:nxt;
      U+Uendbox;
      (U+UTexit;U+UFexit),Xerror+internal error,'exit'15;
      U next,:nxt).
$ alab: alternate label
$ flab: false exit,
$ tlab: true exit
$ nlab: next true label
$ going backward ...
'a'l put labels+>tlab+>flab-ptr:
   this RULE->ptr,next+RULE+ptr, $ type=tcont $
   tlab->data*RULE[ptr],
   next+RULE+ptr,
   (type*RULE[ptr]=Ufcont,flab->data*RULE[ptr];+).
'a'l treat region+>tlab+>flab+nlab>-alab:
   flab->alab,tlab->nlab,
   (nxt:RULE ptr< <<RULE;
        B+Uopen;
        B+Usemicolon,nlab->alab,tlab->nlab,:nxt;
        B+Uplus,nlab->data*RULE[this RULE],:nxt;
        B+Uminus,(is Rflag+Ufirst,alab->nlab;flab->nlab),
             nlab->data*RULE[this RULE],:nxt;
        (B+Uextension;B+Urule),
             (is Rflag+Ufirst,l put labels+nlab+alab;
              l put labels+nlab+flab),this RULE->nlab,:nxt;
        B+Uzone,l put labels+nlab+alab,this RULE->nlab,:nxt;
        B+Uempty zone,l put labels+nlab+alab,:nxt;
        B+Ubox,this RULE->nlab,:nxt;
        B+Ujump,data*RULE[this RULE]->nlab,:nxt;
        B+Uexit,this RULE->nlab,:nxt;
        B+Uclose,(is Rflag+Ufirst,l treat region+nlab+alab+nlab;
                  l treat region+nlab+flab+nlab),:nxt;
        B prev,:nxt).
'a'l make labels+>rtag-texit-fexit-x:
   $ set up Texit, Fexit
   push RULE+UTexit+0,>>RULE->texit->RULE ptr,
   (is rule flag+rtag+r can fail,push RULE+UFexit+0,>>RULE->fexit;
    0->fexit),
   $ find out address jumped to
   l treat region+texit+fexit+#,
   $ add real address of each Ubox
   <<RULE->RULE ptr,0->x,(nxt:
     U+UTexit;
     U+Ulabel,data*RULE[this RULE]->x,:nxt;
     U+Ubox,x->data*RULE[this RULE],:nxt;
     U next,:nxt),
   $ unroll jump chains, complain for infinite loop
   <<RULE->RULE ptr,(nxt:
     U+UTexit;
     (U+Utcont;U+Ufcont),l jump destination+rtag,:nxt;
     U next,:nxt),
   $ check immediate jumps in zone
   <<RULE->RULE ptr,(nxt:
     U+UTexit;
     U+Ubox,l check zone+rtag,:nxt;
     U next,:nxt).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ >ptr : second Ustore entry, just after (Ustore,0,0)
$ copy f1 to f2
'a'r copy RULE flags+>f1+>f2+>ptr:
   type*RULE[ptr]!=Ustore;
   (is RULE flag+ptr+f1,set RULE flag+ptr+f2;clear RULE flag+ptr+f2),
   next+RULE+ptr,:r copy RULE flags.
$ if f1 is one, set f2 to one
'a'r or RULE flags+>f1+>f2+>ptr:
   type*RULE[ptr]!=Ustore;
   (is RULE flag+ptr+f1,set RULE flag+ptr+f2;+),
   next+RULE+ptr,:r or RULE flags.
$ if f1 is zero, clear f2
'a'r and RULE flags+>f1+>f2+>ptr:
   type*RULE[ptr]!=Ustore;
   (is RULE flag+ptr+f1;clear RULE flag+ptr+f2),
   next+RULE+ptr,:r and RULE flags.
$ from ptr go ahead until data*RULE[this RULE] is found
'f'r find LOCAL+>ptr+lptr>-local:
   ptr->lptr,data*RULE[this RULE]->local,(nxt:
     type*RULE[lptr]!=Ustore,error+internal error,'exit'12;
     data*RULE[lptr]=local;
     next+RULE+lptr,:nxt).
$ >p   : outer Ustore block, just after (Ustore,0,0)
$ >newp: inner Ustore block, pointing at (Ustore,0,0)
$  if f1*outer is set, set f2*inner
'a'r or block bits to+>p+>newp+>f1+>f2:
   $ ASSERT+"RULE[newp]=(Ustore,0,0)
   next+RULE+newp,
   $ ASSERT+"p<=newp", here p and newp can be equal
   (nxt:type*RULE[p]!=Ustore;
    $ ASSERT+"data*RULE[p]=data*RULE[newp]" $
    (is RULE flag+p+f1,set RULE flag+newp+f2;+),
      next+RULE+newp,next+RULE+p,:nxt).
$ >p   : outer block
$ >newp: inner block
$ copy f1*inner to f2*outer
'a'r copy block bits from+>p+>newp+>f1+>f2:
  next+RULE+newp,(nxt:
   type*RULE[p]!=Ustore;
   (is RULE flag+newp+f1,set RULE flag+p+f2;clear RULE flag+p+f2),
     next+RULE+newp,next+RULE+p,:nxt).
$ >p   : outer block
$ >newp: inner block
$ if f1*inner is zero, clear f2*outer
'a'r and block bits from+>p+>newp+>f1+>f2:
  next+RULE+newp,(nxt:
   type*RULE[p]!=Ustore;
   $ ASSERT+"data*RULE[p]=data*RULE[newp]" $
   (is RULE flag+newp+f1;clear RULE flag+p+f2),
     next+RULE+newp,next+RULE+p,:nxt).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ compute Tset/Fset/Bset bits for each formal/local
$ compute BtoT/BtoF bits for Uclose
$ start: looking at (Ustore,0,0); stop after Uclose/UTexit
$ assume Bset filled
$  w1: has value right now (rolling)
$  w2: has value at the next alternative
'a'r compute setbits-p-pl-tT-tF-tN-tA:
   Umust+Ustore, RULE ptr->p, $ p points to the second Ustore entry $
   (nxt:U+Ustore, $ initial setup
      (is Rflag+UBset,set Rflag+Uw1+1;set Rflag+Uw1+0),
      set Rflag+UTset+1,set Rflag+UFset+1,:nxt;+),
   $ tN,tT,tF,tA: next/true/false/alt is reachable
   1->tN,0->tT->tF->tA,(nxt:
      U+Ujump,0->tN,:nxt;
      U+Uexit,0->tN,:nxt;
      U+Uminus, $ ASSERT+"tN=1" $
        (is Rflag+Ufirst,1->tA,r copy RULE flags+Uw1+Uw2+p;
         1->tF,r and RULE flags+Uw1+UFset+p),0->tN,:nxt;
      U+Ufcont,
        (is Rflag+Ufirst,1->tA,r copy RULE flags+Uw1+Uw2+p;
         1->tF,r and RULE flags+Uw1+UFset+p),:nxt;
      U+Usemicolon,(is+tN,1->tT,r and RULE flags+Uw1+UTset+p;+),
        r copy RULE flags+Uw2+Uw1+p,tA->tN,0->tA,:nxt;
      U+Uout,r find LOCAL+p+pl,set RULE flag+pl+Uw1,:nxt;
      U+Uopen,RULE ptr->pl,r or block bits to+p+pl+Uw1+UBset,
        r compute setbits,
        (is Rflag+UBtoT,r copy block bits from+p+pl+UTset+Uw1;0->tN),
        $ ASSERT+"type*RULE[this RULE]=Uclose"
        (is Rflag+UBtoF,
           (is Rflag+Ufirst,1->tA,r copy block bits from+p+pl+UFset+Uw2;
            1->tF,r and block bits from+p+pl+UFset+UFset);+),
        :nxt;
      U+Uclose,((is+tN;is+tT),set Rflag+UBtoT+1;+),
               ((is+tA;is+tF),set Rflag+UBtoF+1;+);
      U+UTexit; $ get out
      U next,:nxt),
    (is+tN,r and RULE flags+Uw1+UTset+p;+),
    (is+tA,r and RULE flags+Uw2+UFset+p;+).
'a'r find connections:
   <<RULE->RULE ptr,r compute setbits.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
$ compute Bused/Tused/Fused flags
$ mark affixes it the value used is the last one
$  w1: used right now
$  w2: used at next alt

$ handle an affix group
$  First scan: out affix: clear used flag,
$              slice out/slice inout affix: set used flag
$  Second scan: in, out, slice in  affix: set used flag
$  mark affixes whose the value is used later (flag Tused)
'a'r treat affix group+>p-old RULE-pl:
   this RULE->old RULE,old RULE->RULE ptr,(nxt:
    $ first scan, out variables
    B+Uout,r find LOCAL+p+pl,
        (is RULE flag+pl+Uw1,set RULE flag+this RULE+UTused;+),
        clear RULE flag+pl+Uw1,:nxt;
    (B+Usliceout;B+Usliceinout),r find LOCAL+p+pl,
        (is RULE flag+pl+Uw1,set RULE flag+this RULE+UTused;+),
        set RULE flag+pl+Uw1,:nxt;
    (B+Uin;B+Uinout;B+Uslicein;B+Urepeat),:nxt;
    +),old RULE->RULE ptr,(nxt:
    $ second scan, other variables
    (B+Uin;B+Uinout,B+Uslicein),r find LOCAL+p+pl,
        (is RULE flag+pl+Uw1,set RULE flag+this RULE+UTused;+),
        set RULE flag+pl+Uw1,:nxt;
    (B+Uout;B+Usliceout;B+Usliceinout;B+Urepeat),:nxt;
    +).
'a'r copy jump used+>jmp+>p-p1:
   $ ASSERT+"type*RULE[jump]=Ulabel"
   previous+RULE+jmp, $ ASSERT+"type*RULE[jmp]=Ustore"
   (nxt: data*RULE[jmp]=0; previous+RULE+jmp,:nxt),
   next+RULE+jmp,
   p->p1,previous+RULE+p, $ clear Uw1 flags
   (nxt:type*RULE[p1]!=Ustore;
        clear RULE flag+p1+Uw1,next+RULE+p1,:nxt),
   $ set Uw1 flags
   r or block bits to+jmp+p+UBused+Uw1.
'a'r compute used bits+>p+>new>-pl:
   $ ASSERT+"RULE[p]=(Ustore,0,0)"
   next+RULE+p,
   r copy RULE flags+UTused+Uw1+p,
   r copy RULE flags+UFused+Uw2+p,
   (nxt:RULE ptr < <<RULE;
      B+Uopen;
      B+Usemicolon,r copy RULE flags+Uw1+Uw2+p,
                r copy RULE flags+UTused+Uw1+p,:nxt;
      B+Uminus,(is Rflag+Ufirst,r copy RULE flags+Uw2+Uw1+p;
                r copy RULE flags+UFused+Uw1+p),:nxt;
      B+Ujump,r copy jump used+data*RULE[this RULE]+p,:nxt;
      B+Ufcont,(is Rflag+Ufirst,r or RULE flags+Uw2+Uw1+p;
                r or RULE flags+UFused+Uw1+p),:nxt;
      B+Uclose,data*RULE[this RULE]->pl,
         $ ASSERT+"type*RULE[pl]=Uopen"
         next+RULE+pl, $ ASSERT+"RULE[pl]=(Ustore,0,0)"
         r or block bits to+p+pl+Uw1+UTused,
         (is Rflag+Ufirst, r or block bits to+p+pl+Uw2+UFused;
          r or block bits to+p+pl+UFused+UFused),
         r compute used bits+pl+new,
         r copy block bits from+p+pl+UBused+Uw1,:nxt;
      (B+Uout;B+Uin;B+Uinout;B+Uslicein;B+Usliceout;
       B+Usliceinout;B+Urepeat),r treat affix group+p,:nxt;
      B prev,:nxt),
   $ copy UW1 to UBused; mark if there is a change
   $  r or RULE flags+Uw1+UBused+p
   (nxt:type*RULE[p]!=Ustore;
    (is RULE flag+p+Uw1,
      (is RULE flag+p+UBused;1->new,set RULE flag+p+UBused);
     $ ASSERT: !is RULE flag+p+UBused
     +),
    next+RULE+p,:nxt).
'a'r find use bits-new:
   0->new,>>RULE->RULE ptr,r compute used bits+<<RULE+new,
   (is+new,:r find use bits;+).
$ --------------------------------------------------------------- $
$ this optimization does not work as vararg affixes are
$ not handled properly. They should enter the list, see before ...
$
'a'r same label-label-yes:
   <<RULE->RULE ptr,(nxt:
     U+UTexit;
     (U+Urule;U+Uzone),
       (U+Utcont,data*RULE[this RULE]->label,
          $ this happens for (pred+#,+);
          ((U+Ufcont,data*RULE[this RULE]=label),Xwarning+0+internal error;+);
        +),:nxt;
     U next,:nxt),
   <<RULE->RULE ptr,(nxt:
     U+UTexit;
     U+Urule,(isRflag+Uoptimize,1->yes,0->label,
          (nxt4: U+Utcont,data*RULE[this RULE]->label,:nxt4;
                 U+Ufcont,(data*RULE[this RULE]!=label,0->yes;+),:nxt4;
                 U+Uin,:nxt4;
                 U+Uslicein,:nxt4;
                 U+Usliceout,0->yes,:nxt4;
                 U+Usliceinout,0->yes,:nxt4;
                 U+Urepeat,:nxt4;
                 U+Uinout,(isRflag+UTused,0->yes;+),:nxt4;
                 U+Uout,(isRflag+UTused,0->yes;+),:nxt4;
                 +$ optimize out $);+),:nxt;
      U next,:nxt).

$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'n generate rule body+>tag:
   g skip rule body. $ generate the rule here
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'g make rule+>tag-dpos-dnum:
   scratch+RULE,scratch+ZONE,0->d compound level,
   save disc position+dpos+dnum,tag->d rule compiled,
   d setup formal stack+tag, $ scratch LLOC
   g rule body+0,l make labels+tag,r find connections,
    r find use bits,
    r same label,
   (error no>0; $ infinite loop error
     restore disc position+dpos+dnum,scratch+ZONE,
     d setup formal stack+tag,
     n generate rule body+tag),
   must Q+Dpoint.
'a'g check rule+>tag:
   is rule flag+tag+r public,g make rule+tag;
   is rule flag+tag+r macro,m skip formals+tag,g skip rule body, must Q+Dpoint;
   is rule flag+tag+r called,g make rule+tag;
   m skip formals+tag,g skip rule body,must Q+Dpoint.
$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'a'prelude III:
   open target file,
    $ reset pragmats
   0->dptrace->dpcount->dpbounds->dpoverflow->dpwrongbit->dpwrongstring,
    $ rewind DISC and start reading
   0->Qsymbol->Qtype->Qbuffer ptr->Qsubstitute,
   restore disc position+0+0, $ rewind and set linenum to zero $
   +.
'a'postlude III:
   close target file.
'a'pass III:
    error no>0;
    prelude III,
    $ program head
      g program head,
    $ generate data section
      g all public tags,g external tag,g variables section,
      g all files,g all lists,
    $ generate rules
    restore disc position+0+0,
    (nxt: Q+Drule,(-rtag:must Qtag+rtag,g check rule+rtag),:nxt;
          Q+Droot,g check rule+Xroot tag,:nxt;
          Q+Dpragmat,g read pragmat,:nxt;
          Q+Dcharfile,g skip charfile,:nxt;
          Q+Ddatafile,g skip datafile,:nxt;
          Q+Dstack,g skip list fill,:nxt;
          Q+Dtable,g skip list fill,:nxt;
          Q+Dend;
          error+internal error,'exit'3),
      g program tail,
    postlude III.
$----------------------------------------------------------------$
$ Reading from DISC with macro substitution
$    M+a1+a2+a3-l1-l2:<body>.  ==> (M-l1-l2:<body>)
$ for table/stack ssel and calibre is stored directly
$  no substitution for
$     LABEL<tag>; LOCAL {tag}+ COLON
$  when it LLOC, check if formal arg ==> replace,
$      otherwise adjust (new locals start with rule label)
$  if formal arg/tag and table/stack, store ssel and calibre
$  if <tag> and macro rule, read and store actual affixes;
$      replace +L by L*L[>>L] when simple (must know ssel for L)
$  (the same problem when L is a source somewhere else)
$  actual affix # becomes local in the macro
$ RULE: compile only if a) r public is set; b) r called is set

$================================================================$

'root'
   pass I,pass II,pass IIA,pass III.

'end'
$================================================================$

'a'list disc content-d-type-cnt:
  open disc+/r/,0->cnt,
  (nxt: get data+DISC+d+type,
        (is+type,print+DSYMB+d;
         print int+d),
        incr+cnt,(cnt=8,0->cnt,nlcr;print char+/ /),
        :nxt;
   print char+newline,close disc).   

$=================================================================$
'a'emit spec+>cmdchar+>ptr:
  =cmdchar=
  [/d/],put int+STDOUT+ptr;
  [/v/],$ local or global variable $ +;
  put string+STDOUT+"unknown command char: ",put char+STDOUT+cmdchar,
  put string+STDOUT+", arg=",put int+STDOUT+ptr.
'a'emit+T[]+*+>ptr-oldptr-ch:
  >>BUFFER->oldptr,unpack string+T+ptr+BUFFER,
  oldptr->ptr, incr+ptr,(nxt:>>BUFFER<ptr,unstack to+BUFFER+oldptr;
    (BUFFER[ptr]=/%/,incr+ptr,(>>BUFFER<ptr,/%/->ch;BUFFER[ptr]->ch),
       (ch=/%/,put char+STDOUT+ch;
        shift vararg block+*,emit spec+ch+ptr;
        put string+STDOUT+"out of arguments in emit"
       );
     put char+STDOUT+BUFFER[ptr]
    ),incr+ptr,:nxt).

'a'emit string+T[]+>ptr:put string+STDOUT+T+ptr.
'a'emit cons+>x:put int+STDOUT+x.

$ first: the interval list used so far; second: this zone
$    v1=min int, v1=max int, do nothing ????
'a'emit register between+>v1+>v2:
  v1=v2,emit string+"(V==",emit const+v2,emit string+")";
  v1=min int, emit string+"(V<=",emit const+v2,emit string+")";
  v2=max int,emit string+"(V>=",emit const+v1,emit string+")";
  emit string+"(V>=",emit const+v1,emit string+"&&V<=",
           emit const+v2,emit string+")".

$ use only if the result is NOT [min int, max int]
$   could generate wrong code when previous interval 
$   intersect intervals some coming later.
'a'generate code for a zone+>first+>second-more:
   next*ZONE[second]->second,0->more,
   (nxt-lb-up-new:
    second=0;
    lb*ZONE[second]->lb,up*ZONE[second]->up,
       shrink interval+first+lb+up+new,
       (new=0;
        (is+more,emit string+"||";1->more),emit register between+lb+up),
       :generate code for a zone).
        

