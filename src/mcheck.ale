$ check macros
'pragmat'module="macros".
$ HEADER ******************************************************* $
$ read from DISC and check that macros do not call each other
$
'a'check macro rules.

$ BODY ********************************************************* $
'pragmat'if=compile.
'pragmat'require=("display","disc","tags").

'table'MESSAGE=(
  "rule %p: unbounded macro substitution":recursive macro call
).

'a'skip source:
  Q cons+#;
  (Q+Dlwb;Q+Dupb;Q+Dvlwb;Q+Dvupb;Q+Dcalibre),must Qtag+#;
  Q+Dsub,must Qtag+#,skip source,mustQ+Dbus,must Qtag+#,(Qtag+#;must Qcons+#);
  Q+Dnoarg;
  must Qtag+#.
'a'skip affixes:
  Q+Dplus,skip source,:skip affixes;+.

'a'rule body:
  (Q+Dlabel,must Qtag+#;+),
  (Q+Dlocal,Qskip+Dcolon;+),
  (Q+Dbox,Qskip+Dbox,classification;
   alt sequence).
'a'classification:
  mustQ+Darea,Qskip+Darea,mustQ+Dcomma,alternative,
    (Q+Dsemicolon,:classification;+).
'a'alternative:
   member,(Q+Dcomma,:alternative;+).
'a'alt sequence:
   alternative,(Q+Dsemicolon,:alt sequence;+).
 'a'member-tag:
   Q+Dopen,rule body,mustQ+Dclose;
   Q+Dextension,Qskip+Dextension;
   Q+Djump,must Qtag+#;
   Q+Dplus;
   Q+Dminus;
   must Qtag+tag,(is tag flag+tag+rmacro,check macro rule+tag;+),
      skip affixes.

'a'check macro rule+>tag-dpos-dnum-mp-mn:
   $ tag is a macro
   is tag flag+tag+rmchecked;
   is tag flag+tag+rmchecking,
     error+recursive macro call+tag,clear tag flag+tag+rmchecking,
     set tag flag+tag+rmchecked;
   set tag flag+tag+rmchecking,save disc position+dpos+dnum,
     search macro rule+tag+mp+mn,restore disc position+mp+mn, 
     rule body,clear tag flag+tag+rmchecking,set tag flag+tag+rmchecked,
     restore disc position+dpos+dnum.

'a'check macro rules-tag:
   0->tag,(nxt:next macro rule+tag,check macro rule+tag,:nxt;+).

'root'+.

'pragmat'endif=compile.

'end'

