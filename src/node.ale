$ node generation
'pragmat'module="node".
$ HEADER ***************************************************** $
$
$ generate nodes for rules, also apply some optimization.
$ node types:
$  -  call
$  -  extension
$  -  classifier
$  -  head / tail
$ A call has zero, one or two exits; a classifier has one exit
$  for each alternative (one of them must succeed); an
$  extension has one exit. Eventually, each exit is a label of
$  some node.
$ Data flow is recalculated for formal in/out/inout and local
$  variables to see if set variables are actually used; if not
$  then the assignment can be skipped. It requires traversing
$  the flow backwards several times.
$ Each compound block stores flags for all relevant formal/local
$  -- at entry v has a value and it is used as it is
$        Example: at 2 this flag should be set set as "2->v"
$                 cannot be optimized out
$        1->v, (l1: use v, (l2:condition,:l1; 2->v,:l2))
$              ^1          ^2
$  -- after leaving the block with true, v is set and will be used
$  -- after leaving the block with false, v is set and will be used
$  -- auxiliary bit for the head of the next alternative
$
$ one can go backwards maintaining this bit. Node "n" has one or
$  two successors. If "n" gives value to v and the true branch has
$  this flag off, no need to store and forward the false brach flag.
$  If "n" uses v, set this flag. If "n" does not mention v, OR the
$  flags of the two branches. At jumps, take the flag from the
$  referred entry point.
$
$ Flags at the compound blocks can be computed iteratively. Initially
$  all are zero; the final TRUE and FALSE flags are computed for
$  formals. Then apply the sweep above, set the compound block head
$  flags for each alternative head, and mark if it went up. If any
$  of the bits went up, repeat. (Keep old flags as they can never go
$  down.)
$
$ ----------------------------------------------------------- $
$ There are three no-op nodes: +, -, jump. After assigning labels
$  the are left out. As a final optimization, identical nodes can
$  be merged, this can trigger further merging.

$ this is for in/out/inout and local affixes
$ the RULE stack is filled
$
$   RULE	*LADM
$   use		formal/local (affixes used)
$   TRUE	0/*RULE
$   FALSE	0/*RULE   (optional)
$   use/set/
$    noset	formal/local (affixes used/set/noset if successful)
$
$   EXTENSION	tag (formal/global)
$   use		formal/local (used for filling)
$   TRUE	0/*RULE
$
$   CLASS	-
$   use		formal/local (in classification box)
$   ZONE	-
$   TRUE	0/*RULE
$   FALSE	0/*RULE  (the last zone has no FALSE label)
$
$   JUMP	*RULE
$   PLUS	0/*RULE
$   MINUS	0/*RULE
$
$   OPEN	number of saved flags; a JUMP points here
$   0		<flags for each relevant formal/local>
$   CLOSE	*RULE (the OPEN pair)
$
$   SCOLON	(semicolon to separate alternatives)
$   HEAD	(just after the head to indicate that this it is)

$ two use bits for affix "v": ends in T or F; needed: (canT,canF)
$    use v:     set
$    set v:     clear
$    FALSE:     T bit: if not head, ignore;
$                      if head, OR T-bit of head of next alt
$               F-bit: if not head, bring F bit of block;
$                      if head, FALSE of the head of the next alt)
$    JUMP:      copy from the point (clear if not there)

$ macro substitution ---------------------------------------- $
$  LLOC is shifted by Qsubstitute
$    when we see a formal affix, we return the replaced entry
$    there is a problem with ssel, as it is not forwarded. Example:
$    'a'macro+[]t[]+>x: x->t. 'stack'(b)S.
$    "macro+S+0" is OK (formal t and actual S match), 
$    substitution "0->S" is incorrect (S has no ssel).
$    Actually, 'a'macro+[]t[]+>x: x->t*t. is correct
$    Check this in drules.ale. Also, exact match is
$    necessary in macros.

'a'macro limit+x>: 0->x.

'a'macro arguments+>tag-formal-type-x:
   get adm+tag+formal,(nxt:formal=0;
   (* Lsubstitute->flag,>>QBUFFER->repr,formal->tag,0->calibre->ssel,Imacro->type *)LLOC,
   mustQ+Dplus,get type+formal+type,
   (type=Iformal repeat,expand varargs+formal;
    match formal actual+type+x,
      (x=Inoarg,0->flag*LLOC,compound level->repr*LLOC,Ilocal->type*LLOC;
       x=Iformal repeat,internal error+"impossible";
       putQ+Dend),


'a'expand macro+>head+>tag





'end'

