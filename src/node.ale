$ node generation
'pragmat'module="node".
$ HEADER ***************************************************** $
$
$ generate nodes for rules, also apply some optimization.
$ node types:
$  -  call
$  -  extension
$  -  classifier
$  -  head / tail
$ A call has zero, one or two exits; a classifier has one exit
$  for each alternative (one of them must succeed); an
$  extension has one exit. Eventually, each exit is a label of
$  some node.
$ There are three no-op nodes: +, -, jump. After assigning labels
$  the are left out. As a final optimization, identical nodes can
$  be merged, this can trigger further merging.
$ ----------------------------------------------------------- $
$ Data flow is recalculated for formal in/out/inout and local
$  variables to see if set variables are actually used; if not
$  then the assignment can be skipped. It requires traversing
$  the flow backwards.
$ Each compound block stores a flag for all relevant formal/local
$  -- at entry v has a value and it is used
$     Example: at 2 this flag is set and "2->v" cannot be
$     optimized out:
$        1->v, (l1: use v, (l2:condition,:l1; 2->v,:l2))
$              ^1          ^2
$ 
$ A backward pass computes it. Suppose we are at the RULE or
$ EXTENSION and  have this bit at the (potential) T and the F
$ exits. I the RULE is an 'exit', clear. Otherwise get it
$ from T, modify by the out affix (if any). If the RULE can
$ fail, OR the F bit, and add the in affix (if any). 
$ A "jump" retrieves the bit from the destination, or clear if
$ it is not there.
$ PLUS retrieves the bit from T exit, MINUS from the F exit.
$ A compound block gets the T and F bits, and returns the front bit.
$
$ In compound block, the T exit at the semicolon is the T exit 
$  of the block; otherwise it is the actual value.
$ The F exit is the F exit of the block for non-heads, for a head
$  it is the T value of the next head, or the F exit of the block
$  if this is the last alternative.

$ OPEN of the compound block is followed by entries for all in/out/
$  /inout/local up to that block.
$   UTset, UFset <- final values, set when entering the region
$   UBset        <- to be computed, this is the final value
$   UAlt         <- value at the next alternative

$ the RULE stack is filled
$
$   RULE	*LADM
$   use		formal/local (affixes used)
$   TRUE	0/*RULE
$   FALSE	0/*RULE   (optional)
$   use/set	formal/local (affixes used/set if successful)
$
$   EXTENSION	tag (formal/global)
$   use		formal/local (used for filling)
$   TRUE	0/*RULE
$
$   CLASS	-
$   use		formal/local (in classification box)
$   ZONE	-
$   TRUE	0/*RULE
$   FALSE	0/*RULE  (the last zone has no FALSE label)
$
$   JUMP	*RULE
$   PLUS	0/*RULE
$   MINUS	0/*RULE
$
$   OPEN	number of saved flags; a JUMP points here
$   0		<flags for each relevant formal/local>
$   CLOSE	*RULE (the OPEN pair)
$
$   SCOLON	(semicolon to separate alternatives)
$   HEAD	(just after the head to indicate that this it is)

$ 'stack'(orepr=calibre,otype=ssel,flag,type,repr,tag)LLOC=().
$     for formal list, calibre and ssel is here; calibre=-1 if no selector list
$     type: Iformal ??? -- formal              tag: offset for in/out/inout/local
$           Ilocal  -- local                   otherwise -1
$           Imacro  -- textual replacement
$           Ilabel  -- label                   repr: RULE ptr

'table'RULE type=(
   0:ARULE,	$ cannot fail; extension; last zone $
   0:ERULE,	$ exit $
   0:QRULE,	$ can fail; zone $
   0:use,	$ use + offset $
   0:set,	$ set + offset
   0:TRUE,	$ true branch
   0:FALSE,	$ false branch
   0:JUMP,	$ jump + RULE
   0:PLUS,	$ +
   0:MINUS,	$ -
   0:HEAD,	$ following a head
   0:SCOLON,	$ semicolon
   0:OPEN,	$ region start
   0:CLOSE	$ region end
).

$ --------------------------------------- $
$ create LLOC stack entries for formals;
$  fill calibre and ssel for lists
'a'setup formal stack+>rtag-formal-type:
  $ this is called once for the rule
  scratch+LLOC,get adm+rtag+formal,
  (nxt:formal=0;
    get type+formal+type,
    (*-1->repr,type->type,formal->tag,0->flag->calibre->ssel *)LLOC,
    ((type=Iformal stack;type=Iformal table),
       get formal calibre+formal+calibre*LLOC,
       get formal ssel+formal+ssel*LLOC;
     +),get adm+formal+formal,:nxt).
'a'setup label+label>:
  $ compound block: if has a label, create the LLOC entry
  Q+Dlabel,must Qtag+label,
    (*0->repr,Ilabel->type,label->tag,0->flag->orepr->otype*)LLOC,
    >>LLOC->label;
  0->label.
'a'setup locals-local:
  $ compound block: create LLOC entry for each local
  Q+Dlocal,(nxt:Q+Dcolon;
    must Qtag+local,
    (*-1->repr,Ilocal->type,local->tag,0->flag->orepr->otype*)LLOC,
    :nxt);
   +.
$ ========================================================== $
'a'must Qlist+tag>+loc>:
  Qsave local->loc,must Qtag+tag.
'a'read selector+x>-tag:
  Q cons+x; $ this is the selector
  must Qtag+tag,get repr+tag+x. $ x>0 $
'f'final selector+>tag+>loc+x>:
  $ if L is a replacement for T in "macro+T[]" then
  $  use T*T=1 and not L*L
  is+loc,ssel*LLOC[loc]->x;was+LLOC+tag,ssel*LLOC[tag]->x;
  ssel*LADM[tag]->x.
  
$ ========================================================== $
'f'save Qbuffer+Qa>+Qb>+Qc>+Qd>:
   >>Qbuffer->Qa,Qsubstitute->Qb,save disc position+Qc+Qd.
'a'restore Qbuffer+>Qa+>Qb+>Qc+>Qd>:
  restore disc position+Qc+Qd,Qb->Qsubstitute,unstack to+Qbuffer+Qa.

'p'limit op+op>:
  Q+Dvlwb,Dvlwb->op;
  Q+Vvupd,Dvupb->op;
  Q+Dlwb,Dlwb->op;
  Q+Dupb,Dupb->op;
  Q+Dcalibre,Dcalibre->op.

'a'fsimple affix+aff>-x-tag-type-loc:
  $ read and store an affix; aff=1: #, aff=2: *; aff=0: otherwise
  Qcons+x,putQ+Dconst+x,0->aff;
  limit op+x,must Qtag+tag,putQ+x+tag,0->aff;
  Q+Dsub,putQ+Dsub,fsimple affix+aff,mustQ+Dbus,must Q tag+tag,
    read selector+x,putQ+Dbus+tag+Dconst+x;
  Q+Dnoarg,1->aff;
  must Qlist tag+tag+loc,0->aff,get type+tag+type,(=type=
    [Iconstant;Ipointer constant;Ivariable;Istatic var;Ipointer constant;
     Iformal in,Iformal out;Iformal inout;Ilocal],putQ+tag;
    [Istack;Itable;Istatic stack;Iformal table;Iformal table],
     $ T ==> T*T[>>T] $
     final selector+tag+loc+x,putQ+Dsub+Dupb+tag+Dbus+tag+Dconst+x;
    [Iformal repeat],putQ+tag,2->aff).

'a'match formal actual+>ftype+type>-tag:
  =ftype=
  [Iformal file;Iformal table;Iformal stack],
    must Qtag+tag,get type+tag+type,putQ+tag;
  [Iformal in;Iformal out;Iformal inout], fsimple affix+type.

'a'copy Qbuffer affix+>ptr>:
  =QBUFFER[ptr]= [Dplus;Dend],incr+ptr,putq+Dend;
  [Dconst],incr+ptr,putq+Dconst+QBUFFER[ptr],inct:ptr,:copy Qbuffer affix;
  putQ+Qbuffer[ptr],incr+ptr,:copy QBUFFER affix.

'variable'LLOC base=0.
$ the present rule is shifted by that much
'a'expand varargs+>repeat-formal-ftype-atype-lrep-cnt-qptr:
   $ repeat is the formal repeat affix of the macro
   $ head: macro+>a+*+>q:     
   $   call: macro+1+*,     * => *, q => formal of called
   $   call macro+1+T1+T2+* * => T1+T2+*, q => T1
  get adm+repeat+formal,>>LLOC->lrep,0->cnt,
  (nxt:get type+formal+ftype,match formal actual+ftype+atype,
    (atype=Iformal repeat; $ last argument is *
      (cnt=0,(* Lsubst->flag,0->repr,formal->tag,0->calibre->ssel,Imacro->type *)LLOC;+),
      (atype!=Inoarg;
       cnt!=0,putQ+Dnoarg;
       0->flag*LLOC,Ilocal->type*LLOC,putQ+>>LLOC),
      get adm+formal+formal,(formal=0,1->cnt,get adm+repeat+formal;+),
      (Q+Dplus,putQ+Dplus,:nxt;+)),
   $ we have read all actual affixes; replacement text for * is done
   (-aformal:cnt=0, $ first case, * is in top of QBUFFER
     QBUFFER->aformal,putQ+Dend,get adm+aformal+aformal,
     (nxt:formal=0; $ and then aformal=0
      (* Lsubst->flag,>>QBUFFER->repr,formal->tag,0->calibre->ssel,Imacro->type *)LLOC,
      $ get repr+aformal+x,add+x+LLshift+x, putQ+x+Dend
      putQ+repr*LADM[aformal]+Dend,
      get adm+formal+formal,get adm+aformal+aformal,:nxt);
   putQ+Dend, $ second case, lrep is the * affix in LLOC
      repr*LLOC[lrep]->qptr,incr+qptr,
      $ qptr looks at the replacement text of *
      (nxt:formal=0;
       next+LLOC+lrep,(flag*LLOC[lrep]=Lsubst,>>QBUFFER->repr*LLOC[lrep];+),
       copy QBUFFER affix+qptr,get adm+formal+formal,:nxt)).

'a'macro arguments+>tag-formal-type-x:
   $ from the corrent position of LLOC make "setup formal stack"
   get adm+tag+formal,(nxt:formal=0;
   (* Lsubst->flag,>>QBUFFER->repr,formal->tag,0->calibre->ssel,Imacro->type *)LLOC,
   mustQ+Dplus,get type+formal+type,
   (type=Iformal repeat,expand varargs+formal;
    match formal actual+type+x,
      (x=Inoarg,0->flag*LLOC,-1->repr*LLOC,Ilocal->type*LLOC;
       putQ+Dend),
      get adm+formal+formal,:nxt)).


'a'expand macro+>tag-lptr-Qa-Qb-Qc-Qd-Lptr:
  >>Qbuffer->Qa,LLshift->Qb, $ plus disc position $
  >>LLOC->Lptr,macro arguments+tag, $ this sets up LLOC for formals $
    save disc position+Qc+Qd,goto macro+tag,
    subtr+Lptr+<<LLOC+LLshift,next+LLOC+LLshift,
    $ macro rule body +Lptr $
    restore disc position+Qc+Qd,
  Qb->LLshift,unstack to+QBUFFER+Qa.

  unstack to LLOC+LLOC base,Ql->LLOC base,
  restore Qbuffer+Qa+Qb+Qc+Qd.



'end'



$ macro substitution ---------------------------------------- $
$  LLOC is shifted by Qsubstitute
$    when we see a formal affix, we return the replaced entry
$    there is a problem with ssel, as it is not forwarded. Example:
$    'a'macro+[]t[]+>x: x->t. 'stack'(b)S.
$    "macro+S+0" is OK (formal t and actual S match), 
$    substitution "0->S" is incorrect (S has no ssel).
$    Actually, 'a'macro+[]t[]+>x: x->t*t. is correct
$    Check this in drules.ale. Also, exact match is
$    necessary in macros.

'a'macro limit+x>: 0->x.

'a'macro arguments+>tag-formal-type-x:


'a'expand macro+>head+>tag





'end'

