$ node generation
'pragmat'module="node".
$ HEADER ***************************************************** $
'a'generate rule+>rtag.

$ BODY ******************************************************* $
'pragmat'if=compile,prototype=none.
$
$ generate nodes for rules, also apply some optimization.
$ node types:
$  -  call
$  -  extension
$  -  classifier
$  -  head / tail
$ A call has zero, one or two exits; a classifier has one exit
$  for each alternative (one of them must succeed); an
$  extension has one exit. Eventually, each exit is a label of
$  some node.
$ There are three no-op nodes: +, -, jump. After assigning labels
$  the are left out. As a final optimization, identical nodes can
$  be merged, this can trigger further merging.
$ ----------------------------------------------------------- $
$ Data flow is recalculated for formal in/out/inout and local
$  variables to see if set variables are actually used; if not
$  then the assignment can be skipped. It requires traversing
$  the flow backwards.
$ Each compound block stores a flag for all relevant formal/local
$  -- at entry v has a value and it is used
$     Example: at 2 this flag is set and "2->v" cannot be
$     optimized out:
$        1->v, (l1: use v, (l2:condition,:l1; 2->v,:l2))
$              ^1          ^2
$ 
$ A backward pass computes it. Suppose we are at the RULE or
$ EXTENSION and  have this bit at the (potential) T and the F
$ exits. I the RULE is an 'exit', clear. Otherwise get it
$ from T, modify by the out affix (if any). If the RULE can
$ fail, OR the F bit, and add the in affix (if any). 
$ A "jump" retrieves the bit from the destination, or clear if
$ it is not there.
$ PLUS retrieves the bit from T exit, MINUS from the F exit.
$ A compound block gets the T and F bits, and returns the front bit.
$
$ In compound block, the T exit at the semicolon is the T exit 
$  of the block; otherwise it is the actual value.
$ The F exit is the F exit of the block for non-heads, for a head
$  it is the T value of the next head, or the F exit of the block
$  if this is the last alternative.

$ OPEN of the compound block is followed by entries for all in/out/
$  /inout/local up to that block.
$   UTused, UFused <- final values, set when entering the region
$   Uflag          <- to be computed, this is the final value
$   Ualt           <- value at the next alternative

$ the RULE stack is filled
$
$   NODE	<NODE entry>
$   use		formal/local 
$   FALSE	0/*RULE (label, optional)
$   use/set/spare formal/local (if true)
$   TRUE	0/*RULE (label)
$   SINK
$
$   JUMP	*LLOC entry
$   PLUS	0/*RULE
$   MINUS	0/*RULE
$
$   OPEN	number of saved flags; a JUMP points here
$   0		<flags for each relevant formal/local>
$
$   CLOSE	*RULE (the OPEN pair)
$
$   SCOLON	0 (semicolon to separate alternatives)
$   HEAD	0 (just after the head to indicate that this it is)

$ 'stack'(orepr=calibre,otype=ssel,flag,type,repr,tag)LLOC=().
$  for formal list, calibre and ssel is here; calibre=-1 if no selector list
$  type: Iformal XXX -- formal              tag: offset for in/out/inout/local
$        Ilocal  -- local                   otherwise -1
$        Imacro  -- textual replacement     repr: QBUFFER ptr, tag: formal (LADM)
$        Ilabel  -- label                   repr: RULE ptr

'pragmat'require=("disc","tags","types","display","buffer"
).

$ definitions from buffer
'stack'(flag,data)RULE.
'a'push RULE+>flag+>data.

'constant'
  Umark		= 0x100000,
  Uopen		= 0x100001, $ followed by many 0 for formal/local flags
  Uclose	= 0x100002, $ points back to Uopen
  Uhead		= 0x100003, $ after the head of an alternative
  Unode		= 0x100004, $ rule,extension
  Utrue		= 0x100005, $ true exit
  Ufalse	= 0x100006, $ false exit
  Usink		= 0x100007, $ 'exit' rule
  Uplus		= 0x100008, $ +
  Uminus	= 0x100009,
  Ujump		= 0x10000a,
  Ubox		= 0x10000b,
  Uuse		= 0x100011, $ formal/local used here
  Uset		= 0x100012, $ formal/local set
  Uspare	= 0x100013, $ formal/local set but not used later
  Usemicolon	= 0x10000f.

$ --------------------------------------- $
$ create LLOC stack entries for formals;
$  fill calibre and ssel for lists
'a'setup formal stack+>rtag-formal-type:
  $ this is called only once for the rule
  scratch+LLOC,get adm+rtag+formal,
  (nxt:formal=0;
    get type+formal+type,
    (*-1->repr,type->type,formal->tag,0->flag->calibre->ssel *)LLOC,
    ((type=Iformal stack;type=Iformal table),
       get formal calibre+formal+calibre*LLOC,
       get formal ssel+formal+ssel*LLOC;
     +),get adm+formal+formal,:nxt).
'a'setup label+label>:
  $ compound block: if has a label, create the LLOC entry
  Q+Dlabel,must Qtag+label,
    (* 0->repr,Ilabel->type,label->tag,0->flag->orepr->otype*)LLOC,
    >>LLOC->label;
  0->label.
'a'setup locals-local:
  $ compound block: create LLOC entry for each local
  Q+Dlocal,(nxt:Q+Dcolon;
    must Qtag+local,
    (*-1->repr,Ilocal->type,local->tag,0->flag->orepr->otype*)LLOC,
    :nxt);
  +.
$ rule structure =========================================== $
'a'start range+>label+rloc>-loc-cnt:
  push RULE+Uopen+0,>>RULE->rloc,(is+label,rloc->repr*LLOC[label];+),
  <<LLOC->loc,0->cnt,(nxt:loc>>>LLOC;
    (=type*LLOC[loc]=
     [Iformal in;Iformal out;Iformal inout;Ilocal],
        incr+cnt,push RULE+0+loc,
        (repr*LLOC[loc]<0,cnt->repr*LLOC[loc];
         repr*LLOC[loc]=cnt;
         internal error+_line_);
     +),
    next+LLOC+loc,:nxt).
'a'close range+>rloc:
  push RULE+Uclose+rloc.
$ use/set values ------------------------------------ $
'constant'
  Uin		=0x234501,
  Uout		=0x234502,
  Uinout	=0x234503,
  Uslicein	=0x234511,
  Usliceout	=0x234512,
  Usliceinout	=0x234513.
'f'utype to slice+>in+out>:add+in+0x10+out.
'q'in utype+>utype-x:bool and+utype+1+x,x!=0.
     $ used before the call
'q'out utype+>utype-x:bool and+utype+2+x,x!=0.
     $ used after the call
$ OPTIMIZATION ====================================== $
$ read the rule, populate the RULE stack, 
$   traverse it, then read the rule again.
$ this part populates RULE; rule names start with "g"

$ macro replacement --------------------------------- $
'a'g expand macro+>tag-loc-Qa-Qb-dpos-dnum-mpos-mnum:
  $ tag has the rmacro flag; it behaves as a compound block
  $ formals of the macro are on LLOC with type Imacro or Ilocal
  >>LLOC->loc,
  macro call head+tag+Qa+Qb,save disc position+dpos+dnum,
    search macro rule+tag+mpos+mnum,restore disc position+mpos+mnum,
    g rule body,mustQ+Dpoint,
  restore disc position+dpos+dnum,macro call tail+Qa+Qb,
  unstack to+LLOC+loc.
$ extension ----------------------------------------- $
'a'g transport list:
  g simple affix+Uin+#,$ skip destination
    (nxt:Q+Dto,(Qcons+#;must Qtag+#),:nxt;+),
    (Q+Dextension;Qahead+Dend;:g transport list).
'a'g extension:
  must Qtag+#,push RULE+Unode+0,g transport list,push RULE+Utrue+0.
$ classification ------------------------------------ $
'a'g read box:
    push RULE+Unode+0,g simple affix+Uin+#,push RULE+Utrue+0,
    push RULE+Ubox+0,mustQ+Dbox.
'a'g classification-last:
    mustQ+Darea,Qskip+Darea,
    push RULE+Unode+0,push RULE+Ufalse+0,>>RULE->last,push RULE+Utrue+0,
    push RULE+Uhead+0,g alt tail,
    (Q+Dsemicolon,push RULE+Usemicolon+0,:g classification;
     $ the last area does not have false branch
     Umark->flag*RULE[last]).
$ actual rule --------------------------------------- $
'a'g handle affix+>tag+>utype:
   (in utype+utype,push RULE+Uuse+repr*LLOC[tag];+),
   (out utype+utype,(utype>=Uslicein,extend BUFFER+Uuse;extend BUFFER+Uset),
     extend BUFFER+repr*LLOC[tag];+).
'a'g handle vararg block+>ptr:
   $ ptr points to the * formal affix of the rule, use that block
   (nxt: =type*LLOC[ptr]=
   [Ilabel],+; $ this is the last one
$   [Iformal in],g handle affix+ptr+Uin,next+LLOC+ptr,:nxt;
$   [Iformal out],g handle affix+ptr+Uout,next+LLOC+ptr,:nxt;
   [Iformal out;Iformal inout],g handle affix+ptr+Uout,next+LLOC+ptr,:nxt;
   next+LLOC+ptr,:nxt).

'p'g limit:
   Q+Dvlwb;Q+Dvupb;Q+Dlwb;Q+Dupb;Q+Dcalibre.
'a'g simple affix+>utype+repeat>-tag-type:
   Qcons+#,0->repeat;
   g limit,must Qtag+#,0->repeat;
   Q+Dsub,utype to slice+utype+type,g simple affix+type+repeat,
     mustQ+Dbus,must Qtag+#,(Qcons+#;must Qtag+#);
   Q+Dnoarg,0->repeat;
   must Qtag+tag,get type+tag+type,
     (=type=
      [Iformal repeat],tag->repeat; $ * affix $
      [Iformal in;Iformal out;Iformal inout;Ilocal],
         g handle affix+tag+utype,0->repeat;
      0->repeat).

'a'g match formal actual+>ftype+repeat>-tag-type:
  $ we are expecting an affix of type "ftype"
  $ we can get the formal affix *
  =ftype=
  [Iformal file;Iformal table;Iformal stack], 
     must Qtag+tag,get type+tag+type,
     (type=Iformal repeat,tag->repeat;0->repeat);
  [Iformal shift], must Qtag+repeat;
  [Iformal in],    g simple affix+Uin+repeat;
  [Iformal out],   g simple affix+Uout+repeat;
  [Iformal inout], g simple affix+Uinout+repeat;
  internal error+_line_.

'a'g actual rule+>tag-formal-ftype-repeat-frep:
  $ collect which formal/local this rule uses and sets
  $  Uuse <#counter>
  $ before calling, collect in and inout (plus slice)
  $ after return, set out and inout (plus slice)
  $ collect out/inout affixes in BUFFER, and copy from
  $  there to RULE after the Ufalse entry (if the rule
  $  can fail).
  $ If * is an actual affix, use and set all formal
  $  after the *, except for 'get affix blockno'
  push RULE+Unode+0,scratch+BUFFER,0->repeat->frep,get adm+tag+formal,
  (nxt:Q+Dplus,get type+formal+ftype,
    (ftype=Iformal repeat,
      get adm+formal+formal,formal->repeat,get type+formal+ftype;+),
    g match formal actual+ftype+frep,
    get adm+formal+formal,(formal=0,repeat->formal;+),:nxt;
  +),
  $ frep: the last actual affix is *; this is a LLOC pointer
  (frep=0;
   (is tag flag+tag+rshiftrule,tag!=Xshift affix),+;
   g handle vararg block+frep),
  (is tag flag+tag+rcan fail,push RULE+Ufalse+0;+),
  <<BUFFER->frep,
  (nxt-flag:frep>>>BUFFER;
    BUFFER[frep]->flag,incr+frep,push RULE+flag+BUFFER[frep],incr+frep,:nxt),
  (is tag flag+tag+rno return,push RULE+Usink+0;push RULE+Utrue+0).
$ structure ----------------------------------------- $
'a'g compound-loc:
  >>LLOC->loc,g rule body,unstack to+LLOC+loc.

'a'g alt sequence:
  g member,push RULE+Uhead+0,g alt tail,
    (Q+Dsemicolon,push RULE+Usemicolon+0,:g alt sequence;+).

'a'g alt tail:
  Q+Dcomma,g member,:g alt tail;+.

'a'g member-tag:
  Q+Dopen,g compound,mustQ+Dclose;
  Q+Dextension,g extension;
  Q+Djump,must Qtag+tag,push RULE+Ujump+repr*LLOC[tag];
  Q+Dplus,push RULE+Uplus+0;
  Q+Dminus,push RULE+Uminus+0;
  must Qtag+tag,(is tag flag+tag+rmacro,g expand macro+tag;
                 g actual rule+tag).

'a'g rule body-label-rloc:
  setup label+label,$ add label to LLOC, if any $
  setup locals,     $ add locals to LLOC, some of them before label
  start range+label+rloc,
   (Q+Dbox,g read box,g classification;
    g alt sequence),
  close range+rloc.

$ traversing RULE stack ============================= $
$ flags for formal/local stored variables
'constant'
  Ufinal	= 0x01, $ final flag, 0: not used afterward, 1: used
  UTused	= 0x02, $ final value, used at true exit
  UFused	= 0x04, $ final value, used at false exit
  Uflag		= 0x08, $ running flag
  Ualt		= 0x10, $ usage at the head of the next alternative
  Uzero		= 0x20. $ this bit is always zero

'variable'Ufinal changed=0.

'a'set RULE flag+>base+>off+>v:
  addmult+off+<>RULE+base+base,bool or+flag*RULE[base]+v+flag*RULE[base].
'a'clear RULE flag+>base+>off+>v:
  addmult+off+<>RULE+base+base,bool invert+v+v,bool and+flag*RULE[base]+v+flag*RULE[base].  
'q'is RULE flag+>base+>off+>v-x:
  addmult+off+<>RULE+base+base,bool and+flag*RULE[base]+v+x,x!=0.

'a'copy Uf1 to Uf2+>base+>Uf1+>Uf2-off:
  $ at the end of the region copy UF to Ualt (the last alternative fails)
  $ at the end of an alternative copy UT to Uflag
  1->off,(nxt:is RULE flag+base+off+Umark; $ no more stored value $
    (is RULE flag+base+off+Uf1,set RULE flag+base+off+Uf2;
         clear RULE flag+base+off+Uf2),incr+off,:nxt).
'a'merge Uf1 to Uf2+>base+>Uf1+>Uf2-off:
  1->off,(nxt:is RULE flag+base+off+Umark;
    (is RULE flag+base+off+Uf1,
       (Uf2!=Ufinal;is RULE flag+base+off+Uf2;1->Ufinal changed),
       set RULE flag+base+off+Uf2;+),
    incr+off,:nxt).
'a'copy jump Uf+>from+>to-off:
  $ copy final flags from -> to; clear local affixes
  1->off,(nxt:is RULE flag+from+off+Umark;
    (is RULE flag+from+off+Ufinal,set RULE flag+to+off+Uflag;
     clear RULE flag+to+off+Uflag),incr+off,:nxt),
  (nxt:is RULE flag+to+off+Umark;
       clear RULE flag+to+off+Uflag,incr+off,:nxt).

'a'set flags for region+>base+>region+>head-off:
  $ region is a pointer to an inner region; set UT/UF used flags
  $  UT is coming from Uflag, UF is from head (=Ualt or =UFused)
  $ flags can only increase.
  1->off,(nxt:is RULE flag+base+off+Umark;
     (is RULE flag+base+off+Uflag,set RULE flag+region+off+UTused;+),
     (is RULE flag+base+off+head,set RULE flag+region+off+UFused;+),
     clear RULE flag+region+off+Uflag,incr+off,:nxt).
'a'recover flags from region+>base+>region-off:
  $ when the region is done, retrieve Uflags from the region
  1->off,(nxt:is RULE flag+base+off+Umark;
    (is RULE flag+region+off+Uflag,set RULE flag+base+off+Uflag;
      clear RULE flag+base+off+Uflag),incr+off,:nxt).

'a'set flags for rule+>rtag-base-formal-type-cnt:
   $ set the UTused, UFused flags for the rule.
   $  UFused = 0 (as no set is required for false exit)
   $  UTused = 1 for out and inout affixes
   get adm+rtag+formal,0->cnt,data*RULE->base,$ flag*RULE=Uclose $
   (nxt:formal=0;
     get type+formal+type,(=type=
       [Iformal in],incr+cnt;
       [Iformal out;Iformal inout],incr+cnt,set RULE flag+base+cnt+UTused;
       +),
     get adm+formal+formal,:nxt).
$ - - - - - - - - - - - - - - - - - - - - - - - - - - $
'variable' Uptr=0.
'p'B+>x: flag*RULE[Uptr]=x,previous+RULE+Uptr.
'p'Bdata+>x+d>: flag*RULE[Uptr]=x,data*RULE[Uptr]->d,previous+RULE+Uptr.
'a'Breplace+>new-ptr:Uptr->ptr,next+RULE+ptr,new->flag*RULE[ptr].

$ Uptr is just before Uclose; UT,UF flags are set
'a'Uregion+>base:
  copy Uf1 to Uf2+base+UFused+Ualt,
  (nxt:Ualternative+base,copy Uf1 to Uf2+base+Uflag+Ualt,
    (B+Usemicolon,:nxt;
     B+Ubox,(U actual rule+base+UFused;internal error+_line_);
     +)),
  $ skip the storeage area $
  (nxt:B+Uopen;previous+RULE+Uptr,:nxt),
  $ set the final flags for this region
  merge Uf1 to Uf2+base+Uflag+Ufinal.

'p'U actual rule+>base+>Uf-cnt:
  $ 'exit' clears all flags; otherwise keep Uflag
  $ Uf specifies the false branch
  (B+Utrue;B+Usink,copyUf1 to Uf2+base+Uzero+Uflag),
    (nxt:Bdata+Uuse+cnt,set RULE flag+base+cnt+Uflag,:nxt;
         Bdata+Uset+cnt,
              (is RULE flag+base+cnt+Uflag;Breplace+Uspare),
              clear RULE flag+base+cnt+Uflag,:nxt;
         Bdata+Uspare+cnt,
              (is RULE flag+base+cnt+Uflag,Breplace+Uset;+),
              clear RULE flag+base+cnt+Uflag,:nxt;
         B+Umark,:nxt; $ skip it over
         B+Ufalse, merge Uf1 to Uf2+base+Uf+Uflag,:nxt;
         B+Unode;
         internal error+_line_).
'p'U member+>base+>Uf-ptr:
  Bdata+Ujump+ptr, $ptr points to Uopen; copy Uflags from there
     copy jump Uf+ptr+base;
  B+Uplus,copy Uf1 to Uf2+base+UTused+Uflag;
  B+Uminus,copy Uf1 to Uf2+base+Uf+Uflag;
  U actual rule+base+Uf;
  Bdata+Uclose+ptr,$ set up flags for this region
     set flags for region+base+ptr+Uf,
     Uregion+ptr,recover flags from region+base+ptr.
'a'Ualternative+>base:
  copy Uf1 to Uf2+base+UTused+Uflag,(nxt:
    B+Uhead,(Umember+base+Ualt;internal error+_line_);
    Umember+base+UFused,:nxt;
    +).
$ --------------------------------------------------- $
$ diagnostics: compute mentioned/used flags
'constant'
  UDuse		= 0x100, $ affix in Uuse
  UDset		= 0x200. $ affix in Uset

'a'merge DU flags+>base+>region-off:
  1->off,(nxt:is RULE flag+base+off+Umark;
    (is RULE flag+region+off+UDuse,set RULE flag+base+off+UDuse;+),
    (is RULE flag+region+off+UDset,set RULE flag+base+off+UDset;+),
    incr+off,:nxt).
'p'DU rule+>base-cnt:
  (B+Utrue;B+Usink),(nxt:
    Bdata+Uuse+cnt,set RULE flag+base+cnt+UDuse,:nxt;
    Bdata+Uset+cnt,set RULE flag+base+cnt+UDset,:nxt;
    B+Uspare,:nxt;
    B+Umark,:nxt;
    B+Ufalse,:nxt;
    B+Unode;
    +).
'p'DU member+>base-ptr:
  B+Ujump;B+Uplus;B+Uminus;DU rule+base;
  Bdata+Uclose+ptr,DU region+ptr,merge DU flags+base+ptr.
'a'DU alternative+>base:
  B+Uhead,(DU member+base;+);
  DU member+base,:DU alternative;
  +.
'a'DU region+>base:
  (nxt:DU alternative+base,(B+Usemicolon,:nxt;
                       B+Ubox,(DU rule+base;+);+)),
  $ skip storage region $
  (nxt:B+Uopen;previous+RULE+Uptr,:nxt).
'a'compute DU flags-ptr:
  >>RULE->Uptr,(Bdata+Uclose+ptr;internal error+_line_),
  DU region+ptr.
$ for a formal/local
$  UDuse:   the variable has been used somewhere
$  Ufinal:  the original value is used
$  UDset:   a value has been assigned to it
$ formal in/inout: Ufinal should be set
$ formal inout:  Udset=0: can be in
$ local: complain if UDset but not UDuse;
$        places where Uuse => Uspare

$ =================================================== $
'a'traverse RULE+>tag-ptr:
  set flags for rule+tag,
  (nxt: >>RULE->Uptr,(Bdata+Uclose+ptr;internal error+_line_),
        0->Ufinal changed,Uregion+ptr,(Ufinal changed=0;:nxt)).



'a'g optimize rule+>tag:
  scratch+RULE,setup formal stack+tag,
  g rule body,mustQ+Dpoint,
  $========$
  traverse RULE+tag.
$ --------------------------------------------------- $

'q'skip rule generation+>tag:
  is tag flag+tag+tpublic,-;
  is tag flag+tag+rmacro;
  is tag flag+tag+tused,-;
  +.

'a'generate rule+>tag-dpos-dnum:
  $ if macro and not public, dont't anything
  skip rule generation+tag,Qskip+Dpoint;
  save disc position+dpos+dnum,g optimize rule+tag,
  +.
  

'root'+.

'pragmat'endif=compile.

'end'

