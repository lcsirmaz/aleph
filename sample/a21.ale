'pragmat'title="simple symbolic derivation".
$ formally derivate a formula specified as structure
’stack’[10](op,left,right)expr[].
’table’operator[]=("+":plus op, "-":min op, "*":tim op,
    "/":div op, "^":pow op,
    "log ": log op $ log(f) is represented as 0 "log" f $),
   const[]=("0": c zero, "1": c one, "2": c two),
   var[]=("x": x var).
’action’derivate+>e+de>-f-df-g-dg-n1-n2-n3:
   was+const+e, c zero->de;
   was+var+e,   c one->de;
   left*expr[e]->f, right*expr[e]->g,
   derivate+f+df, derivate+g+dg,
   (=op*expr[e]=
    [plus op],M+df+plus op+dg+de;
    [min op], M+df+min op+dg+de;
    [tim op], M+df+tim op+g+n1,M+f+tim op+dg+n2,
                 M+n1+plus op+n2+de;
    [div op], M+df+tim op+g+n1,M+f+tim op+dg+n2,
                 M+n1+min op+n2+n1,M+g+pow op+c two+n2,
                 M+n1+div op+n2+de;
    [log op], M+dg+div op+g+de;
    [pow op], M+g+min op+c one+n1,M+f+pow op+n1+n1,
              M+df+tim op+g+n2,M+n2+tim op+n1+n1,
              M+c zero+log op+f+n2,M+n2+tim op+dg+n2,
              M+f+pow op+g+n3,M+n2+tim op+n3+n2,
              M+n1+plus op+n2+de
    ).
’action’M+>left+>op+>right+res>:
  (*left->left, op->op,right->right*) expr, >>expr->res.
’action’print expr+>e:
   print expr1+e,print char+newline.
’action’print expr1+>e:
   was+const+e,print string+const+e;
   was+var+e,print string+var+e;
   print char+/(/,(= op*expr[e] =
     [plus op; min op; tim op; div op; pow op],
       print expr1+left*expr[e];+),
     print string+operator+op*expr[e],
     print expr1+right*expr[e],print char+/)/.
$ create function representations: x^x, log x/x, log x
’stack’expr=((xvar->left->right,pow op->op): x to x,
             (log x->left, xvar->right,div op->op): log x by x,
             (c zero->left,xvar->right,log op->op): log x).
$ compute the first and second derivative and print
’action’test+>f-df-ddf:
   derivate+f+df,derivate+df+ddf,
   print expr+f,print expr+df,print expr+ddf.
’root’test+x to x, test+log x by x, test+log x.
’end’

