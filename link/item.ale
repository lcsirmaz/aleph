$ item
$ HEADER ************************************************ $
'pragmat'module="item".
$ read al items from the .ice file

'f'get calibre+>item+cal>.
'f'get ssel+>item+ssel>.
'a'head section.
'a'skip head section.
'a'item section.
'a'skip item section.

$ item flags $
'constant'
  tpublic	= 0x0004, $ public 
  timported	= 0x0008, $ imported
  texternal	= 0x0010, $ external
$ rule flags
  rside effect	= 0x0100, $ 'a','p'
  rcan fail	= 0x0200, $ 'q','p'
  rno return	= 0x0400, $ 'e'
  rvararg	= 0x8000, $ has formal *
  routvararg	=0x10000, $ has out formal vararg
  rtace       =0x1000000, $ trace=on, print when enter the rule
  rcount      =0x2000000, $ count=on, profiling
  rbounds     =0x4000000, $ bound checks
$ rule types
  rfunc		=0,
  raction	=rside effect,
  rque		=rcan fail,
  rpred		=rside effect|rcan fail,
  rexit		=rno return,
  rtype		=rside effect|rcan fail|rno return.


'stack'ITEM.

$ BODY *************************************************** $
'pragmat'if=compile.

'pragmat'require=("lexical","error").

'stack'[20](flag,type,tag,lineno,adm,repr)ITEM.
$ type: Irule      adm => formals
$       variable   adm => expression
$       list       calibre,ssel

$ variables for a module $
'variable'
   base lineno=0,  $ base lineno, this is added to the given lineno $
   base item=0.    $ ITEM[base] describes this module

'stack'[10](count,width=calibre,link=data=ssel)AUX.

'a'push AUX+>x: (* x->data *)AUX.

'variable'link formals=0. $ link all formals $

'f'get calibre+>item+cal>:
   calibre*AUX[adm*ITEM[item]]->cal.
'f'get ssel+>item+ssel>:
   ssel*AUX[adm*ITEM[item]]->ssel.

'q'compare formals+>p1+>p2-w:
   count*AUX[p1]=count*AUX[p2],
   width*AUX[p1]->w,width*AUX[p2]=w,(nxt:w=0;
     incr+p1,incr+p2,data*AUX[p1]=data*AUX[p2],decr+w,:nxt).

'a'search formals+>ptr>-link:
   link formals->link,
   (nxt:link=0,link formals->link*AUX[ptr],ptr->link formals;
    compare formals+link+ptr,previous+AUX+ptr,unstack to+AUX+ptr,link->ptr;
    link*AUX[link]->link,:nxt).

'a'store formal affixes+formals>-cnt-type-x:
   must+Tconst+cnt,(*cnt->count->width,0->link *)AUX,>>AUX->formals,
     (nxt:cnt=0;
        decr+cnt,must+Ttype+type,push AUX+type,
        ((type=Iformal stack;type=Iformal table),
        incr+width*AUX[formals],must+Tconst+x,push AUX+x,
        incr+width*AUX[formals],must+Tconst+x,push AUX+x;+),:nxt),
     search formals+formals.

'a'store list bounds+bounds>-cal-ssel:
   must+Tconst+cal,must+Tconst+ssel,(* cal->calibre,ssel->ssel*)AUX,
   >>AUX->bounds.

'f'check item ID+>n:
   addmult+n+<>ITEM+base item+n,(n=>>ITEM;corrupted obj file+_line_).

'a'read item-ID-lineno:
   (* 0->flag->type->lineno->tag->adm->repr *)ITEM,
   must+Ttype+type*ITEM,must+Titem+ID,check item ID+ID,
   must+Tconst+flag*ITEM,must+Tconst+lineno,
   (lineno<=0;add+base lineno+lineno+lineno),lineno->lineno*ITEM,
   (=type*ITEM=
    [Irule], store formal affixes+adm*ITEM;
    [Istack;Itable;Istatic stack], store list bounds+adm*ITEM;
    +),
   must+Tstring+tag*ITEM.
'a'item section:
   R+Dpoint; read item,:item section.
'a'skip item section:
   R+Dpoint;next symbol,:skip item section.

$ head section ******************************************* $
'a'head section:+.
'a'skip head section:+.  

'root'+.
'pragmat'endif=compile.
'end'
