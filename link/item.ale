$ item
$ HEADER ************************************************ $
'pragmat'module="item".
$ read al items from the .ice file

'f'get item+>idx+item>:
   addmult+idx+<>ITEM+base item+item.

'f'get calibre+>item+cal>,get ssel+>item+ssel>.
'a'put vupb+>item+>x,put vlwb+>item+>x.
'q'is item flag+>item+>flag.
'a'set item flag+>item+>flag.
'a'clear item flag+>item+>flag.

'a'head section.
'a'skip head section.
'a'item section.
'a'skip item section.

'f'find lineno+>item+line>+str>+module>.

$ item flags $
'constant'
  tpublic	= 0x0004, $ public 
  timported	= 0x0008, $ imported
  texternal	= 0x0010, $ external
$ constant, pointer constant
  tvalue	= 0x0020, $ repr contains the final value
  teval		= 0x0040, $ constant expression is under evaluation
$ rule flags
  rside effect	= 0x0100, $ 'a','p'
  rcan fail	= 0x0200, $ 'q','p'
  rno return	= 0x0400, $ 'e'
  rvararg	= 0x8000, $ has formal *
  routvararg	=0x10000, $ has out formal vararg
  rtrace      =0x1000000, $ trace=on, print when enter the rule
  rcount      =0x2000000, $ count=on, profiling
  rbounds     =0x4000000, $ bound checks
$ rule types
  rfunc		=0,
  raction	=rside effect,
  rque		=rcan fail,
  rpred		=rside effect|rcan fail,
  rexit		=rno return,
  rtype		=rside effect|rcan fail|rno return.


'stack'(flag,type,tag,lineno,adm,repr)ITEM.
'variable'base item.

$ BODY *************************************************** $
'pragmat'if=compile.

'pragmat'require=("lexical","error").

'stack'[20](flag,type,tag,lineno,adm,repr)ITEM.
$ type: Irule      adm => formals
$       variable   adm => expression (to be filled)
$       list       adm => vlwb,vupb,calibre,ssel

'q'is item flag+>item+>flag-x:
  bool and+flag*ITEM[item]+flag+x,is+x.
'a'set item flag+>item+>flag:
  bool or+flag*ITEM[item]+flag+flag*ITEM[item].
'a'clear item flag+>item+>flag-mask
  bool invert+flag+mask,bool and+mask+flag*ITEM[item]+flag*ITEM[item].

'constant'
  tglobal	= tpublic|timported|texternal,
  titem mask	= ~(tglobal|rtype|rvararg|routvararg|
                        rtrace|rcount|rbounds).
  
$ AUX stack ---------------------------------------------- $
'stack'[10](vlwb,vupb=count,width=calibre=item,link=data=ssel)AUX.
$ adm*rule => <count,width,link>
$  followed by <count> many formal types; formal lists have two
$  additional entries: calibre and ssel (<width> is the total 
$  width of the list)
$  the same formal list is stored only once (linear search)
$ adm*list => <vlwb,vupb,calibre,ssel>
$  where vlwb,vupb will be used to store size estimate and filling
$  size
$ 

'a'push AUX+>x: (* x->data *)AUX.

$ compatibility ------------------------------------------ $
'table'MESSAGE=(
  "%p: incompatible types at %i and %i" :incompatible global types,
  "%p: mixing external at %i and %i"    :incompatible external,
  "%p: doubly defined at %i and %i"     :doubly defined
).
$ - - - - - - - - - - - - - - - - - - - - - - - - - -  $
'q'stack size mismatch+>item1+>item2-x1-x2:
  (get ssel+item1+x1,get ssel+item2+x2,x1!=x2);
  (get calibre+item1+x1,get calibre+item2+x2,x1!=x2).

'q'incompatible types+>item1+>item2-type:
  (type*ITEM[item1]->type,type!=type*ITEM[item2]);
  type=Irule,adm*ITEM[item1]!=adm*ITEM[item2];  $ have different formal list $
  (type=Istack;type=Itable;type=Istatic stack),stack size mismatch+item1+item2;
  -.

'a'check compatibility+>tag+>item1+>item2:
   incompatible types+item1+item2,error+incompatible global types+tag+item1+item2;
   is item flag+item1+texternal,
     (is item flag+item2+texternal;error+incompatible external+tag+item1+item2);
   is item flag+item2+texternal,error+incompatible external+tag+item2+item1;
   is item flag+item1+tpublic,
     (is item flag+item2+tpublic,error+doubly defined+tag+item1+item2;+);
   is item flag+item2+tpublic,put tag definition+tag+item2;
   +.

'a'enter item+>item-tag-def:
  (is item flag+item+tglobal,-); $ if not global, don't do anything
  tag*ITEM[item]->tag,get tag definition+tag+def,
  (def=0,put tag definition+tag+item;
   check compatibility+tag+def+item).

$ module header ---------------------------------------- $
'variable'link formals=0. $ link all formals $

'f'get calibre+>item+cal>:
   calibre*AUX[adm*ITEM[item]]->cal.
'f'get ssel+>item+ssel>:
   ssel*AUX[adm*ITEM[item]]->ssel.
'a'put vlwb+>item+>x:
   x->vlwb*AUX[adm*ITEM[item]].
'a'put vupb+>item+>x:
   x->vupb*AUX[adm*ITEM[item]].

$ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - $
'q'compare formals+>p1+>p2-w:
   count*AUX[p1]=count*AUX[p2],
   width*AUX[p1]->w,width*AUX[p2]=w,(nxt:w=0;
     incr+p1,incr+p2,data*AUX[p1]=data*AUX[p2],decr+w,:nxt).

'a'search formals+>ptr>-link:
   link formals->link,
   (nxt:link=0,link formals->link*AUX[ptr],ptr->link formals;
    compare formals+link+ptr,previous+AUX+ptr,unstack to+AUX+ptr,link->ptr;
    link*AUX[link]->link,:nxt).

'a'store formal affixes+formals>-cnt-type-x:
   must+Tconst+cnt,(*cnt->count->width,0->link *)AUX,>>AUX->formals,
     (nxt:cnt=0;
        decr+cnt,must+Ttype+type,push AUX+type,
        ((type=Iformal stack;type=Iformal table),
        incr+width*AUX[formals],must+Tconst+x,push AUX+x,
        incr+width*AUX[formals],must+Tconst+x,push AUX+x;+),:nxt),
     search formals+formals.

'a'store list bounds+bounds>-cal-ssel:
   must+Tconst+cal,must+Tconst+ssel,
   (* 0->vlwb->vupb,cal->calibre,ssel->ssel*)AUX,
   >>AUX->bounds.

'f'check item ID+>n:
   addmult+n+<>ITEM+base item+n,(n=>>ITEM;corrupted obj file+_title_+_line_).

'a'read item-ID-flag-lineno:
   (* 0->flag->type->lineno->tag->adm->repr *)ITEM,
   must+Ttype+type*ITEM,must+Titem+ID,check item ID+ID,
   must+Tconst+flag,bool and+flag+titem mask+flag*ITEM,
   must+Tconst+lineno,
   (lineno<=0;
    lineno>max lineno,corrupted obj file+_title_+_line_;
    lineno->lineno*ITEM),
   (=type*ITEM=
    [Irule], store formal affixes+adm*ITEM;
    [Istack;Itable;Istatic stack], store list bounds+adm*ITEM;
    [Iconstant;Ivariable;Istatic var;Ipointer constant;
     Ichar file;Idata file],+;
    corrupted obj file+_title_+_line_),
   must+Tstring+tag*ITEM, enter item+>>ITEM.

'a'item section:
   R+Dpoint; read item,:item section.

'a'skip item section:
   R+Dpoint;next symbol,:skip item section.

$ head section ******************************************* $
$ each module has an ITEM entry linked through the repr field
'variable'
   max lineno=0,   $ maximal lineno in this module
   base item=0.    $ ITEM[base] describes this module

'table'MESSAGE=(
  "module %p: included twice" :same title
).

'a'check module title-ptr:
   base item->ptr,(nxt:ptr=0;
     tag*ITEM=tag*ITEM[ptr],warning+same title+tag*ITEM;
     repr*ITEM[ptr]->ptr,:nxt).

'a'head section-n-str:
  (* 0->flag->type->lineno->tag->adm->repr *)ITEM,
  (R+Dmodule,Dmodule->type*ITEM;R+Dtitle,Dtitle->type*ITEM;
   corrupted obj file+_title_+_line_),
  must+Tstring+tag*ITEM, check module title, $ warn for the same title 
  0->max lineno,
  (nxt: must+Tconst+n,(n>max lineno,n->max lineno;
                       corrupted obj file+_title_+_line_),
         must+Tstring+str,
         (* n->width,str->data *)AUX,(adm*ITEM=0,>>AUX->adm*ITEM;+),
         (R+Dpoint;:nxt)),
  max lineno->lineno*ITEM,
  (base item=0;>>ITEM->repr*ITEM[base item]),>>ITEM->base item.
  
'a'skip head section: $ advance base item $
  (nxt:R+Dpoint; next symbol,:nxt),
  (base item=0,<<ITEM->base item;
   repr*ITEM[base item]->base item),
  lineno*ITEM[base item]->max lineno.

'f'find lineno+>item+line>+str>+module>-ptr-nptr-l:
   <<ITEM->ptr,
   (nxt:repr*ITEM[ptr]->nptr,((is+nptr,nptr<item),nptr->ptr,:nxt;+)),
   tag*ITEM[ptr]->module,lineno*ITEM[item]->l,
   ((l<=0;l>lineno*ITEM[ptr]),0->line,Squote image->str;
    adm*ITEM[ptr]->ptr,l->line,
      (nxt:l>width*AUX[ptr],subtr+l+width*AUX[ptr]+line,add+ptr+2+ptr,:nxt;
           data*AUX[ptr]->str)).

$ check items for definition *********************************** $
'table'MESSAGE=(
).
'a'check all items-ptr:
  <<ITEM->ptr,
  (nxt:ptr>>>ITEM;+).
  


'root'+.
'pragmat'endif=compile.
'end'
