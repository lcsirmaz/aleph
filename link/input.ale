$ source input
'pragmat'module=input, title="input, v2.0".

$ *************************************************************
$  This code is part of ALEPH-M (Modular ALEPH-v2)
$
$  (C) 2020-2023, L.Csirmaz
$
$  ALEPH-M is a free software, your can redistribute and/or
$  modify it under the terms of the GNU General Public License
$  as published by the Free Software Foundation, either version
$  3 of the License, or (at your option) any later version.
$
$  ALEPH-M is distributed in the hope that it will be useful,
$  but  WITHOUT ANY WARRANTY; without even the implied warranty
$  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
$  the GNU General Public License for more details.
$
$ ************************************************************* 

$ HEADER ********************************************** $
$ store ice files in FILES; identify by pointers.
'a'check command line arguments.
   $ check arguments, set errno in case of error
'p'get next source+ptr>.
   $ open the next ice file with FILES index ptr
   $ handle 'include' files transparently
'a'open source+>ptr.
   $ open source with the given FILES ptr
'a'set source+>ptr.
   $ set the source for messages
'a'get target file.
   $ create the target .c file as >>LEXT, should be released.
$ error callback routines
'f'get ice file+ptr>.
   $ copy the actual source path to ptr
'q'was ice source+>ptr+str>.
   $ if ptr is in FILES, copy path to str
'q'not stdlib source.
   $ the actual source is not stblib
$ BODY ************************************************ $
'pragmat'if=compile.

'pragmat'require=("config","lexical","error","item","target").

'table'MESSAGE=(
"no input file specified, use --help for a short help"
                                     :no input,
"missing argument after -%c"         :missing argument,
"maximum number of sources (%d) exceeded"
                                     :maximum reached,
"error opening .ice file %p "        :opening source,
"embedded 'include' ice files in %p" :embedded include
).


'stack'[1](flags,path)FILES.
$ populate FILES as the sources are read. Files containing 'include'
$   lines replace the top FILES entry and add additional entries.
$   'include' files cannot be embedded (it won't be the top file).

$ FILES flags: how to open the file
'constant'Fext =0x01,   $ add extension
          Fpath=0x02,   $ add -L path
          Fstdp=0x04.   $ add standard path

'variable'libdir=0,     $ the -L command line argument
          main file=0,  $ main program index
          target file=0,$ -o argument (STDARG)
          file no=0,    $ number of added files
          actual ptr=0. $ actual FILES entry

'q'is file flag+>ptr+>mask-x:
    bool and+flags*FILES[ptr]+mask+x,is+x.
'a'set file flag+>ptr+>mask:
    bool or+flags*FILES[ptr]+mask+flags*FILES[ptr].

'a'extend BUFFER+>x: (* x->BUFFER *)BUFFER.
'a'extend FILES+>x:
    incr+file no,
      (file no<max input files,(* 0->flags,x->path *)FILES;
       fatal error+maximum reached+max input files).
$ -------------------------------------------------------------
$ check argument list for options
'variable'arg top=0,   $ next command line argument
          add stdlib=1,$ add stdlib
          libfile=0.   $ first library file

'q'is first arg+T[]+>str-eq:
   compare string+STDARG+arg top+T+str+eq,eq=0.
'a'check command line arguments:
   >>STDARG->arg top,1->add stdlib,(nxt:
    arg top < <<STDARG,error+no input;
    is first arg+"--help",message+help message;
    is first arg+"--version",message+version message+version major+version minor;
    is first arg+"-no-stdlib",0->add stdlib,
        previous string+STDARG+arg top,:nxt;
    is first arg+"-o",previous string+STDARG+arg top,
        (arg top < <<STDARG,error+missing argument+/o/;
         arg top->target file,previous string+STDARG+arg top,:nxt);
    is first arg+"-L",previous string+STDARG+arg top,
        (arg top < <<STDARG,error+missing argument+/L/;
         arg top->libdir,previous string+STDARG+arg top,:nxt);
    is first arg+"-W",report not used public items,
        previous string+STDARG+arg top,:nxt;
    is first arg+"-g",use call stack,
        previous string+STDARG+arg top,:nxt;
    +).

'p'get next source+ptr>-res:
    $ scan all input files. If actual ptr< >>FILES, process added entries
    $    first (they have been added by 'include')
    $ if no more cmd line arguments are, add stdlib; or fail
    (actual ptr=0,<<FILES->actual ptr;next+FILES+actual ptr),
    actual ptr->ptr,
    (nxt:ptr<= >>FILES, 
                 handle source file+ptr+res,(res=0;:nxt);
         <<STDARG <=arg top,extend FILES+arg top,
                 previous string+STDARG+arg top,
                 handle source file+ptr+res,(res=0;:nxt);
         is+add stdlib,extend FILES+stdlib file,>>FILES->libfile,
                 0->add stdlib,
                 handle source file+ptr+res,(res=0;:nxt)).
'q'not stdlib source:
   libfile=0;actual ptr=0;actual ptr<libfile.
$ --------------------------------------------------------------
$ copy .ice file to BUFFER for messages
'f'get ice file+ptr>:
    was ice source+actual ptr+ptr;0->ptr.
'q'was ice source+>ptr+str>:
    was+FILES+ptr,path*FILES[ptr]->str.
$ --------------------------------------------------------------
$ how to open a source:
$   Fext:   add .ice extension
$   Fpath:  add -L <path>, if specified
$   Fstdp:  add built-in standard search path

'a'add extension:
   extend BUFFER+/./,extend BUFFER+/i/,extend BUFFER+/c/,extend BUFFER+/e/.
'a'add dir separator:
   BUFFER=dir separator;extend BUFFER+dir separator.

'a'open BUFFER+res>-n:
   $ 0: OK, 1: not found, -1: error
   list length+BUFFER+n,
   (n<=0,1->res; $ not an empty source
    pack string+BUFFER+n+LEXT,scratch+BUFFER,
        close source,try to open source+res).
'a'string to BUFFER+>str:
   was+LEXT+str,get tag image+str+str,unpack string+LEXT+str+BUFFER;
   was+STDARG+str,unpack string+STDARG+str+BUFFER;
   internal error+_rule_.

'a'open file as given+>ptr+res>:
   $ open path*FILE[ptr] as specified by flags*FILES[ptr]
   $ res=0: OK, opened; res=1: not found; other errors: fatal
   scratch+BUFFER,
   (is file flag+ptr+Fpath,string to BUFFER+libdir,add dir separator;+),
   (is file flag+ptr+Fstdp,string to BUFFER+std search path,add dir separator;+),
   string to BUFFER+path*FILES[ptr],
   (is file flag+ptr+Fext,add extension;+),
   open BUFFER+res,(res>=0;fatal error+opening source+ptr).

'a'set source+>ptr: ptr->actual ptr.

'a'open source+>ptr-res:
   ptr=0,0->actual ptr;
   ptr->actual ptr, open file as given+ptr+res,
      (res=0;fatal error+opening source+ptr).

'a'try file first+>ptr+res>:
   $ determine if path*FILE[ptr] can be opened; store how it was opened
   (0->flags*FILES[ptr],open file as given+ptr+res,res=0);
   (set file flag+ptr+Fext,open file as given+ptr+res,res=0);
   (is+libdir,Fpath->flags*FILES[ptr],
         ((open file as given+ptr+res,res=0);
          (set file flag+ptr+Fext,open file as given+ptr+res,res=0);
          -));
    Fstdp->flags*FILES[ptr],
          ((open file as given+ptr+res,res=0);
           (set file flag+ptr+Fext,open file as given+ptr+res,res=0);
           +).

'a'handle source file+>ptr+res>:
    $ res=0: file opened OK
    $ res=1: 'include' lines are added; error if ptr!=>>FILES
    try file first+ptr+res,
       (is+res,fatal error+opening source+ptr;
        $ check if it is 'main';
        inpt=Dmain,ptr->main file;
        inpt=Dinclude,add included ice files+ptr,1->res;
        +).

'a'add included ice files+>ptr-str:
   $ ice file starts with 'include'; read sources and add to FILES
   ptr!=>>FILES,fatal error+embedded include+ptr;
   unstack+FILES,
   (nxt:R+Dinclude,must+Tstring+str,extend FILES+str,:nxt;
        close source).

$ --------------------------------------------------------------
$ create the target file name in >>LEXT
'a'get target file-oldp-ptr-n-nn-ext-pt:
   $ use the -o argument; otherwise the name of the main module
   (is+target file,0->ext,target file->ptr;
    1->ext,path*FILES[main file]->ptr),
     >>BUFFER->oldp,string to BUFFER+ptr,>>BUFFER->nn,1->pt,
        $ does it have an extension; if yes strip it
     (nxt:nn<=oldp; $ at the beginning
          (=BUFFER[nn]=
           [/./],(ext=0,2->ext,oldp->nn;  $ -o arg has extension
                  decr+nn,(is+pt,0->pt,unstack to+BUFFER+nn;+),:nxt);
           [///;/\/;/:/],(ext=1;oldp->nn);
           decr+nn,:nxt)),
     (ext=2;extend BUFFER+/./,extend BUFFER+/c/),
     subtr+>>BUFFER+nn+n,pack string+BUFFER+n+LEXT,unstack to+BUFFER+oldp.


'root'+.
'pragmat'endif=compile.
'end'


